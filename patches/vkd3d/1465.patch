From 6e3a11085cf2facc00e13f815801d462122e7a2e Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Mon, 13 Mar 2023 16:08:13 +0100
Subject: [PATCH 01/16] tests: Add multi execute indirect tests.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 tests/d3d12_command.c | 465 ++++++++++++++++++++++++++++++++++++++++++
 tests/d3d12_tests.h   |   3 +
 2 files changed, 468 insertions(+)

diff --git a/tests/d3d12_command.c b/tests/d3d12_command.c
index 05dd05630..716a7bca6 100644
--- a/tests/d3d12_command.c
+++ b/tests/d3d12_command.c
@@ -1449,6 +1449,471 @@ void test_vbv_stride_edge_cases(void)
     destroy_test_context(&context);
 }
 
+void test_execute_indirect_multi_dispatch_root_descriptors(void)
+{
+    const unsigned int max_indirect_count = 5;
+    D3D12_INDIRECT_ARGUMENT_DESC arguments[2];
+    D3D12_ROOT_PARAMETER root_params[1];
+    ID3D12CommandSignature *signature;
+    D3D12_COMMAND_SIGNATURE_DESC desc;
+    D3D12_ROOT_SIGNATURE_DESC rs_desc;
+    struct resource_readback rb;
+    struct test_context context;
+    ID3D12Resource *indirect;
+    unsigned int test_index;
+    ID3D12Resource *output;
+    unsigned int iteration;
+    unsigned int i;
+    HRESULT hr;
+
+    struct test_data
+    {
+        uint32_t dispatch_counts[4];
+        struct
+        {
+            D3D12_GPU_VIRTUAL_ADDRESS va;
+            uint32_t wg_x, wg_y, wg_z;
+        } dispatches[16];
+    } indirect_data = {
+        { 2, 7, 4, 13 },
+        {
+            { 0, 2, 3, 4 },
+            { 0, 5, 6, 7 },
+            { 0, 8, 9, 10 },
+            { 0, 11, 3, 12 },
+            { 0, 6, 13, 14 },
+            { 0, 13, 14, 15 },
+            { 0, 16, 17, 18 },
+            { 0, 19, 18, 7 },
+            { 0, 2, 3, 4 },
+            { 0, 5, 6, 7 },
+            { 0, 8, 9, 10 },
+            { 0, 11, 3, 12 },
+            { 0, 6, 13, 14 },
+            { 0, 13, 14, 15 },
+            { 0, 16, 17, 18 },
+            { 0, 19, 18, 7 },
+        },
+    };
+
+    uint32_t expected_counts[ARRAY_SIZE(indirect_data.dispatches)] = { 0 };
+
+    static const DWORD cs_code_dxbc[] =
+    {
+#if 0
+    RWStructuredBuffer<uint> RWBuf : register(u0);
+
+    [numthreads(1, 1, 1)]
+    void main()
+    {
+            uint o;
+            InterlockedAdd(RWBuf[0], 1, o);
+    }
+#endif
+        0x43425844, 0x9de05180, 0xc4ce6696, 0x888b971b, 0x17d7d33f, 0x00000001, 0x000000ac, 0x00000003,
+        0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+        0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x00000058, 0x00050050, 0x00000016, 0x0100086a,
+        0x0400009e, 0x0011e000, 0x00000000, 0x00000004, 0x0400009b, 0x00000001, 0x00000001, 0x00000001,
+        0x0a0000ad, 0x0011e000, 0x00000000, 0x00004002, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+        0x00004001, 0x00000001, 0x0100003e,
+    };
+
+    static const D3D12_SHADER_BYTECODE cs_code = SHADER_BYTECODE(cs_code_dxbc);
+
+    if (!init_compute_test_context(&context))
+        return;
+
+    desc.ByteStride = sizeof(indirect_data.dispatches[0]);
+    desc.NodeMask = 0;
+    desc.NumArgumentDescs = ARRAY_SIZE(arguments);
+    desc.pArgumentDescs = arguments;
+
+    memset(&rs_desc, 0, sizeof(rs_desc));
+    memset(root_params, 0, sizeof(root_params));
+    rs_desc.NumParameters = ARRAY_SIZE(root_params);
+    rs_desc.pParameters = root_params;
+    root_params[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
+    root_params[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_UAV;
+    create_root_signature(context.device, &rs_desc, &context.root_signature);
+
+    context.pipeline_state = create_compute_pipeline_state(context.device, context.root_signature, cs_code);
+
+    memset(arguments, 0, sizeof(arguments));
+    arguments[0].Type = D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW;
+    arguments[0].UnorderedAccessView.RootParameterIndex = 0;
+    arguments[1].Type = D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH;
+    hr = ID3D12Device_CreateCommandSignature(context.device, &desc, context.root_signature, &IID_ID3D12CommandSignature, (void **)&signature);
+    if (FAILED(hr))
+        signature = NULL;
+    todo ok(SUCCEEDED(hr), "Failed to create command signature, hr #%x.\n", hr);
+
+    output = create_default_buffer(context.device, ARRAY_SIZE(indirect_data.dispatches) * 4, D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
+    for (i = 0; i < ARRAY_SIZE(indirect_data.dispatches); i++)
+        indirect_data.dispatches[i].va = ID3D12Resource_GetGPUVirtualAddress(output) + 4 * i;
+
+    indirect = create_upload_buffer(context.device, sizeof(indirect_data), &indirect_data);
+
+    ID3D12GraphicsCommandList_SetComputeRootSignature(context.list, context.root_signature);
+    ID3D12GraphicsCommandList_SetPipelineState(context.list, context.pipeline_state);
+
+    for (test_index = 0; test_index < 8 && signature; test_index++)
+    {
+        iteration = test_index & 3;
+
+        if (test_index < 4)
+        {
+            /* Multi-dispatch, direct count. */
+            ID3D12GraphicsCommandList_ExecuteIndirect(context.list, signature, indirect_data.dispatch_counts[iteration],
+                    indirect, offsetof(struct test_data, dispatches[test_index]), NULL, 0);
+        }
+        else
+        {
+            /* Indirect count style. */
+            ID3D12GraphicsCommandList_ExecuteIndirect(context.list, signature, max_indirect_count,
+                    indirect, offsetof(struct test_data, dispatches[test_index]),
+                    indirect, offsetof(struct test_data, dispatch_counts[iteration]));
+        }
+    }
+
+    transition_resource_state(context.list, output, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COPY_SOURCE);
+
+    get_buffer_readback_with_command_list(output, DXGI_FORMAT_UNKNOWN, &rb, context.queue, context.list);
+
+    for (test_index = 0; test_index < 8; test_index++)
+    {
+        unsigned int num_dispatches;
+        iteration = test_index & 3;
+        num_dispatches = test_index < 4 ?
+            indirect_data.dispatch_counts[iteration] :
+            min(indirect_data.dispatch_counts[iteration], max_indirect_count);
+
+        for (i = test_index; i < num_dispatches + test_index; i++)
+        {
+            expected_counts[i] +=
+                indirect_data.dispatches[i].wg_x *
+                indirect_data.dispatches[i].wg_y *
+                indirect_data.dispatches[i].wg_z;
+        }
+    }
+
+    for (i = 0; i < ARRAY_SIZE(indirect_data.dispatches); i++)
+    {
+        uint32_t value;
+        value = get_readback_uint(&rb, i, 0, 0);
+        todo ok(value == expected_counts[i], "Value %u: Expected %u, got %u.\n", i, expected_counts[i], value);
+    }
+
+    release_resource_readback(&rb);
+    ID3D12Resource_Release(indirect);
+    ID3D12Resource_Release(output);
+    if (signature)
+        ID3D12CommandSignature_Release(signature);
+
+    destroy_test_context(&context);
+}
+
+void test_execute_indirect_multi_dispatch_root_constants(void)
+{
+    const unsigned int max_indirect_count = 5;
+    D3D12_INDIRECT_ARGUMENT_DESC arguments[2];
+    D3D12_ROOT_PARAMETER root_params[2];
+    ID3D12CommandSignature *signature;
+    D3D12_COMMAND_SIGNATURE_DESC desc;
+    D3D12_ROOT_SIGNATURE_DESC rs_desc;
+    struct resource_readback rb;
+    struct test_context context;
+    ID3D12Resource *indirect;
+    unsigned int test_index;
+    ID3D12Resource *output;
+    unsigned int iteration;
+    HRESULT hr;
+
+    static const uint32_t indirect_data[] = {
+        1, 8, 3, 6, /* indirect multi dispatch counts */
+        13, 10, 20, 30, /* root constant u32 + dispatch group counts */
+        14, 11, 21, 31,
+        15, 0, 22, 32,
+        16, 13, 23, 0,
+        17, 10, 20, 30,
+        18, 11, 21, 31,
+        19, 12, 22, 32,
+        20, 13, 23, 33,
+        21, 10, 20, 30,
+        22, 11, 21, 31,
+        23, 12, 22, 32,
+        24, 13, 23, 33,
+        25, 10, 20, 30,
+        26, 11, 21, 31,
+        27, 12, 22, 32,
+        28, 13, 23, 33,
+    };
+
+    static const DWORD cs_code_dxbc[] =
+    {
+#if 0
+    RWStructuredBuffer<uint> RWBuf : register(u0);
+    cbuffer C : register(b0) { uint4 v; };
+
+    [numthreads(1, 1, 1)]
+    void main()
+    {
+            uint o;
+            InterlockedAdd(RWBuf[0], v.x | v.y | v.z | v.w, o);
+    }
+#endif
+        0x43425844, 0x7a70560a, 0x4aa2793e, 0x14ed39f7, 0xa8aea1d3, 0x00000001, 0x00000128, 0x00000003,
+        0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+        0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000d4, 0x00050050, 0x00000035, 0x0100086a,
+        0x04000059, 0x00208e46, 0x00000000, 0x00000001, 0x0400009e, 0x0011e000, 0x00000000, 0x00000004,
+        0x02000068, 0x00000001, 0x0400009b, 0x00000001, 0x00000001, 0x00000001, 0x0900003c, 0x00100012,
+        0x00000000, 0x0020801a, 0x00000000, 0x00000000, 0x0020800a, 0x00000000, 0x00000000, 0x0800003c,
+        0x00100012, 0x00000000, 0x0010000a, 0x00000000, 0x0020802a, 0x00000000, 0x00000000, 0x0800003c,
+        0x00100012, 0x00000000, 0x0010000a, 0x00000000, 0x0020803a, 0x00000000, 0x00000000, 0x0a0000ad,
+        0x0011e000, 0x00000000, 0x00004002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0010000a,
+        0x00000000, 0x0100003e,
+    };
+
+    static const D3D12_SHADER_BYTECODE cs_code = SHADER_BYTECODE(cs_code_dxbc);
+
+    if (!init_compute_test_context(&context))
+        return;
+
+    desc.ByteStride = sizeof(uint32_t) + sizeof(D3D12_DISPATCH_ARGUMENTS);
+    desc.NodeMask = 0;
+    desc.NumArgumentDescs = ARRAY_SIZE(arguments);
+    desc.pArgumentDescs = arguments;
+
+    memset(&rs_desc, 0, sizeof(rs_desc));
+    memset(root_params, 0, sizeof(root_params));
+    rs_desc.NumParameters = ARRAY_SIZE(root_params);
+    rs_desc.pParameters = root_params;
+    root_params[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
+    root_params[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_UAV;
+    root_params[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
+    root_params[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS;
+    root_params[1].Constants.Num32BitValues = 4;
+    create_root_signature(context.device, &rs_desc, &context.root_signature);
+
+    context.pipeline_state = create_compute_pipeline_state(context.device, context.root_signature, cs_code);
+
+    memset(arguments, 0, sizeof(arguments));
+    arguments[0].Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT;
+    arguments[0].Constant.RootParameterIndex = 1;
+    arguments[0].Constant.Num32BitValuesToSet = 1;
+    arguments[0].Constant.DestOffsetIn32BitValues = 2;
+    arguments[1].Type = D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH;
+    hr = ID3D12Device_CreateCommandSignature(context.device, &desc, context.root_signature, &IID_ID3D12CommandSignature, (void **)&signature);
+    if (FAILED(hr))
+        signature = NULL;
+    todo ok(SUCCEEDED(hr), "Failed to create command signature, hr #%x.\n", hr);
+
+    output = create_default_buffer(context.device, 8 * 4, D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
+    indirect = create_upload_buffer(context.device, sizeof(indirect_data), indirect_data);
+
+    ID3D12GraphicsCommandList_SetComputeRootSignature(context.list, context.root_signature);
+    ID3D12GraphicsCommandList_SetPipelineState(context.list, context.pipeline_state);
+
+    for (test_index = 0; test_index < 8 && signature; test_index++)
+    {
+        iteration = test_index & 3;
+
+        ID3D12GraphicsCommandList_SetComputeRootUnorderedAccessView(context.list, 0,
+            ID3D12Resource_GetGPUVirtualAddress(output) + 4 * test_index);
+
+        ID3D12GraphicsCommandList_SetComputeRoot32BitConstant(context.list, 1, 1, 0);
+        ID3D12GraphicsCommandList_SetComputeRoot32BitConstant(context.list, 1, 2, 1);
+        ID3D12GraphicsCommandList_SetComputeRoot32BitConstant(context.list, 1, 3, 2);
+        ID3D12GraphicsCommandList_SetComputeRoot32BitConstant(context.list, 1, 4, 3);
+
+        if (test_index < 4)
+        {
+            /* Multi-dispatch, direct count. */
+            ID3D12GraphicsCommandList_ExecuteIndirect(context.list, signature, indirect_data[iteration], indirect, 16 + 16 * test_index, NULL, 0);
+        }
+        else
+        {
+            /* Indirect count style. */
+            ID3D12GraphicsCommandList_ExecuteIndirect(context.list, signature, max_indirect_count,
+                indirect, 16 + 16 * test_index,
+                indirect, 4 * iteration);
+        }
+
+        /* Also test behavior for cleared root constant state. cbv.z should be cleared to 0 here. */
+        ID3D12GraphicsCommandList_Dispatch(context.list, 1, 1, 1);
+    }
+
+    transition_resource_state(context.list, output, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COPY_SOURCE);
+
+    get_buffer_readback_with_command_list(output, DXGI_FORMAT_UNKNOWN, &rb, context.queue, context.list);
+
+    for (test_index = 0; test_index < 8; test_index++)
+    {
+        unsigned int num_dispatches, expected, expected_cbv, value, i;
+        iteration = test_index & 3;
+        num_dispatches = test_index < 4 ? indirect_data[iteration] : min(indirect_data[iteration], max_indirect_count);
+        expected = 0;
+
+        for (i = test_index; i < num_dispatches + test_index; i++)
+        {
+            expected_cbv = 1 | 2 | 4; /* x, y and w elements are untouched. */
+            expected_cbv |= indirect_data[4 + 4 * i + 0];
+
+            expected += expected_cbv *
+                    indirect_data[4 + 4 * i + 1] *
+                    indirect_data[4 + 4 * i + 2] *
+                    indirect_data[4 + 4 * i + 3];
+        }
+        expected += 7; /* For the single 1, 1, 1 dispatch. */
+        value = get_readback_uint(&rb, test_index, 0, 0);
+        todo ok(value == expected, "Iteration %u: Expected %u, got %u.\n", test_index, expected, value);
+    }
+
+    release_resource_readback(&rb);
+    ID3D12Resource_Release(indirect);
+    ID3D12Resource_Release(output);
+    if (signature)
+        ID3D12CommandSignature_Release(signature);
+
+    destroy_test_context(&context);
+}
+
+void test_execute_indirect_multi_dispatch(void)
+{
+    const unsigned int max_indirect_count = 5;
+    D3D12_INDIRECT_ARGUMENT_DESC arguments[1];
+    ID3D12CommandSignature *signature;
+    D3D12_COMMAND_SIGNATURE_DESC desc;
+    D3D12_ROOT_SIGNATURE_DESC rs_desc;
+    D3D12_ROOT_PARAMETER root_param;
+    struct resource_readback rb;
+    struct test_context context;
+    ID3D12Resource *indirect;
+    unsigned int test_index;
+    ID3D12Resource *output;
+    unsigned int iteration;
+    HRESULT hr;
+
+    /* Simple multi dispatch indirect without state changes. */
+
+    static const uint32_t indirect_data[] = {
+        1, 8, 3, 6, /* indirect multi dispatch counts */
+        10, 20, 30, /* dispatch group counts */
+        11, 21, 31,
+        0, 22, 32,
+        13, 23, 0,
+        10, 20, 30,
+        11, 21, 31,
+        12, 22, 32,
+        13, 23, 33,
+        10, 20, 30,
+        11, 21, 31,
+        12, 22, 32,
+        13, 23, 33,
+        10, 20, 30,
+        11, 21, 31,
+        12, 22, 32,
+        13, 23, 33,
+    };
+
+    static const DWORD cs_code_dxbc[] =
+    {
+#if 0
+    RWStructuredBuffer<uint> RWBuf : register(u0);
+
+    [numthreads(1, 1, 1)]
+    void main()
+    {
+            uint o;
+            InterlockedAdd(RWBuf[0], 1, o);
+    }
+#endif
+        0x43425844, 0x9de05180, 0xc4ce6696, 0x888b971b, 0x17d7d33f, 0x00000001, 0x000000ac, 0x00000003,
+        0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+        0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x00000058, 0x00050050, 0x00000016, 0x0100086a,
+        0x0400009e, 0x0011e000, 0x00000000, 0x00000004, 0x0400009b, 0x00000001, 0x00000001, 0x00000001,
+        0x0a0000ad, 0x0011e000, 0x00000000, 0x00004002, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+        0x00004001, 0x00000001, 0x0100003e,
+    };
+
+    static const D3D12_SHADER_BYTECODE cs_code = SHADER_BYTECODE(cs_code_dxbc);
+
+    if (!init_compute_test_context(&context))
+        return;
+
+    memset(&rs_desc, 0, sizeof(rs_desc));
+    memset(&root_param, 0, sizeof(root_param));
+    rs_desc.NumParameters = 1;
+    rs_desc.pParameters = &root_param;
+    root_param.ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
+    root_param.ParameterType = D3D12_ROOT_PARAMETER_TYPE_UAV;
+    create_root_signature(context.device, &rs_desc, &context.root_signature);
+
+    context.pipeline_state = create_compute_pipeline_state(context.device, context.root_signature, cs_code);
+
+    desc.ByteStride = sizeof(D3D12_DISPATCH_ARGUMENTS);
+    desc.NodeMask = 0;
+    desc.NumArgumentDescs = ARRAY_SIZE(arguments);
+    desc.pArgumentDescs = arguments;
+
+    memset(arguments, 0, sizeof(arguments));
+    arguments[0].Type = D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH;
+    hr = ID3D12Device_CreateCommandSignature(context.device, &desc, NULL, &IID_ID3D12CommandSignature, (void **)&signature);
+    ok(SUCCEEDED(hr), "Failed to create command signature, hr #%x.\n", hr);
+
+    output = create_default_buffer(context.device, 8 * 4, D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
+    indirect = create_upload_buffer(context.device, sizeof(indirect_data), indirect_data);
+
+    ID3D12GraphicsCommandList_SetComputeRootSignature(context.list, context.root_signature);
+    ID3D12GraphicsCommandList_SetPipelineState(context.list, context.pipeline_state);
+
+    for (test_index = 0; test_index < 8; test_index++)
+    {
+        iteration = test_index & 3;
+
+        ID3D12GraphicsCommandList_SetComputeRootUnorderedAccessView(context.list, 0,
+                ID3D12Resource_GetGPUVirtualAddress(output) + 4 * test_index);
+
+        if (test_index < 4)
+        {
+            /* Multi-dispatch, direct count. */
+            ID3D12GraphicsCommandList_ExecuteIndirect(context.list, signature, indirect_data[iteration], indirect, 16 + 12 * test_index, NULL, 0);
+        }
+        else
+        {
+            /* Indirect count style. */
+            ID3D12GraphicsCommandList_ExecuteIndirect(context.list, signature, max_indirect_count,
+                    indirect, 16 + 12 * test_index,
+                    indirect, 4 * iteration);
+        }
+    }
+
+    transition_resource_state(context.list, output, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COPY_SOURCE);
+    get_buffer_readback_with_command_list(output, DXGI_FORMAT_UNKNOWN, &rb, context.queue, context.list);
+
+    for (test_index = 0; test_index < 8; test_index++)
+    {
+        unsigned int num_dispatches, expected, value, i;
+        iteration = test_index & 3;
+        num_dispatches = test_index < 4 ? indirect_data[iteration] : min(indirect_data[iteration], max_indirect_count);
+        expected = 0;
+        for (i = test_index; i < num_dispatches + test_index; i++)
+        {
+            expected += indirect_data[4 + 3 * i + 0] *
+                    indirect_data[4 + 3 * i + 1] *
+                    indirect_data[4 + 3 * i + 2];
+        }
+        value = get_readback_uint(&rb, test_index, 0, 0);
+        todo ok(value == expected, "Iteration %u: Expected %u, got %u.\n", test_index, expected, value);
+    }
+
+    release_resource_readback(&rb);
+    ID3D12Resource_Release(indirect);
+    ID3D12Resource_Release(output);
+    ID3D12CommandSignature_Release(signature);
+
+    destroy_test_context(&context);
+}
+
 void test_execute_indirect_state(void)
 {
     static const struct vec4 values = { 1000.0f, 2000.0f, 3000.0f, 4000.0f };
diff --git a/tests/d3d12_tests.h b/tests/d3d12_tests.h
index 7e0075722..ada6bca0c 100644
--- a/tests/d3d12_tests.h
+++ b/tests/d3d12_tests.h
@@ -139,6 +139,9 @@ decl_test(test_resolve_query_data_in_different_command_list);
 decl_test(test_resolve_query_data_in_reordered_command_list);
 decl_test(test_execute_indirect);
 decl_test(test_execute_indirect_state);
+decl_test(test_execute_indirect_multi_dispatch);
+decl_test(test_execute_indirect_multi_dispatch_root_constants);
+decl_test(test_execute_indirect_multi_dispatch_root_descriptors);
 decl_test(test_dispatch_zero_thread_groups);
 decl_test(test_unaligned_vertex_stride);
 decl_test(test_zero_vertex_stride);

From 4296ecfe219fc0af552e8719cc139ed9f9cf6dff Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Tue, 14 Mar 2023 14:03:11 +0100
Subject: [PATCH 02/16] vkd3d: Implement multi-dispatch indirect without count.

Trivially unrolled.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index b7c99ae4e..69ab76bdb 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -11516,9 +11516,6 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH:
-                if (max_command_count != 1)
-                    FIXME("Ignoring command count %u.\n", max_command_count);
-
                 if (count_buffer)
                 {
                     FIXME_ONCE("Count buffers not supported for indirect dispatch.\n");
@@ -11531,7 +11528,13 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
                     break;
                 }
 
-                VK_CALL(vkCmdDispatchIndirect(list->vk_command_buffer, scratch.buffer, scratch.offset));
+                /* Without state changes, we can always just unroll the dispatches.
+                 * Not the most useful feature ever, but it has to work. */
+                for (i = 0; i < max_command_count; i++)
+                {
+                    VK_CALL(vkCmdDispatchIndirect(list->vk_command_buffer, scratch.buffer, scratch.offset));
+                    scratch.offset += signature_desc->ByteStride;
+                }
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH_RAYS:

From 16f991460ae6d47ba8568ea05ddec6dd00df82da Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Tue, 14 Mar 2023 15:12:14 +0100
Subject: [PATCH 03/16] vkd3d: Implement multi-dispatch indirect with count.

No state change support yet.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c       | 92 +++++++++++++++++++++++++++++++++-----
 libs/vkd3d/meson.build     |  1 +
 libs/vkd3d/meta.c          | 51 +++++++++++++++++++++
 libs/vkd3d/vkd3d_private.h | 35 +++++++++++++++
 libs/vkd3d/vkd3d_shaders.h |  1 +
 5 files changed, 170 insertions(+), 10 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 69ab76bdb..86d6feeed 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -6174,6 +6174,66 @@ static void d3d12_command_list_check_index_buffer_strip_cut_value(struct d3d12_c
     }
 }
 
+static bool d3d12_command_list_emit_multi_dispatch_indirect_count(struct d3d12_command_list *list,
+        VkDeviceAddress indirect_args, uint32_t stride, uint32_t max_commands,
+        VkDeviceAddress count_arg,
+        struct vkd3d_scratch_allocation *scratch)
+{
+    const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
+    struct vkd3d_multi_dispatch_indirect_info pipeline_info;
+    struct vkd3d_multi_dispatch_indirect_args args;
+    VkMemoryBarrier vk_barrier;
+
+    vkd3d_meta_get_multi_dispatch_indirect_pipeline(&list->device->meta_ops, &pipeline_info);
+
+    if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
+            VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
+            sizeof(VkDispatchIndirectCommand) * max_commands, sizeof(uint32_t), ~0u, scratch))
+        return false;
+
+    d3d12_command_list_end_current_render_pass(list, true);
+    d3d12_command_list_invalidate_current_pipeline(list, true);
+    d3d12_command_list_invalidate_root_parameters(list, &list->compute_bindings, true);
+
+    args.indirect_va = indirect_args;
+    args.count_va = count_arg;
+    args.output_va = scratch->va;
+    args.stride_words = stride / sizeof(uint32_t);
+    args.max_commands = max_commands;
+
+    /* TODO: We can hoist the command similar to execute indirect template resolve. */
+
+    VK_CALL(vkCmdBindPipeline(list->vk_command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
+            pipeline_info.vk_pipeline));
+    VK_CALL(vkCmdPushConstants(list->vk_command_buffer,
+            pipeline_info.vk_pipeline_layout, VK_SHADER_STAGE_COMPUTE_BIT,
+            0, sizeof(args), &args));
+
+    vk_barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
+    vk_barrier.pNext = NULL;
+    vk_barrier.srcAccessMask = 0;
+    vk_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
+
+    VK_CALL(vkCmdPipelineBarrier(list->vk_command_buffer,
+            VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+            0, 1, &vk_barrier, 0, NULL, 0, NULL));
+
+    VK_CALL(vkCmdDispatch(list->vk_command_buffer,
+            vkd3d_compute_workgroup_count(max_commands, vkd3d_meta_get_multi_dispatch_indirect_workgroup_size()),
+            1, 1));
+
+    vk_barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+    vk_barrier.dstAccessMask = VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
+
+    VK_CALL(vkCmdPipelineBarrier(list->vk_command_buffer,
+            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+            VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+            0, 1, &vk_barrier, 0, NULL, 0, NULL));
+
+    return true;
+}
+
 static bool d3d12_command_list_emit_predicated_command(struct d3d12_command_list *list,
         enum vkd3d_predicate_command_type command_type, VkDeviceAddress indirect_args,
         const union vkd3d_predicate_command_direct_args *direct_args, struct vkd3d_scratch_allocation *scratch)
@@ -11353,6 +11413,7 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
     const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
     const D3D12_COMMAND_SIGNATURE_DESC *signature_desc = &sig_impl->desc;
     struct vkd3d_scratch_allocation scratch;
+    uint32_t unrolled_stride;
     unsigned int i;
 
     TRACE("iface %p, command_signature %p, max_command_count %u, arg_buffer %p, "
@@ -11369,6 +11430,8 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
         return;
     }
 
+    unrolled_stride = signature_desc->ByteStride;
+
     VKD3D_BREADCRUMB_TAG("ExecuteIndirect [MaxCommandCount, ArgBuffer cookie, ArgBuffer offset, Count cookie, Count offset]");
     VKD3D_BREADCRUMB_AUX32(max_command_count);
     VKD3D_BREADCRUMB_AUX64(arg_impl->res.cookie);
@@ -11436,9 +11499,24 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
         }
         else if (count_buffer)
         {
-            scratch.buffer = count_impl->res.vk_buffer;
-            scratch.offset = count_impl->mem.offset + count_buffer_offset;
-            scratch.va = count_impl->res.va + count_buffer_offset;
+            /* Unroll to N normal indirect dispatches, use count buffer to mask dispatches to (0, 0, 0).
+             * Can use this path for indirect trace rays as well since as needed. */
+            if (arg_desc->Type == D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH)
+            {
+                if (!d3d12_command_list_emit_multi_dispatch_indirect_count(list,
+                        arg_impl->res.va + arg_buffer_offset,
+                        unrolled_stride, max_command_count,
+                        count_impl->res.va + count_buffer_offset, &scratch))
+                    return;
+
+                unrolled_stride = sizeof(VkDispatchIndirectCommand);
+            }
+            else
+            {
+                scratch.buffer = count_impl->res.vk_buffer;
+                scratch.offset = count_impl->mem.offset + count_buffer_offset;
+                scratch.va = count_impl->res.va + count_buffer_offset;
+            }
         }
         else
         {
@@ -11516,12 +11594,6 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH:
-                if (count_buffer)
-                {
-                    FIXME_ONCE("Count buffers not supported for indirect dispatch.\n");
-                    break;
-                }
-
                 if (!d3d12_command_list_update_compute_state(list))
                 {
                     WARN("Failed to update compute state, ignoring dispatch.\n");
@@ -11533,7 +11605,7 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
                 for (i = 0; i < max_command_count; i++)
                 {
                     VK_CALL(vkCmdDispatchIndirect(list->vk_command_buffer, scratch.buffer, scratch.offset));
-                    scratch.offset += signature_desc->ByteStride;
+                    scratch.offset += unrolled_stride;
                 }
                 break;
 
diff --git a/libs/vkd3d/meson.build b/libs/vkd3d/meson.build
index ef564aa0b..9668b2744 100644
--- a/libs/vkd3d/meson.build
+++ b/libs/vkd3d/meson.build
@@ -29,6 +29,7 @@ vkd3d_shaders =[
   'shaders/fs_swapchain_fullscreen.frag',
   'shaders/cs_execute_indirect_patch.comp',
   'shaders/cs_execute_indirect_patch_debug_ring.comp',
+  'shaders/cs_execute_indirect_multi_dispatch.comp',
 ]
 
 vkd3d_src = [
diff --git a/libs/vkd3d/meta.c b/libs/vkd3d/meta.c
index 75731f2d3..9f6cea2b0 100644
--- a/libs/vkd3d/meta.c
+++ b/libs/vkd3d/meta.c
@@ -1111,6 +1111,44 @@ bool vkd3d_meta_get_query_gather_pipeline(struct vkd3d_meta_ops *meta_ops,
     }
 }
 
+HRESULT vkd3d_multi_dispatch_indirect_ops_init(
+        struct vkd3d_multi_dispatch_indirect_ops *meta_multi_dispatch_indirect_ops,
+        struct d3d12_device *device)
+{
+    VkPushConstantRange push_constant_range;
+    VkResult vr;
+
+    memset(meta_multi_dispatch_indirect_ops, 0, sizeof(*meta_multi_dispatch_indirect_ops));
+    push_constant_range.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
+    push_constant_range.offset = 0;
+    push_constant_range.size = sizeof(struct vkd3d_multi_dispatch_indirect_args);
+
+    if ((vr = vkd3d_meta_create_pipeline_layout(device, 0, NULL, 1,
+            &push_constant_range, &meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_layout)) < 0)
+        return hresult_from_vk_result(vr);
+
+    if ((vr = vkd3d_meta_create_compute_pipeline(device,
+            sizeof(cs_execute_indirect_multi_dispatch), cs_execute_indirect_multi_dispatch,
+            meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_layout, NULL, true,
+            &meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_pipeline)) < 0)
+        goto fail;
+
+    return S_OK;
+
+fail:
+    vkd3d_multi_dispatch_indirect_ops_cleanup(meta_multi_dispatch_indirect_ops, device);
+    return hresult_from_vk_result(vr);
+}
+
+void vkd3d_multi_dispatch_indirect_ops_cleanup(
+        struct vkd3d_multi_dispatch_indirect_ops *meta_multi_dispatch_indirect_ops,
+        struct d3d12_device *device)
+{
+    const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
+    VK_CALL(vkDestroyPipeline(device->vk_device, meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_pipeline, NULL));
+    VK_CALL(vkDestroyPipelineLayout(device->vk_device, meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_layout, NULL));
+}
+
 HRESULT vkd3d_predicate_ops_init(struct vkd3d_predicate_ops *meta_predicate_ops,
         struct d3d12_device *device)
 {
@@ -1204,6 +1242,13 @@ void vkd3d_meta_get_predicate_pipeline(struct vkd3d_meta_ops *meta_ops,
     info->data_size = predicate_ops->data_sizes[command_type];
 }
 
+void vkd3d_meta_get_multi_dispatch_indirect_pipeline(struct vkd3d_meta_ops *meta_ops,
+        struct vkd3d_multi_dispatch_indirect_info *info)
+{
+    info->vk_pipeline = meta_ops->multi_dispatch_indirect.vk_multi_dispatch_indirect_pipeline;
+    info->vk_pipeline_layout = meta_ops->multi_dispatch_indirect.vk_multi_dispatch_indirect_layout;
+}
+
 HRESULT vkd3d_execute_indirect_ops_init(struct vkd3d_execute_indirect_ops *meta_indirect_ops,
         struct d3d12_device *device)
 {
@@ -1370,8 +1415,13 @@ HRESULT vkd3d_meta_ops_init(struct vkd3d_meta_ops *meta_ops, struct d3d12_device
     if (FAILED(hr = vkd3d_execute_indirect_ops_init(&meta_ops->execute_indirect, device)))
         goto fail_execute_indirect_ops;
 
+    if (FAILED(hr = vkd3d_multi_dispatch_indirect_ops_init(&meta_ops->multi_dispatch_indirect, device)))
+        goto fail_multi_dispatch_indirect_ops;
+
     return S_OK;
 
+fail_multi_dispatch_indirect_ops:
+    vkd3d_execute_indirect_ops_cleanup(&meta_ops->execute_indirect, device);
 fail_execute_indirect_ops:
     vkd3d_predicate_ops_cleanup(&meta_ops->predicate, device);
 fail_predicate_ops:
@@ -1390,6 +1440,7 @@ HRESULT vkd3d_meta_ops_init(struct vkd3d_meta_ops *meta_ops, struct d3d12_device
 
 HRESULT vkd3d_meta_ops_cleanup(struct vkd3d_meta_ops *meta_ops, struct d3d12_device *device)
 {
+    vkd3d_multi_dispatch_indirect_ops_cleanup(&meta_ops->multi_dispatch_indirect, device);
     vkd3d_execute_indirect_ops_cleanup(&meta_ops->execute_indirect, device);
     vkd3d_predicate_ops_cleanup(&meta_ops->predicate, device);
     vkd3d_query_ops_cleanup(&meta_ops->query, device);
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 54d336e38..ff260a949 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -3733,6 +3733,32 @@ HRESULT vkd3d_predicate_ops_init(struct vkd3d_predicate_ops *meta_predicate_ops,
 void vkd3d_predicate_ops_cleanup(struct vkd3d_predicate_ops *meta_predicate_ops,
         struct d3d12_device *device);
 
+struct vkd3d_multi_dispatch_indirect_info
+{
+    VkPipelineLayout vk_pipeline_layout;
+    VkPipeline vk_pipeline;
+};
+
+struct vkd3d_multi_dispatch_indirect_args
+{
+    VkDeviceAddress indirect_va;
+    VkDeviceAddress count_va;
+    VkDeviceAddress output_va;
+    uint32_t stride_words;
+    uint32_t max_commands;
+};
+
+struct vkd3d_multi_dispatch_indirect_ops
+{
+    VkPipelineLayout vk_multi_dispatch_indirect_layout;
+    VkPipeline vk_multi_dispatch_indirect_pipeline;
+};
+
+HRESULT vkd3d_multi_dispatch_indirect_ops_init(struct vkd3d_multi_dispatch_indirect_ops *meta_predicate_ops,
+        struct d3d12_device *device);
+void vkd3d_multi_dispatch_indirect_ops_cleanup(struct vkd3d_multi_dispatch_indirect_ops *meta_predicate_ops,
+        struct d3d12_device *device);
+
 struct vkd3d_execute_indirect_args
 {
     VkDeviceAddress template_va;
@@ -3784,6 +3810,7 @@ struct vkd3d_meta_ops
     struct vkd3d_query_ops query;
     struct vkd3d_predicate_ops predicate;
     struct vkd3d_execute_indirect_ops execute_indirect;
+    struct vkd3d_multi_dispatch_indirect_ops multi_dispatch_indirect;
 };
 
 HRESULT vkd3d_meta_ops_init(struct vkd3d_meta_ops *meta_ops, struct d3d12_device *device);
@@ -3816,6 +3843,14 @@ bool vkd3d_meta_get_query_gather_pipeline(struct vkd3d_meta_ops *meta_ops,
 void vkd3d_meta_get_predicate_pipeline(struct vkd3d_meta_ops *meta_ops,
         enum vkd3d_predicate_command_type command_type, struct vkd3d_predicate_command_info *info);
 
+void vkd3d_meta_get_multi_dispatch_indirect_pipeline(struct vkd3d_meta_ops *meta_ops,
+        struct vkd3d_multi_dispatch_indirect_info *info);
+
+static inline uint32_t vkd3d_meta_get_multi_dispatch_indirect_workgroup_size(void)
+{
+    return 32;
+}
+
 HRESULT vkd3d_meta_get_execute_indirect_pipeline(struct vkd3d_meta_ops *meta_ops,
         uint32_t patch_command_count, struct vkd3d_execute_indirect_info *info);
 
diff --git a/libs/vkd3d/vkd3d_shaders.h b/libs/vkd3d/vkd3d_shaders.h
index 41637e824..801521f25 100644
--- a/libs/vkd3d/vkd3d_shaders.h
+++ b/libs/vkd3d/vkd3d_shaders.h
@@ -47,6 +47,7 @@ enum vkd3d_meta_copy_mode
 #include <cs_resolve_query.h>
 #include <cs_execute_indirect_patch.h>
 #include <cs_execute_indirect_patch_debug_ring.h>
+#include <cs_execute_indirect_multi_dispatch.h>
 #include <vs_fullscreen_layer.h>
 #include <vs_fullscreen.h>
 #include <gs_fullscreen.h>

From 4cb44ec2627d38b99730ca0c94060181579318b7 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Tue, 14 Mar 2023 15:15:39 +0100
Subject: [PATCH 04/16] tests: Remove TODO from multi_dispatch test.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 tests/d3d12_command.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tests/d3d12_command.c b/tests/d3d12_command.c
index 716a7bca6..2f874b996 100644
--- a/tests/d3d12_command.c
+++ b/tests/d3d12_command.c
@@ -1903,7 +1903,7 @@ void test_execute_indirect_multi_dispatch(void)
                     indirect_data[4 + 3 * i + 2];
         }
         value = get_readback_uint(&rb, test_index, 0, 0);
-        todo ok(value == expected, "Iteration %u: Expected %u, got %u.\n", test_index, expected, value);
+        ok(value == expected, "Iteration %u: Expected %u, got %u.\n", test_index, expected, value);
     }
 
     release_resource_readback(&rb);

From 253b567c1ef46d026012f0d05e1ebe84fd9dc2f0 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 15 Mar 2023 12:49:31 +0100
Subject: [PATCH 05/16] vkd3d: Refactor root signature to allow push UBO per
 PSO type.

Move some root signature global flags and parameters to per-pipeline
type state. We need to support a mode where compute PSOs use push UBOs
and other stages can use whatever they want.

We already had the scaffolding in place to do this, so just needed to
move some extra parameters down.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c             |  18 ++++--
 libs/vkd3d/raytracing_pipeline.c |   8 +--
 libs/vkd3d/state.c               | 106 +++++++++++++++++++++----------
 libs/vkd3d/vkd3d_private.h       |  10 +--
 4 files changed, 94 insertions(+), 48 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 86d6feeed..15f7b03ee 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -5713,7 +5713,7 @@ static void d3d12_command_list_fetch_root_parameter_uniform_block_data(struct d3
 
 static void d3d12_command_list_update_root_descriptors(struct d3d12_command_list *list,
         struct vkd3d_pipeline_bindings *bindings, VkPipelineBindPoint vk_bind_point,
-        VkPipelineLayout layout, VkShaderStageFlags push_stages)
+        VkPipelineLayout layout, VkShaderStageFlags push_stages, uint32_t root_signature_flags)
 {
     const struct d3d12_root_signature *root_signature = bindings->root_signature;
     const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
@@ -5728,7 +5728,7 @@ static void d3d12_command_list_update_root_descriptors(struct d3d12_command_list
     unsigned int va_count = 0;
     uint64_t dirty_push_mask;
 
-    if (root_signature->flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
+    if (root_signature_flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
     {
         d3d12_command_allocator_allocate_scratch_memory(list->allocator,
                 VKD3D_SCRATCH_POOL_KIND_UNIFORM_UPLOAD, sizeof(root_parameter_data),
@@ -5765,7 +5765,7 @@ static void d3d12_command_list_update_root_descriptors(struct d3d12_command_list
         bindings->root_descriptor_dirty_mask = 0;
     }
 
-    if (root_signature->flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
+    if (root_signature_flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
     {
         d3d12_command_list_fetch_root_parameter_uniform_block_data(list, bindings, ptr_root_parameter_data);
         vk_write_descriptor_set_from_scratch_push_ubo(&descriptor_writes[descriptor_write_count],
@@ -5879,17 +5879,23 @@ static void d3d12_command_list_update_descriptors(struct d3d12_command_list *lis
     if (bindings->dirty_flags & VKD3D_PIPELINE_DIRTY_HOISTED_DESCRIPTORS)
         d3d12_command_list_update_hoisted_descriptors(list, bindings);
 
-    if (rs->flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
+    if (bind_point_layout->flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
     {
         /* Root constants and descriptor table offsets are part of the root descriptor set */
         if (bindings->root_descriptor_dirty_mask || bindings->root_constant_dirty_mask
                 || (bindings->dirty_flags & VKD3D_PIPELINE_DIRTY_DESCRIPTOR_TABLE_OFFSETS))
-            d3d12_command_list_update_root_descriptors(list, bindings, vk_bind_point, layout, push_stages);
+        {
+            d3d12_command_list_update_root_descriptors(list, bindings, vk_bind_point, layout, push_stages,
+                    bind_point_layout->flags);
+        }
     }
     else
     {
         if (bindings->root_descriptor_dirty_mask)
-            d3d12_command_list_update_root_descriptors(list, bindings, vk_bind_point, layout, push_stages);
+        {
+            d3d12_command_list_update_root_descriptors(list, bindings, vk_bind_point, layout, push_stages,
+                    bind_point_layout->flags);
+        }
 
         if (bindings->root_constant_dirty_mask)
             d3d12_command_list_update_root_constants(list, bindings, layout, push_stages);
diff --git a/libs/vkd3d/raytracing_pipeline.c b/libs/vkd3d/raytracing_pipeline.c
index e6a158c54..8ec3bed8f 100644
--- a/libs/vkd3d/raytracing_pipeline.c
+++ b/libs/vkd3d/raytracing_pipeline.c
@@ -1717,7 +1717,7 @@ static HRESULT d3d12_state_object_compile_pipeline(struct d3d12_state_object *ob
 
     if (global_signature)
     {
-        shader_interface_info.flags = d3d12_root_signature_get_shader_interface_flags(global_signature);
+        shader_interface_info.flags = d3d12_root_signature_get_shader_interface_flags(global_signature, VKD3D_PIPELINE_TYPE_RAY_TRACING);
         shader_interface_info.descriptor_tables.offset = global_signature->descriptor_table_offset;
         shader_interface_info.descriptor_tables.count = global_signature->descriptor_table_count;
         shader_interface_info.bindings = global_signature->bindings;
@@ -1751,7 +1751,7 @@ static HRESULT d3d12_state_object_compile_pipeline(struct d3d12_state_object *ob
     local_static_sampler_bindings = NULL;
     local_static_sampler_bindings_count = 0;
     local_static_sampler_bindings_size = 0;
-    object->local_static_sampler.set_index = global_signature ? global_signature->num_set_layouts : 0;
+    object->local_static_sampler.set_index = global_signature ? global_signature->raygen.num_set_layouts : 0;
 
     if (object->device->debug_ring.active)
         data->spec_info_buffer = vkd3d_calloc(data->entry_points_count, sizeof(*data->spec_info_buffer));
@@ -1799,8 +1799,8 @@ static HRESULT d3d12_state_object_compile_pipeline(struct d3d12_state_object *ob
             }
 
             /* Promote state which might only be active in local root signature. */
-            shader_interface_info.flags |= d3d12_root_signature_get_shader_interface_flags(local_signature);
-            if (local_signature->flags & (VKD3D_ROOT_SIGNATURE_USE_SSBO_OFFSET_BUFFER | VKD3D_ROOT_SIGNATURE_USE_TYPED_OFFSET_BUFFER))
+            shader_interface_info.flags |= d3d12_root_signature_get_shader_interface_flags(local_signature, VKD3D_PIPELINE_TYPE_RAY_TRACING);
+            if (local_signature->raygen.flags & (VKD3D_ROOT_SIGNATURE_USE_SSBO_OFFSET_BUFFER | VKD3D_ROOT_SIGNATURE_USE_TYPED_OFFSET_BUFFER))
                 shader_interface_info.offset_buffer_binding = &local_signature->offset_buffer_binding;
         }
         else
diff --git a/libs/vkd3d/state.c b/libs/vkd3d/state.c
index 426a9caa7..13084b214 100644
--- a/libs/vkd3d/state.c
+++ b/libs/vkd3d/state.c
@@ -877,6 +877,15 @@ static HRESULT d3d12_root_signature_init_root_descriptor_tables(struct d3d12_roo
     return S_OK;
 }
 
+static void d3d12_root_signature_add_common_flags(struct d3d12_root_signature *root_signature,
+        uint32_t common_flags)
+{
+    root_signature->graphics.flags |= common_flags;
+    root_signature->mesh.flags |= common_flags;
+    root_signature->compute.flags |= common_flags;
+    root_signature->raygen.flags |= common_flags;
+}
+
 static void d3d12_root_signature_init_extra_bindings(struct d3d12_root_signature *root_signature,
         const struct d3d12_root_signature_info *info)
 {
@@ -887,9 +896,9 @@ static void d3d12_root_signature_init_extra_bindings(struct d3d12_root_signature
     if (info->has_ssbo_offset_buffer || info->has_typed_offset_buffer)
     {
         if (info->has_ssbo_offset_buffer)
-            root_signature->flags |= VKD3D_ROOT_SIGNATURE_USE_SSBO_OFFSET_BUFFER;
+            d3d12_root_signature_add_common_flags(root_signature, VKD3D_ROOT_SIGNATURE_USE_SSBO_OFFSET_BUFFER);
         if (info->has_typed_offset_buffer)
-            root_signature->flags |= VKD3D_ROOT_SIGNATURE_USE_TYPED_OFFSET_BUFFER;
+            d3d12_root_signature_add_common_flags(root_signature, VKD3D_ROOT_SIGNATURE_USE_TYPED_OFFSET_BUFFER);
 
         vkd3d_bindless_state_find_binding(&root_signature->device->bindless_state,
                 VKD3D_BINDLESS_SET_EXTRA_OFFSET_BUFFER,
@@ -964,8 +973,14 @@ static HRESULT d3d12_root_signature_init_root_descriptors(struct d3d12_root_sign
     const D3D12_DESCRIPTOR_RANGE1 *range;
     unsigned int i, j, k;
     HRESULT hr = S_OK;
+    uint32_t or_flags;
+
+    or_flags = root_signature->graphics.flags |
+            root_signature->compute.flags |
+            root_signature->raygen.flags |
+            root_signature->mesh.flags;
 
-    if (info->push_descriptor_count || (root_signature->flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK))
+    if (info->push_descriptor_count || (or_flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK))
     {
         if (!(vk_binding_info = vkd3d_malloc(sizeof(*vk_binding_info) * (info->push_descriptor_count + 1))))
             return E_OUTOFMEMORY;
@@ -1086,7 +1101,7 @@ static HRESULT d3d12_root_signature_init_root_descriptors(struct d3d12_root_sign
             context->vk_binding += 1;
     }
 
-    if (root_signature->flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
+    if (or_flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
     {
         vk_binding = &vk_binding_info[j++];
         vk_binding->binding = context->vk_binding;
@@ -1280,6 +1295,18 @@ static HRESULT d3d12_root_signature_init_local(struct d3d12_root_signature *root
     return hr;
 }
 
+static void d3d12_root_signature_update_bind_point_layout(struct d3d12_bind_point_layout *layout,
+        const VkPushConstantRange *push_range, const struct vkd3d_descriptor_set_context *context,
+        const struct d3d12_root_signature_info *info)
+{
+    /* Select push UBO style or push constants on a per-pipeline type basis. */
+    if ((layout->flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK) || info->push_descriptor_count)
+        layout->num_set_layouts = context->vk_set;
+
+    if (!(layout->flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK))
+        layout->push_constant_range = *push_range;
+}
+
 static HRESULT d3d12_root_signature_init_global(struct d3d12_root_signature *root_signature,
         struct d3d12_device *device, const D3D12_ROOT_SIGNATURE_DESC1 *desc)
 {
@@ -1287,6 +1314,7 @@ static HRESULT d3d12_root_signature_init_global(struct d3d12_root_signature *roo
     const struct vkd3d_bindless_state *bindless_state = &device->bindless_state;
     struct vkd3d_descriptor_set_context context;
     VkShaderStageFlagBits mesh_shader_stages;
+    VkPushConstantRange push_constant_range;
     struct d3d12_root_signature_info info;
     unsigned int i;
     HRESULT hr;
@@ -1353,17 +1381,23 @@ static HRESULT d3d12_root_signature_init_global(struct d3d12_root_signature *roo
     }
 
     if (FAILED(hr = d3d12_root_signature_init_push_constants(root_signature, desc, &info,
-            &root_signature->push_constant_range)))
+            &push_constant_range)))
         return hr;
 
-    /* If we cannot contain the push constants, fall back to push UBO. */
-    if (root_signature->push_constant_range.size > vk_device_properties->limits.maxPushConstantsSize)
-        root_signature->flags |= VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK;
+    /* If we cannot contain the push constants, fall back to push UBO everywhere. */
+    if (push_constant_range.size > vk_device_properties->limits.maxPushConstantsSize)
+        d3d12_root_signature_add_common_flags(root_signature, VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK);
 
     d3d12_root_signature_init_extra_bindings(root_signature, &info);
 
+    /* Individual pipeline types may opt-in or out-of using the push UBO descriptor set. */
+    root_signature->graphics.num_set_layouts = context.vk_set;
+    root_signature->mesh.num_set_layouts = context.vk_set;
+    root_signature->compute.num_set_layouts = context.vk_set;
+    root_signature->raygen.num_set_layouts = context.vk_set;
+
     if (FAILED(hr = d3d12_root_signature_init_root_descriptors(root_signature, desc,
-                &info, &root_signature->push_constant_range, &context,
+                &info, &push_constant_range, &context,
                 &root_signature->vk_root_descriptor_layout)))
         return hr;
 
@@ -1380,11 +1414,15 @@ static HRESULT d3d12_root_signature_init_global(struct d3d12_root_signature *roo
     if (FAILED(hr = d3d12_root_signature_init_root_descriptor_tables(root_signature, desc, &info, &context)))
         return hr;
 
-    if (root_signature->flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
-    {
-        root_signature->push_constant_range.stageFlags = 0;
-        root_signature->push_constant_range.size = 0;
-    }
+    /* Select push UBO style or push constants on a per-pipeline type basis. */
+    d3d12_root_signature_update_bind_point_layout(&root_signature->graphics,
+            &push_constant_range, &context, &info);
+    d3d12_root_signature_update_bind_point_layout(&root_signature->mesh,
+            &push_constant_range, &context, &info);
+    d3d12_root_signature_update_bind_point_layout(&root_signature->compute,
+            &push_constant_range, &context, &info);
+    d3d12_root_signature_update_bind_point_layout(&root_signature->raygen,
+            &push_constant_range, &context, &info);
 
     /* If we need to use restricted entry_points in vkCmdPushConstants,
      * we are unfortunately required to do it like this
@@ -1396,11 +1434,9 @@ static HRESULT d3d12_root_signature_init_global(struct d3d12_root_signature *roo
      * For graphics we can generally rely on visibility mask, but not so for compute and raygen,
      * since they use ALL visibility. */
 
-    root_signature->num_set_layouts = context.vk_set;
-
     if (FAILED(hr = vkd3d_create_pipeline_layout_for_stage_mask(
-            device, root_signature->num_set_layouts, root_signature->set_layouts,
-            &root_signature->push_constant_range,
+            device, root_signature->graphics.num_set_layouts, root_signature->set_layouts,
+            &root_signature->graphics.push_constant_range,
             VK_SHADER_STAGE_ALL_GRAPHICS, &root_signature->graphics)))
         return hr;
 
@@ -1411,23 +1447,23 @@ static HRESULT d3d12_root_signature_init_global(struct d3d12_root_signature *roo
                 VK_SHADER_STAGE_FRAGMENT_BIT;
 
         if (FAILED(hr = vkd3d_create_pipeline_layout_for_stage_mask(
-                device, root_signature->num_set_layouts, root_signature->set_layouts,
-                &root_signature->push_constant_range,
+                device, root_signature->mesh.num_set_layouts, root_signature->set_layouts,
+                &root_signature->mesh.push_constant_range,
                 mesh_shader_stages, &root_signature->mesh)))
             return hr;
     }
 
     if (FAILED(hr = vkd3d_create_pipeline_layout_for_stage_mask(
-            device, root_signature->num_set_layouts, root_signature->set_layouts,
-            &root_signature->push_constant_range,
+            device, root_signature->compute.num_set_layouts, root_signature->set_layouts,
+            &root_signature->compute.push_constant_range,
             VK_SHADER_STAGE_COMPUTE_BIT, &root_signature->compute)))
         return hr;
 
     if (d3d12_device_supports_ray_tracing_tier_1_0(device))
     {
         if (FAILED(hr = vkd3d_create_pipeline_layout_for_stage_mask(
-                device, root_signature->num_set_layouts, root_signature->set_layouts,
-                &root_signature->push_constant_range,
+                device, root_signature->raygen.num_set_layouts, root_signature->set_layouts,
+                &root_signature->raygen.push_constant_range,
                 VK_SHADER_STAGE_RAYGEN_BIT_KHR |
                 VK_SHADER_STAGE_MISS_BIT_KHR |
                 VK_SHADER_STAGE_INTERSECTION_BIT_KHR |
@@ -1454,12 +1490,12 @@ HRESULT d3d12_root_signature_create_local_static_samplers_layout(struct d3d12_ro
     if (!d3d12_device_supports_ray_tracing_tier_1_0(root_signature->device))
         return E_INVALIDARG;
 
-    memcpy(set_layouts, root_signature->set_layouts, root_signature->num_set_layouts * sizeof(VkDescriptorSetLayout));
-    set_layouts[root_signature->num_set_layouts] = vk_set_layout;
+    memcpy(set_layouts, root_signature->set_layouts, root_signature->raygen.num_set_layouts * sizeof(VkDescriptorSetLayout));
+    set_layouts[root_signature->raygen.num_set_layouts] = vk_set_layout;
 
     if (FAILED(hr = vkd3d_create_pipeline_layout_for_stage_mask(
-            root_signature->device, root_signature->num_set_layouts + 1, set_layouts,
-            &root_signature->push_constant_range,
+            root_signature->device, root_signature->raygen.num_set_layouts + 1, set_layouts,
+            &root_signature->raygen.push_constant_range,
             VK_SHADER_STAGE_RAYGEN_BIT_KHR |
             VK_SHADER_STAGE_MISS_BIT_KHR |
             VK_SHADER_STAGE_INTERSECTION_BIT_KHR |
@@ -1606,16 +1642,20 @@ HRESULT d3d12_root_signature_create_raw(struct d3d12_device *device,
     return d3d12_root_signature_create_from_blob(device, payload, payload_length, true, root_signature);
 }
 
-unsigned int d3d12_root_signature_get_shader_interface_flags(const struct d3d12_root_signature *root_signature)
+unsigned int d3d12_root_signature_get_shader_interface_flags(const struct d3d12_root_signature *root_signature,
+        enum vkd3d_pipeline_type pipeline_type)
 {
+    const struct d3d12_bind_point_layout *layout;
     unsigned int flags = 0;
 
-    if (root_signature->flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
+    layout = d3d12_root_signature_get_layout(root_signature, pipeline_type);
+
+    if (layout->flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
         flags |= VKD3D_SHADER_INTERFACE_PUSH_CONSTANTS_AS_UNIFORM_BUFFER;
 
-    if (root_signature->flags & VKD3D_ROOT_SIGNATURE_USE_SSBO_OFFSET_BUFFER)
+    if (layout->flags & VKD3D_ROOT_SIGNATURE_USE_SSBO_OFFSET_BUFFER)
         flags |= VKD3D_SHADER_INTERFACE_SSBO_OFFSET_BUFFER;
-    if (root_signature->flags & VKD3D_ROOT_SIGNATURE_USE_TYPED_OFFSET_BUFFER)
+    if (layout->flags & VKD3D_ROOT_SIGNATURE_USE_TYPED_OFFSET_BUFFER)
         flags |= VKD3D_SHADER_INTERFACE_TYPED_OFFSET_BUFFER;
 
     if (root_signature->device->bindless_state.flags & VKD3D_BINDLESS_CBV_AS_SSBO)
@@ -2281,7 +2321,7 @@ static void d3d12_pipeline_state_init_shader_interface(struct d3d12_pipeline_sta
 {
     const struct d3d12_root_signature *root_signature = state->root_signature;
     memset(shader_interface, 0, sizeof(*shader_interface));
-    shader_interface->flags = d3d12_root_signature_get_shader_interface_flags(root_signature);
+    shader_interface->flags = d3d12_root_signature_get_shader_interface_flags(root_signature, state->pipeline_type);
     shader_interface->min_ssbo_alignment = d3d12_device_get_ssbo_alignment(device);
     shader_interface->descriptor_tables.offset = root_signature->descriptor_table_offset;
     shader_interface->descriptor_tables.count = root_signature->descriptor_table_count;
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index ff260a949..1a6002e0b 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -1598,6 +1598,9 @@ struct d3d12_bind_point_layout
 {
     VkPipelineLayout vk_pipeline_layout;
     VkShaderStageFlags vk_push_stages;
+    unsigned int flags; /* vkd3d_root_signature_flag */
+    uint32_t num_set_layouts;
+    VkPushConstantRange push_constant_range;
 };
 
 #define VKD3D_MAX_HOISTED_DESCRIPTORS 16
@@ -1641,7 +1644,6 @@ struct d3d12_root_signature
     uint64_t root_descriptor_push_mask;
 
     D3D12_ROOT_SIGNATURE_FLAGS d3d12_flags;
-    unsigned int flags; /* vkd3d_root_signature_flag */
 
     unsigned int binding_count;
     struct vkd3d_shader_resource_binding *bindings;
@@ -1649,8 +1651,6 @@ struct d3d12_root_signature
     unsigned int root_constant_count;
     struct vkd3d_shader_push_constant_buffer *root_constants;
 
-    /* Use one global push constant range */
-    VkPushConstantRange push_constant_range;
     struct vkd3d_shader_descriptor_binding push_constant_ubo_binding;
     struct vkd3d_shader_descriptor_binding raw_va_aux_buffer_binding;
     struct vkd3d_shader_descriptor_binding offset_buffer_binding;
@@ -1660,7 +1660,6 @@ struct d3d12_root_signature
 #endif
 
     VkDescriptorSetLayout set_layouts[VKD3D_MAX_DESCRIPTOR_SETS];
-    uint32_t num_set_layouts;
 
     uint32_t descriptor_table_offset;
     uint32_t descriptor_table_count;
@@ -1695,7 +1694,8 @@ static inline struct d3d12_root_signature *impl_from_ID3D12RootSignature(ID3D12R
     return CONTAINING_RECORD(iface, struct d3d12_root_signature, ID3D12RootSignature_iface);
 }
 
-unsigned int d3d12_root_signature_get_shader_interface_flags(const struct d3d12_root_signature *root_signature);
+unsigned int d3d12_root_signature_get_shader_interface_flags(const struct d3d12_root_signature *root_signature,
+        enum vkd3d_pipeline_type pipeline_type);
 HRESULT d3d12_root_signature_create_local_static_samplers_layout(struct d3d12_root_signature *root_signature,
         VkDescriptorSetLayout vk_set_layout, VkPipelineLayout *vk_pipeline_layout);
 HRESULT vkd3d_create_pipeline_layout(struct d3d12_device *device,

From 1d4bc156853bc80e7dd5f8519f95f3079a1faf6e Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 15 Mar 2023 13:01:17 +0100
Subject: [PATCH 06/16] vkd3d: Add config flag to force push UBO for root
 parameters.

Will enable a workaround path for ExecuteIndirect multi-dispatch.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 include/vkd3d.h            | 1 +
 libs/vkd3d/device.c        | 1 +
 libs/vkd3d/state.c         | 8 ++++++++
 libs/vkd3d/vkd3d_private.h | 1 +
 4 files changed, 11 insertions(+)

diff --git a/include/vkd3d.h b/include/vkd3d.h
index dba403738..de482aa9e 100644
--- a/include/vkd3d.h
+++ b/include/vkd3d.h
@@ -76,6 +76,7 @@ extern "C" {
 #define VKD3D_CONFIG_FLAG_FORCE_DEDICATED_IMAGE_ALLOCATION (1ull << 35)
 #define VKD3D_CONFIG_FLAG_BREADCRUMBS_TRACE (1ull << 36)
 #define VKD3D_CONFIG_FLAG_SIMULTANEOUS_UAV_SUPPRESS_COMPRESSION (1ull << 37)
+#define VKD3D_CONFIG_FLAG_FORCE_COMPUTE_ROOT_PARAMETERS_PUSH_UBO (1ull << 38)
 
 struct vkd3d_instance;
 
diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index 6bc68fda7..ea89fe060 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -755,6 +755,7 @@ static const struct vkd3d_debug_option vkd3d_config_options[] =
     {"preallocate_srv_mip_clamps", VKD3D_CONFIG_FLAG_PREALLOCATE_SRV_MIP_CLAMPS},
     {"force_initial_transition", VKD3D_CONFIG_FLAG_FORCE_INITIAL_TRANSITION},
     {"breadcrumbs_trace", VKD3D_CONFIG_FLAG_BREADCRUMBS | VKD3D_CONFIG_FLAG_BREADCRUMBS_TRACE},
+    {"force_compute_root_parameters_push_ubo", VKD3D_CONFIG_FLAG_FORCE_COMPUTE_ROOT_PARAMETERS_PUSH_UBO},
 };
 
 static void vkd3d_config_flags_init_once(void)
diff --git a/libs/vkd3d/state.c b/libs/vkd3d/state.c
index 13084b214..31b20e474 100644
--- a/libs/vkd3d/state.c
+++ b/libs/vkd3d/state.c
@@ -1387,6 +1387,8 @@ static HRESULT d3d12_root_signature_init_global(struct d3d12_root_signature *roo
     /* If we cannot contain the push constants, fall back to push UBO everywhere. */
     if (push_constant_range.size > vk_device_properties->limits.maxPushConstantsSize)
         d3d12_root_signature_add_common_flags(root_signature, VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK);
+    else if (push_constant_range.size && (device->bindless_state.flags & VKD3D_FORCE_COMPUTE_ROOT_PARAMETERS_PUSH_UBO))
+        root_signature->compute.flags |= VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK;
 
     d3d12_root_signature_init_extra_bindings(root_signature, &info);
 
@@ -5912,6 +5914,12 @@ static uint32_t vkd3d_bindless_state_get_bindless_flags(struct d3d12_device *dev
         flags |= VKD3D_HOIST_STATIC_TABLE_CBV;
     }
 
+    if (vkd3d_config_flags & VKD3D_CONFIG_FLAG_FORCE_COMPUTE_ROOT_PARAMETERS_PUSH_UBO)
+    {
+        INFO("Forcing push UBO path for compute root parameters.\n");
+        flags |= VKD3D_FORCE_COMPUTE_ROOT_PARAMETERS_PUSH_UBO;
+    }
+
     if (vkd3d_bindless_supports_mutable_type(device, flags))
     {
         INFO("Device supports VK_%s_mutable_descriptor_type.\n",
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 1a6002e0b..e5375b09f 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -3369,6 +3369,7 @@ enum vkd3d_bindless_flags
     VKD3D_BINDLESS_MUTABLE_TYPE_RAW_SSBO            = (1u << 8),
     VKD3D_BINDLESS_MUTABLE_EMBEDDED                 = (1u << 9),
     VKD3D_BINDLESS_MUTABLE_EMBEDDED_PACKED_METADATA = (1u << 10),
+    VKD3D_FORCE_COMPUTE_ROOT_PARAMETERS_PUSH_UBO    = (1u << 11),
 };
 
 #define VKD3D_BINDLESS_SET_MAX_EXTRA_BINDINGS 8

From 6d6db939e2a7122b01f957d1b5c5bf3404694c7e Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 15 Mar 2023 13:17:04 +0100
Subject: [PATCH 07/16] vkd3d: Remove redundant feature check for DGC.

It's checked before calling this function either way.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 15f7b03ee..dfa78c2d2 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -14842,12 +14842,6 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
     static const VkIndexType vk_index_types[] = { VK_INDEX_TYPE_UINT32, VK_INDEX_TYPE_UINT16 };
     static const uint32_t d3d_index_types[] = { DXGI_FORMAT_R32_UINT, DXGI_FORMAT_R16_UINT };
 
-    if (!device->device_info.device_generated_commands_features_nv.deviceGeneratedCommands)
-    {
-        WARN("Device generated commands not supported, indirect state commands will be ignored.\n");
-        return S_OK;
-    }
-
     for (i = 0; i < desc->NumArgumentDescs; i++)
     {
         const D3D12_INDIRECT_ARGUMENT_DESC *argument_desc = &desc->pArgumentDescs[i];

From c827948b19f87fd3f7d76ae2e5aad2c80c8f680e Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 15 Mar 2023 13:22:04 +0100
Subject: [PATCH 08/16] vkd3d: Validate that push UBO path is not used for DGC.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index dfa78c2d2..24cafc3f7 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -14855,6 +14855,14 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
             case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT:
                 root_parameter_index = argument_desc->Constant.RootParameterIndex;
                 root_constant = root_signature_get_32bit_constants(root_signature, root_parameter_index);
+
+                if (root_signature->graphics.flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
+                {
+                    ERR("Root signature uses push UBO for root parameters, but this feature requires push constant path.\n");
+                    hr = E_NOTIMPL;
+                    goto end;
+                }
+
                 token.tokenType = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV;
                 token.pushconstantPipelineLayout = root_signature->graphics.vk_pipeline_layout;
                 token.pushconstantShaderStageFlags = root_signature->graphics.vk_push_stages;
@@ -14878,6 +14886,14 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
             case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW:
                 root_parameter_index = argument_desc->ShaderResourceView.RootParameterIndex;
                 root_parameter = root_signature_get_parameter(root_signature, root_parameter_index);
+
+                if (root_signature->graphics.flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
+                {
+                    ERR("Root signature uses push UBO for root parameters, but this feature requires push constant path.\n");
+                    hr = E_NOTIMPL;
+                    goto end;
+                }
+
                 if (!(root_signature->root_descriptor_raw_va_mask & (1ull << root_parameter_index)))
                 {
                     ERR("Root parameter %u is not a raw VA. Cannot implement command signature which updates root descriptor.\n",

From 4683a82607a13e82f815c918aa0969fa603ab12d Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 15 Mar 2023 13:27:03 +0100
Subject: [PATCH 09/16] vkd3d: Stub out implementation of compute state
 template.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 39 +++++++++++++++++++++++++++++++++++----
 1 file changed, 35 insertions(+), 4 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 24cafc3f7..a1bc1576e 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -14774,7 +14774,15 @@ static HRESULT d3d12_command_signature_allocate_preprocess_memory_for_list(
     return S_OK;
 }
 
-static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_signature *signature,
+static HRESULT d3d12_command_signature_init_state_template_compute(struct d3d12_command_signature *signature,
+        const D3D12_COMMAND_SIGNATURE_DESC *desc,
+        struct d3d12_root_signature *root_signature,
+        struct d3d12_device *device)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT d3d12_command_signature_init_state_template_graphics(struct d3d12_command_signature *signature,
         const D3D12_COMMAND_SIGNATURE_DESC *desc,
         struct d3d12_root_signature *root_signature,
         struct d3d12_device *device)
@@ -15190,15 +15198,38 @@ HRESULT d3d12_command_signature_create(struct d3d12_device *device, struct d3d12
 
     if ((object->requires_state_template = requires_state_template))
     {
-        if (!device->device_info.device_generated_commands_features_nv.deviceGeneratedCommands)
+        if ((pipeline_type == VKD3D_PIPELINE_TYPE_GRAPHICS || pipeline_type == VKD3D_PIPELINE_TYPE_MESH_GRAPHICS) &&
+                !device->device_info.device_generated_commands_features_nv.deviceGeneratedCommands)
         {
             FIXME("VK_NV_device_generated_commands is not supported by implementation.\n");
             hr = E_NOTIMPL;
             goto err;
         }
-
-        if (FAILED(hr = d3d12_command_signature_init_state_template(object, desc, root_signature, device)))
+        else if (pipeline_type == VKD3D_PIPELINE_TYPE_COMPUTE &&
+                !(device->bindless_state.flags & VKD3D_FORCE_COMPUTE_ROOT_PARAMETERS_PUSH_UBO))
+        {
+            FIXME("State template is required for compute, but VKD3D_CONFIG_FLAG_FORCE_COMPUTE_ROOT_PARAMETERS_PUSH_UBO is not enabled.\n");
+            hr = E_NOTIMPL;
             goto err;
+        }
+        else if (pipeline_type == VKD3D_PIPELINE_TYPE_RAY_TRACING)
+        {
+            /* Very similar idea as indirect compute would be. */
+            FIXME("State template is required for indirect ray tracing, but it is unimplemented.\n");
+            hr = E_NOTIMPL;
+            goto err;
+        }
+
+        if (pipeline_type == VKD3D_PIPELINE_TYPE_GRAPHICS || pipeline_type == VKD3D_PIPELINE_TYPE_MESH_GRAPHICS)
+        {
+            if (FAILED(hr = d3d12_command_signature_init_state_template_graphics(object, desc, root_signature, device)))
+                goto err;
+        }
+        else if (pipeline_type == VKD3D_PIPELINE_TYPE_COMPUTE)
+        {
+            if (FAILED(hr = d3d12_command_signature_init_state_template_compute(object, desc, root_signature, device)))
+                goto err;
+        }
     }
     else
         object->argument_buffer_offset = argument_buffer_offset;

From 832721265ad5e3ccbd1e580ae8461dc2a8e93bae Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 15 Mar 2023 14:06:17 +0100
Subject: [PATCH 10/16] vkd3d: Create command signature for indirect compute.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c       | 113 +++++++++++++++++++++++++++++--------
 libs/vkd3d/vkd3d_private.h |  22 +++++---
 2 files changed, 105 insertions(+), 30 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index a1bc1576e..ca96ad8f7 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -11198,7 +11198,7 @@ static void d3d12_command_list_execute_indirect_state_template(
      * - We require debugging. */
     props = &list->device->device_info.device_generated_commands_properties_nv;
 
-    if ((signature->state_template.stride != signature->desc.ByteStride && max_command_count > 1) ||
+    if ((signature->state_template.graphics.stride != signature->desc.ByteStride && max_command_count > 1) ||
             (arg_buffer_offset & (props->minIndirectCommandsBufferOffsetAlignment - 1)) ||
             (count_buffer && (count_buffer_offset & (props->minSequencesCountBufferOffsetAlignment - 1))) ||
             patch_args.debug_tag)
@@ -11228,13 +11228,13 @@ static void d3d12_command_list_execute_indirect_state_template(
             }
         }
 
-        patch_args.template_va = signature->state_template.buffer_va;
+        patch_args.template_va = signature->state_template.graphics.buffer_va;
         patch_args.api_buffer_va = arg_buffer->res.va + arg_buffer_offset;
         patch_args.device_generated_commands_va = stream_allocation.va;
         patch_args.indirect_count_va = count_buffer ? count_buffer->res.va + count_buffer_offset : 0;
         patch_args.dst_indirect_count_va = count_buffer ? count_allocation.va : 0;
         patch_args.api_buffer_word_stride = signature->desc.ByteStride / sizeof(uint32_t);
-        patch_args.device_generated_commands_word_stride = signature->state_template.stride / sizeof(uint32_t);
+        patch_args.device_generated_commands_word_stride = signature->state_template.graphics.stride / sizeof(uint32_t);
 
         if (patch_args.debug_tag != 0)
         {
@@ -11270,10 +11270,10 @@ static void d3d12_command_list_execute_indirect_state_template(
             d3d12_command_list_invalidate_current_pipeline(list, true);
         }
 
-        VK_CALL(vkCmdPushConstants(vk_patch_cmd_buffer, signature->state_template.pipeline.vk_pipeline_layout,
+        VK_CALL(vkCmdPushConstants(vk_patch_cmd_buffer, signature->state_template.graphics.pipeline.vk_pipeline_layout,
                 VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(patch_args), &patch_args));
         VK_CALL(vkCmdBindPipeline(vk_patch_cmd_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
-                signature->state_template.pipeline.vk_pipeline));
+                signature->state_template.graphics.pipeline.vk_pipeline));
 
         /* One workgroup processes the patching for one draw. We could potentially use indirect dispatch
          * to restrict the patching work to just the indirect count, but meh, just more barriers.
@@ -11309,7 +11309,7 @@ static void d3d12_command_list_execute_indirect_state_template(
     generated.pNext = NULL;
     generated.pipeline = list->current_pipeline;
     generated.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
-    generated.indirectCommandsLayout = signature->state_template.layout;
+    generated.indirectCommandsLayout = signature->state_template.graphics.layout;
     generated.streamCount = 1;
     generated.pStreams = &stream;
     generated.preprocessBuffer = preprocess_allocation.buffer;
@@ -14545,11 +14545,13 @@ static void d3d12_command_signature_cleanup(struct d3d12_command_signature *sign
 {
     const struct vkd3d_vk_device_procs *vk_procs = &signature->device->vk_procs;
 
-    if (signature->device->device_info.device_generated_commands_features_nv.deviceGeneratedCommands)
+    if ((signature->pipeline_type == VKD3D_PIPELINE_TYPE_GRAPHICS ||
+            signature->pipeline_type == VKD3D_PIPELINE_TYPE_MESH_GRAPHICS) &&
+            signature->device->device_info.device_generated_commands_features_nv.deviceGeneratedCommands)
     {
-        VK_CALL(vkDestroyBuffer(signature->device->vk_device, signature->state_template.buffer, NULL));
-        vkd3d_free_device_memory(signature->device, &signature->state_template.memory);
-        VK_CALL(vkDestroyIndirectCommandsLayoutNV(signature->device->vk_device, signature->state_template.layout, NULL));
+        VK_CALL(vkDestroyBuffer(signature->device->vk_device, signature->state_template.graphics.buffer, NULL));
+        vkd3d_free_device_memory(signature->device, &signature->state_template.graphics.memory);
+        VK_CALL(vkDestroyIndirectCommandsLayoutNV(signature->device->vk_device, signature->state_template.graphics.layout, NULL));
     }
 
     vkd3d_private_store_destroy(&signature->private_store);
@@ -14660,23 +14662,23 @@ static HRESULT d3d12_command_signature_init_patch_commands_buffer(struct d3d12_c
     buffer_desc.Flags = D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
 
     if (FAILED(hr = vkd3d_create_buffer(device, &heap_info, D3D12_HEAP_FLAG_NONE,
-            &buffer_desc, &signature->state_template.buffer)))
+            &buffer_desc, &signature->state_template.graphics.buffer)))
         return hr;
 
-    if (FAILED(hr = vkd3d_allocate_internal_buffer_memory(device, signature->state_template.buffer,
+    if (FAILED(hr = vkd3d_allocate_internal_buffer_memory(device, signature->state_template.graphics.buffer,
             VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
-            &signature->state_template.memory)))
+            &signature->state_template.graphics.memory)))
         return hr;
 
-    signature->state_template.buffer_va = vkd3d_get_buffer_device_address(device,
-            signature->state_template.buffer);
+    signature->state_template.graphics.buffer_va = vkd3d_get_buffer_device_address(device,
+            signature->state_template.graphics.buffer);
 
-    if ((vr = VK_CALL(vkMapMemory(device->vk_device, signature->state_template.memory.vk_memory,
+    if ((vr = VK_CALL(vkMapMemory(device->vk_device, signature->state_template.graphics.memory.vk_memory,
             0, VK_WHOLE_SIZE, 0, (void**)&ptr))))
         return hr;
 
     memcpy(ptr, commands, command_count * sizeof(struct vkd3d_patch_command));
-    VK_CALL(vkUnmapMemory(device->vk_device, signature->state_template.memory.vk_memory));
+    VK_CALL(vkUnmapMemory(device->vk_device, signature->state_template.graphics.memory.vk_memory));
 
     return hr;
 }
@@ -14699,7 +14701,7 @@ static HRESULT d3d12_command_signature_init_indirect_commands_layout(
     create_info.tokenCount = token_count;
     create_info.pTokens = tokens;
 
-    signature->state_template.stride = stream_stride;
+    signature->state_template.graphics.stride = stream_stride;
 
     if (token_count > device->device_info.device_generated_commands_properties_nv.maxIndirectCommandsTokenCount)
     {
@@ -14708,7 +14710,8 @@ static HRESULT d3d12_command_signature_init_indirect_commands_layout(
         return E_NOTIMPL;
     }
 
-    vr = VK_CALL(vkCreateIndirectCommandsLayoutNV(device->vk_device, &create_info, NULL, &signature->state_template.layout));
+    vr = VK_CALL(vkCreateIndirectCommandsLayoutNV(device->vk_device, &create_info, NULL,
+            &signature->state_template.graphics.layout));
     return hresult_from_vk_result(vr);
 }
 
@@ -14720,7 +14723,7 @@ static HRESULT d3d12_command_signature_allocate_stream_memory_for_list(
 {
     if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
             VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
-            max_command_count * signature->state_template.stride,
+            max_command_count * signature->state_template.graphics.stride,
             list->device->device_info.device_generated_commands_properties_nv.minIndirectCommandsBufferOffsetAlignment,
             ~0u, allocation))
         return E_OUTOFMEMORY;
@@ -14747,7 +14750,7 @@ static HRESULT d3d12_command_signature_allocate_preprocess_memory_for_list(
     info.pNext = NULL;
     info.maxSequencesCount = max_command_count;
     info.pipeline = render_pipeline;
-    info.indirectCommandsLayout = signature->state_template.layout;
+    info.indirectCommandsLayout = signature->state_template.graphics.layout;
 
     if (max_command_count > list->device->device_info.device_generated_commands_properties_nv.maxIndirectSequenceCount)
     {
@@ -14779,7 +14782,70 @@ static HRESULT d3d12_command_signature_init_state_template_compute(struct d3d12_
         struct d3d12_root_signature *root_signature,
         struct d3d12_device *device)
 {
-    return E_NOTIMPL;
+    /* Compute templates are simpler, since the only state that can change is
+     * root constants and root descriptors, so we can work around it with some heroics.
+     * The implementation strategy for a non-DGC path is to upload a 256 byte buffer
+     * with default command list root parameter state.
+     * The input is either copied from the buffer directly, or it's read from the indirect buffer and replaces
+     * the default input. This can be done in parallel with 64 threads per dispatch.
+     * Some threads per workgroup will then copy the indirect dispatch parameters
+     * (or clear them to 0 if indirect count needs to mask the dispatch). */
+    const struct vkd3d_shader_root_parameter *root_parameter;
+    const struct vkd3d_shader_root_constant *root_constant;
+    uint32_t root_parameter_index;
+    uint32_t src_offset_words = 0;
+    uint32_t dst_offset_word;
+    unsigned int i, j;
+
+    for (i = 0; i < ARRAY_SIZE(signature->state_template.compute.source_offsets); i++)
+        signature->state_template.compute.source_offsets[i] = -1;
+
+    for (i = 0; i < desc->NumArgumentDescs; i++)
+    {
+        const D3D12_INDIRECT_ARGUMENT_DESC *argument_desc = &desc->pArgumentDescs[i];
+
+        switch (argument_desc->Type)
+        {
+            case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT:
+                root_parameter_index = argument_desc->Constant.RootParameterIndex;
+                root_constant = root_signature_get_32bit_constants(root_signature, root_parameter_index);
+
+                dst_offset_word = root_constant->constant_index + argument_desc->Constant.DestOffsetIn32BitValues;
+                for (j = 0; j < argument_desc->Constant.Num32BitValuesToSet; j++, src_offset_words++)
+                    signature->state_template.compute.source_offsets[dst_offset_word + j] = (int32_t)src_offset_words;
+                break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW:
+            case D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW:
+            case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW:
+                root_parameter_index = argument_desc->ShaderResourceView.RootParameterIndex;
+                root_parameter = root_signature_get_parameter(root_signature, root_parameter_index);
+
+                if (!(root_signature->root_descriptor_raw_va_mask & (1ull << root_parameter_index)))
+                {
+                    ERR("Root parameter %u is not a raw VA. Cannot implement command signature which updates root descriptor.\n",
+                            root_parameter_index);
+                    return E_NOTIMPL;
+                }
+
+                dst_offset_word = root_parameter->descriptor.raw_va_root_descriptor_index * sizeof(VkDeviceAddress) / sizeof(uint32_t);
+                for (j = 0; j < sizeof(VkDeviceAddress) / sizeof(uint32_t); j++, src_offset_words++)
+                    signature->state_template.compute.source_offsets[dst_offset_word + j] = (int32_t)src_offset_words;
+                break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH:
+                signature->state_template.compute.dispatch_offset_words = src_offset_words;
+                break;
+
+            default:
+                FIXME("Unsupported token type %u.\n", argument_desc->Type);
+                return E_NOTIMPL;
+        }
+    }
+
+    /* No need to build a specialized pipeline here, there is a generic pipeline to handle compute. */
+
+    return S_OK;
 }
 
 static HRESULT d3d12_command_signature_init_state_template_graphics(struct d3d12_command_signature *signature,
@@ -15036,7 +15102,8 @@ static HRESULT d3d12_command_signature_init_state_template_graphics(struct d3d12
         goto end;
     if (FAILED(hr = d3d12_command_signature_init_indirect_commands_layout(signature, device, tokens, token_count, stream_stride)))
         goto end;
-    if (FAILED(hr = vkd3d_meta_get_execute_indirect_pipeline(&device->meta_ops, patch_commands_count, &signature->state_template.pipeline)))
+    if (FAILED(hr = vkd3d_meta_get_execute_indirect_pipeline(&device->meta_ops, patch_commands_count,
+            &signature->state_template.graphics.pipeline)))
         goto end;
 
 end:
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index e5375b09f..f3e0625f5 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -2977,14 +2977,22 @@ struct d3d12_command_signature
     uint32_t argument_buffer_offset;
 
     /* Complex command signatures require some work to stamp out device generated commands. */
-    struct
+    union
     {
-        VkBuffer buffer;
-        VkDeviceAddress buffer_va;
-        struct vkd3d_device_memory_allocation memory;
-        VkIndirectCommandsLayoutNV layout;
-        uint32_t stride;
-        struct vkd3d_execute_indirect_info pipeline;
+        struct
+        {
+            VkBuffer buffer;
+            VkDeviceAddress buffer_va;
+            struct vkd3d_device_memory_allocation memory;
+            VkIndirectCommandsLayoutNV layout;
+            uint32_t stride;
+            struct vkd3d_execute_indirect_info pipeline;
+        } graphics;
+        struct
+        {
+            int32_t source_offsets[D3D12_MAX_ROOT_COST];
+            uint32_t dispatch_offset_words;
+        } compute;
     } state_template;
     bool requires_state_template;
     enum vkd3d_pipeline_type pipeline_type;

From dd0f6191bcd0a3c25c9a1a2cbc4850dbd9dfd643 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 15 Mar 2023 14:33:49 +0100
Subject: [PATCH 11/16] vkd3d: Implement execute indirect for multi-dispatch.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/breadcrumbs.c                      |   6 +
 libs/vkd3d/command.c                          | 216 +++++++++++++++++-
 libs/vkd3d/meson.build                        |   1 +
 libs/vkd3d/meta.c                             |  29 ++-
 .../cs_execute_indirect_multi_dispatch.comp   |  56 +++++
 ...execute_indirect_multi_dispatch_state.comp |  85 +++++++
 libs/vkd3d/vkd3d_private.h                    |  18 ++
 libs/vkd3d/vkd3d_shaders.h                    |   1 +
 8 files changed, 402 insertions(+), 10 deletions(-)
 create mode 100644 libs/vkd3d/shaders/cs_execute_indirect_multi_dispatch.comp
 create mode 100644 libs/vkd3d/shaders/cs_execute_indirect_multi_dispatch_state.comp

diff --git a/libs/vkd3d/breadcrumbs.c b/libs/vkd3d/breadcrumbs.c
index c33cbb278..de5066bc3 100644
--- a/libs/vkd3d/breadcrumbs.c
+++ b/libs/vkd3d/breadcrumbs.c
@@ -52,6 +52,12 @@ static const char *vkd3d_breadcrumb_command_type_to_str(enum vkd3d_breadcrumb_co
             return "execute_indirect";
         case VKD3D_BREADCRUMB_COMMAND_EXECUTE_INDIRECT_TEMPLATE:
             return "execute_indirect_template";
+        case VKD3D_BREADCRUMB_COMMAND_EXECUTE_INDIRECT_PATCH_COMPUTE:
+            return "execute_indirect_patch_compute";
+        case VKD3D_BREADCRUMB_COMMAND_EXECUTE_INDIRECT_PATCH_STATE_COMPUTE:
+            return "execute_indirect_patch_state_compute";
+        case VKD3D_BREADCRUMB_COMMAND_EXECUTE_INDIRECT_UNROLL_COMPUTE:
+            return "execute_indirect_unroll_compute";
         case VKD3D_BREADCRUMB_COMMAND_COPY:
             return "copy";
         case VKD3D_BREADCRUMB_COMMAND_COPY_TILES:
diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index ca96ad8f7..dcada8491 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -5705,10 +5705,13 @@ static void d3d12_command_list_fetch_root_parameter_uniform_block_data(struct d3
         dst_data->root_constants[first_table_offset + table->table_index] =
                 bindings->descriptor_tables[root_parameter_index];
     }
+}
 
-    /* Reset dirty flags to avoid redundant updates in the future */
-    bindings->dirty_flags &= ~VKD3D_PIPELINE_DIRTY_DESCRIPTOR_TABLE_OFFSETS;
-    bindings->root_constant_dirty_mask = 0;
+static void d3d12_command_list_fetch_root_parameter_data(struct d3d12_command_list *list,
+        struct vkd3d_pipeline_bindings *bindings, union root_parameter_data *dst_data)
+{
+    d3d12_command_list_fetch_root_descriptor_vas(list, bindings, dst_data);
+    d3d12_command_list_fetch_root_parameter_uniform_block_data(list, bindings, dst_data);
 }
 
 static void d3d12_command_list_update_root_descriptors(struct d3d12_command_list *list,
@@ -5768,6 +5771,12 @@ static void d3d12_command_list_update_root_descriptors(struct d3d12_command_list
     if (root_signature_flags & VKD3D_ROOT_SIGNATURE_USE_PUSH_CONSTANT_UNIFORM_BLOCK)
     {
         d3d12_command_list_fetch_root_parameter_uniform_block_data(list, bindings, ptr_root_parameter_data);
+
+        /* Reset dirty flags to avoid redundant updates in the future.
+         * We consume all constants / tables here regardless of dirty state. */
+        bindings->dirty_flags &= ~VKD3D_PIPELINE_DIRTY_DESCRIPTOR_TABLE_OFFSETS;
+        bindings->root_constant_dirty_mask = 0;
+
         vk_write_descriptor_set_from_scratch_push_ubo(&descriptor_writes[descriptor_write_count],
                 &buffer_info, &alloc, D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT,
                 root_signature->push_constant_ubo_binding.binding);
@@ -6237,6 +6246,88 @@ static bool d3d12_command_list_emit_multi_dispatch_indirect_count(struct d3d12_c
             VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
             0, 1, &vk_barrier, 0, NULL, 0, NULL));
 
+    VKD3D_BREADCRUMB_COMMAND(EXECUTE_INDIRECT_PATCH_COMPUTE);
+    return true;
+}
+
+static bool d3d12_command_list_emit_multi_dispatch_indirect_count_state(struct d3d12_command_list *list,
+        struct d3d12_command_signature *signature,
+        VkDeviceAddress indirect_args,
+        uint32_t stride, uint32_t max_commands,
+        VkDeviceAddress count_arg,
+        struct vkd3d_scratch_allocation *dispatch_scratch,
+        struct vkd3d_scratch_allocation *ubo_scratch)
+{
+    const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
+    struct vkd3d_multi_dispatch_indirect_info pipeline_info;
+    struct vkd3d_multi_dispatch_indirect_state_args args;
+    struct vkd3d_scratch_allocation template_scratch;
+    VkMemoryBarrier vk_barrier;
+
+    vkd3d_meta_get_multi_dispatch_indirect_state_pipeline(&list->device->meta_ops, &pipeline_info);
+
+    if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
+            VKD3D_SCRATCH_POOL_KIND_UNIFORM_UPLOAD,
+            D3D12_MAX_ROOT_COST * sizeof(uint32_t) +
+                    sizeof(signature->state_template.compute.source_offsets),
+            sizeof(uint32_t), ~0u, &template_scratch))
+        return false;
+
+    if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
+            VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
+            sizeof(VkDispatchIndirectCommand) * max_commands,
+            sizeof(uint32_t), ~0u, dispatch_scratch))
+        return false;
+
+    if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
+            VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
+            (D3D12_MAX_ROOT_COST * sizeof(uint32_t)) * max_commands,
+            D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT,
+            ~0u, ubo_scratch))
+        return false;
+
+    d3d12_command_list_fetch_root_parameter_data(list, &list->compute_bindings, template_scratch.host_ptr);
+    memcpy(void_ptr_offset(template_scratch.host_ptr, D3D12_MAX_ROOT_COST * sizeof(uint32_t)),
+            signature->state_template.compute.source_offsets,
+            sizeof(signature->state_template.compute.source_offsets));
+
+    args.indirect_va = indirect_args;
+    args.count_va = count_arg;
+    args.dispatch_va = dispatch_scratch->va;
+    args.root_parameters_va = ubo_scratch->va;
+    args.root_parameter_template_va = template_scratch.va;
+    args.stride_words = stride / sizeof(uint32_t);
+    args.dispatch_offset_words = signature->state_template.compute.dispatch_offset_words;
+
+    /* TODO: We can hoist the command similar to execute indirect template resolve. */
+
+    VK_CALL(vkCmdBindPipeline(list->vk_command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
+            pipeline_info.vk_pipeline));
+    VK_CALL(vkCmdPushConstants(list->vk_command_buffer,
+            pipeline_info.vk_pipeline_layout, VK_SHADER_STAGE_COMPUTE_BIT,
+            0, sizeof(args), &args));
+
+    vk_barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
+    vk_barrier.pNext = NULL;
+    vk_barrier.srcAccessMask = 0;
+    vk_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
+
+    VK_CALL(vkCmdPipelineBarrier(list->vk_command_buffer,
+            VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+            0, 1, &vk_barrier, 0, NULL, 0, NULL));
+
+    VK_CALL(vkCmdDispatch(list->vk_command_buffer, max_commands, 1, 1));
+
+    vk_barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+    vk_barrier.dstAccessMask = VK_ACCESS_INDIRECT_COMMAND_READ_BIT | VK_ACCESS_UNIFORM_READ_BIT;
+
+    VK_CALL(vkCmdPipelineBarrier(list->vk_command_buffer,
+            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+            VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+            0, 1, &vk_barrier, 0, NULL, 0, NULL));
+
+    VKD3D_BREADCRUMB_COMMAND(EXECUTE_INDIRECT_PATCH_STATE_COMPUTE);
     return true;
 }
 
@@ -11138,7 +11229,101 @@ static HRESULT d3d12_command_signature_allocate_preprocess_memory_for_list(
         uint32_t max_command_count,
         struct vkd3d_scratch_allocation *allocation, VkDeviceSize *size);
 
-static void d3d12_command_list_execute_indirect_state_template(
+static void d3d12_command_list_execute_indirect_state_template_compute(
+        struct d3d12_command_list *list, struct d3d12_command_signature *signature,
+        uint32_t max_command_count,
+        struct d3d12_resource *arg_buffer, UINT64 arg_buffer_offset,
+        struct d3d12_resource *count_buffer, UINT64 count_buffer_offset)
+{
+    const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
+    VkDeviceAddress arg_va = arg_buffer->res.va + arg_buffer_offset;
+    struct vkd3d_scratch_allocation dispatch_scratch, ubo_scratch;
+    VkDeviceAddress count_va = 0;
+    VkWriteDescriptorSet write;
+    VkDescriptorBufferInfo buf;
+    VkPipelineLayout vk_layout;
+    uint32_t write_set;
+    unsigned int i;
+
+    d3d12_command_list_end_current_render_pass(list, false);
+    d3d12_command_list_end_transfer_batch(list);
+
+    if (count_buffer)
+        count_va = count_buffer->res.va + count_buffer_offset;
+
+    if (!d3d12_command_list_emit_multi_dispatch_indirect_count_state(list,
+            signature,
+            arg_va, signature->desc.ByteStride, max_command_count,
+            count_va, &dispatch_scratch, &ubo_scratch))
+        return;
+
+    d3d12_command_list_invalidate_current_pipeline(list, true);
+    d3d12_command_list_invalidate_root_parameters(list, &list->compute_bindings, true);
+
+    if (!d3d12_command_list_update_compute_state(list))
+    {
+        WARN("Failed to update compute state, ignoring dispatch.\n");
+        return;
+    }
+
+    vk_write_descriptor_set_from_scratch_push_ubo(&write, &buf, &ubo_scratch,
+            D3D12_MAX_ROOT_COST * sizeof(uint32_t),
+            list->compute_bindings.root_signature->push_constant_ubo_binding.binding);
+
+    vk_layout = list->compute_bindings.root_signature->compute.vk_pipeline_layout;
+    write_set = list->compute_bindings.root_signature->push_constant_ubo_binding.set;
+
+    /* Run indirect dispatches back to back with one push UBO per dispatch which lets us
+     * update root parameters per command. */
+    for (i = 0; i < max_command_count; i++)
+    {
+        VK_CALL(vkCmdPushDescriptorSetKHR(list->vk_command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
+                vk_layout, write_set, 1, &write));
+        VK_CALL(vkCmdDispatchIndirect(list->vk_command_buffer, dispatch_scratch.buffer, dispatch_scratch.offset));
+
+        VKD3D_BREADCRUMB_AUX32(i);
+        VKD3D_BREADCRUMB_COMMAND(EXECUTE_INDIRECT_UNROLL_COMPUTE);
+
+        dispatch_scratch.offset += sizeof(VkDispatchIndirectCommand);
+        buf.offset += D3D12_MAX_ROOT_COST * sizeof(uint32_t);
+    }
+
+    /* Need to clear state to zero if it was part of a command signature. */
+    for (i = 0; i < signature->desc.NumArgumentDescs; i++)
+    {
+        const D3D12_INDIRECT_ARGUMENT_DESC *arg = &signature->desc.pArgumentDescs[i];
+        switch (arg->Type)
+        {
+            case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW:
+            case D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW:
+            case D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW:
+            {
+                uint32_t index = arg->ConstantBufferView.RootParameterIndex;
+                d3d12_command_list_set_root_descriptor(list,
+                        &list->compute_bindings, index, 0);
+                break;
+            }
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT:
+            {
+                uint32_t zeroes[D3D12_MAX_ROOT_COST];
+                memset(zeroes, 0, sizeof(uint32_t) * arg->Constant.Num32BitValuesToSet);
+                d3d12_command_list_set_root_constants(list,
+                        &list->compute_bindings, arg->Constant.RootParameterIndex,
+                        arg->Constant.DestOffsetIn32BitValues,
+                        arg->Constant.Num32BitValuesToSet, zeroes);
+                break;
+            }
+
+            default:
+                break;
+        }
+    }
+
+    /* No need to implicitly invalidate anything here, since we used the normal APIs. */
+}
+
+static void d3d12_command_list_execute_indirect_state_template_graphics(
         struct d3d12_command_list *list, struct d3d12_command_signature *signature,
         uint32_t max_command_count,
         struct d3d12_resource *arg_buffer, UINT64 arg_buffer_offset,
@@ -11450,10 +11635,23 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
         /* Complex execute indirect path. */
         if (list->predicate_va)
             FIXME("Predicated ExecuteIndirect with state template not supported yet. Ignoring predicate.\n");
-        d3d12_command_list_execute_indirect_state_template(list, sig_impl,
-                max_command_count,
-                arg_impl, arg_buffer_offset,
-                count_impl, count_buffer_offset);
+
+        if (sig_impl->pipeline_type == VKD3D_PIPELINE_TYPE_GRAPHICS ||
+                sig_impl->pipeline_type == VKD3D_PIPELINE_TYPE_MESH_GRAPHICS)
+        {
+            d3d12_command_list_execute_indirect_state_template_graphics(list, sig_impl,
+                    max_command_count,
+                    arg_impl, arg_buffer_offset,
+                    count_impl, count_buffer_offset);
+        }
+        else if (sig_impl->pipeline_type == VKD3D_PIPELINE_TYPE_COMPUTE)
+        {
+            d3d12_command_list_execute_indirect_state_template_compute(list, sig_impl,
+                    max_command_count,
+                    arg_impl, arg_buffer_offset,
+                    count_impl, count_buffer_offset);
+        }
+
         VKD3D_BREADCRUMB_COMMAND(EXECUTE_INDIRECT_TEMPLATE);
         return;
     }
@@ -11611,6 +11809,8 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
                 for (i = 0; i < max_command_count; i++)
                 {
                     VK_CALL(vkCmdDispatchIndirect(list->vk_command_buffer, scratch.buffer, scratch.offset));
+                    VKD3D_BREADCRUMB_AUX32(i);
+                    VKD3D_BREADCRUMB_COMMAND(EXECUTE_INDIRECT_UNROLL_COMPUTE);
                     scratch.offset += unrolled_stride;
                 }
                 break;
diff --git a/libs/vkd3d/meson.build b/libs/vkd3d/meson.build
index 9668b2744..ef33ad708 100644
--- a/libs/vkd3d/meson.build
+++ b/libs/vkd3d/meson.build
@@ -30,6 +30,7 @@ vkd3d_shaders =[
   'shaders/cs_execute_indirect_patch.comp',
   'shaders/cs_execute_indirect_patch_debug_ring.comp',
   'shaders/cs_execute_indirect_multi_dispatch.comp',
+  'shaders/cs_execute_indirect_multi_dispatch_state.comp',
 ]
 
 vkd3d_src = [
diff --git a/libs/vkd3d/meta.c b/libs/vkd3d/meta.c
index 9f6cea2b0..b8d4888a6 100644
--- a/libs/vkd3d/meta.c
+++ b/libs/vkd3d/meta.c
@@ -1127,12 +1127,24 @@ HRESULT vkd3d_multi_dispatch_indirect_ops_init(
             &push_constant_range, &meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_layout)) < 0)
         return hresult_from_vk_result(vr);
 
+    push_constant_range.size = sizeof(struct vkd3d_multi_dispatch_indirect_state_args);
+
+    if ((vr = vkd3d_meta_create_pipeline_layout(device, 0, NULL, 1,
+            &push_constant_range, &meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_state_layout)) < 0)
+        return hresult_from_vk_result(vr);
+
     if ((vr = vkd3d_meta_create_compute_pipeline(device,
             sizeof(cs_execute_indirect_multi_dispatch), cs_execute_indirect_multi_dispatch,
             meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_layout, NULL, true,
             &meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_pipeline)) < 0)
         goto fail;
 
+    if ((vr = vkd3d_meta_create_compute_pipeline(device,
+            sizeof(cs_execute_indirect_multi_dispatch_state), cs_execute_indirect_multi_dispatch_state,
+            meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_state_layout, NULL, true,
+            &meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_state_pipeline)) < 0)
+        goto fail;
+
     return S_OK;
 
 fail:
@@ -1145,8 +1157,14 @@ void vkd3d_multi_dispatch_indirect_ops_cleanup(
         struct d3d12_device *device)
 {
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
-    VK_CALL(vkDestroyPipeline(device->vk_device, meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_pipeline, NULL));
-    VK_CALL(vkDestroyPipelineLayout(device->vk_device, meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_layout, NULL));
+    VK_CALL(vkDestroyPipeline(device->vk_device,
+            meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_pipeline, NULL));
+    VK_CALL(vkDestroyPipeline(device->vk_device,
+            meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_state_pipeline, NULL));
+    VK_CALL(vkDestroyPipelineLayout(device->vk_device,
+            meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_layout, NULL));
+    VK_CALL(vkDestroyPipelineLayout(device->vk_device,
+            meta_multi_dispatch_indirect_ops->vk_multi_dispatch_indirect_state_layout, NULL));
 }
 
 HRESULT vkd3d_predicate_ops_init(struct vkd3d_predicate_ops *meta_predicate_ops,
@@ -1249,6 +1267,13 @@ void vkd3d_meta_get_multi_dispatch_indirect_pipeline(struct vkd3d_meta_ops *meta
     info->vk_pipeline_layout = meta_ops->multi_dispatch_indirect.vk_multi_dispatch_indirect_layout;
 }
 
+void vkd3d_meta_get_multi_dispatch_indirect_state_pipeline(struct vkd3d_meta_ops *meta_ops,
+        struct vkd3d_multi_dispatch_indirect_info *info)
+{
+    info->vk_pipeline = meta_ops->multi_dispatch_indirect.vk_multi_dispatch_indirect_state_pipeline;
+    info->vk_pipeline_layout = meta_ops->multi_dispatch_indirect.vk_multi_dispatch_indirect_state_layout;
+}
+
 HRESULT vkd3d_execute_indirect_ops_init(struct vkd3d_execute_indirect_ops *meta_indirect_ops,
         struct d3d12_device *device)
 {
diff --git a/libs/vkd3d/shaders/cs_execute_indirect_multi_dispatch.comp b/libs/vkd3d/shaders/cs_execute_indirect_multi_dispatch.comp
new file mode 100644
index 000000000..43f3b6dba
--- /dev/null
+++ b/libs/vkd3d/shaders/cs_execute_indirect_multi_dispatch.comp
@@ -0,0 +1,56 @@
+#version 450
+#extension GL_EXT_buffer_reference : require
+
+layout(local_size_x = 32) in;
+
+layout(buffer_reference_align = 4, std430, buffer_reference) readonly buffer Indirect
+{
+	uint values[];
+};
+
+layout(buffer_reference_align = 4, std430, buffer_reference) writeonly buffer IndirectOutput
+{
+	uint values[];
+};
+
+layout(buffer_reference_align = 4, std430, buffer_reference) readonly buffer IndirectCount
+{
+	uint value;
+};
+
+layout(push_constant) uniform Registers
+{
+	Indirect indirect;
+	IndirectCount count;
+	IndirectOutput out_dispatch;
+	uint stride_words;
+	uint max_commands;
+};
+
+void main()
+{
+	uint cmd_index = gl_GlobalInvocationID.x;
+	if (cmd_index >= max_commands)
+		return;
+
+	uint indirect_count = count.value;
+
+	uint offset = cmd_index * stride_words;
+	uvec3 wgs;
+	if (cmd_index < indirect_count)
+	{
+		wgs = uvec3(indirect.values[offset + 0],
+				indirect.values[offset + 1],
+				indirect.values[offset + 2]);
+	}
+	else
+	{
+		wgs = uvec3(0);
+	}
+
+	out_dispatch.values[3 * cmd_index + 0] = wgs.x;
+	out_dispatch.values[3 * cmd_index + 1] = wgs.y;
+	out_dispatch.values[3 * cmd_index + 2] = wgs.z;
+}
+
+
diff --git a/libs/vkd3d/shaders/cs_execute_indirect_multi_dispatch_state.comp b/libs/vkd3d/shaders/cs_execute_indirect_multi_dispatch_state.comp
new file mode 100644
index 000000000..acb8f5f84
--- /dev/null
+++ b/libs/vkd3d/shaders/cs_execute_indirect_multi_dispatch_state.comp
@@ -0,0 +1,85 @@
+#version 450
+#extension GL_EXT_buffer_reference : require
+#extension GL_EXT_buffer_reference_uvec2 : require
+
+// Always emit a full 256 byte payload for each UBO. We have to assume worst case alignment anyways,
+// little point in trying to be smart about it.
+layout(local_size_x = 64) in;
+
+layout(buffer_reference_align = 4, std430, buffer_reference) readonly buffer Indirect
+{
+	uint values[];
+};
+
+layout(buffer_reference_align = 4, std430, buffer_reference) writeonly buffer IndirectOutput
+{
+	uint values[];
+};
+
+layout(buffer_reference_align = 4, std430, buffer_reference) readonly buffer IndirectCount
+{
+	uint value;
+};
+
+struct RootParameterBlock
+{
+	uint values[64];
+};
+
+layout(buffer_reference_align = 16, std430, buffer_reference) writeonly buffer OutputRootParameters
+{
+	RootParameterBlock blocks[];
+};
+
+layout(buffer_reference_align = 4, std430, buffer_reference) readonly buffer Template
+{
+	uint input_root_parameters[64];
+	int source_word_offsets[64];
+};
+
+layout(push_constant) uniform Registers
+{
+	Indirect indirect;
+	uvec2 count_va;
+	IndirectOutput out_dispatch;
+	OutputRootParameters out_root_parameters;
+	Template in_template;
+	uint stride_words;
+	uint dispatch_offset_words;
+};
+
+void main()
+{
+	bool active_dispatch;
+	if (any(notEqual(count_va, uvec2(0))))
+		active_dispatch = gl_WorkGroupID.x < IndirectCount(count_va).value;
+	else
+		active_dispatch = true;
+
+	uint input_offset_base = gl_WorkGroupID.x * stride_words;
+
+	uint new_root_parameter;
+	int source_offset = in_template.source_word_offsets[gl_LocalInvocationIndex];
+	if (source_offset >= 0)
+		new_root_parameter = indirect.values[input_offset_base + source_offset];
+	else
+		new_root_parameter = in_template.input_root_parameters[gl_LocalInvocationIndex];
+
+	out_root_parameters.blocks[gl_WorkGroupID.x].values[gl_LocalInvocationIndex] = new_root_parameter;
+
+	// TODO: We can change this constant to suit our needs if we need multi-indirect any kind of dispatch really.
+	// Spec constant is good for that scenario.
+
+	const uint DISPATCH_NUM_WORDS = 3;
+	if (gl_LocalInvocationIndex < DISPATCH_NUM_WORDS)
+	{
+		uint input_value;
+		if (active_dispatch)
+			input_value = indirect.values[input_offset_base + dispatch_offset_words + gl_LocalInvocationIndex];
+		else
+			input_value = 0u;
+
+		out_dispatch.values[DISPATCH_NUM_WORDS * gl_WorkGroupID.x + gl_LocalInvocationIndex] = input_value;
+	}
+}
+
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index f3e0625f5..70dfde748 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -3118,6 +3118,9 @@ enum vkd3d_breadcrumb_command_type
     VKD3D_BREADCRUMB_COMMAND_DISCARD,
     VKD3D_BREADCRUMB_COMMAND_CLEAR_INLINE,
     VKD3D_BREADCRUMB_COMMAND_CLEAR_PASS,
+    VKD3D_BREADCRUMB_COMMAND_EXECUTE_INDIRECT_PATCH_COMPUTE,
+    VKD3D_BREADCRUMB_COMMAND_EXECUTE_INDIRECT_PATCH_STATE_COMPUTE,
+    VKD3D_BREADCRUMB_COMMAND_EXECUTE_INDIRECT_UNROLL_COMPUTE,
 };
 
 #ifdef VKD3D_ENABLE_BREADCRUMBS
@@ -3757,10 +3760,23 @@ struct vkd3d_multi_dispatch_indirect_args
     uint32_t max_commands;
 };
 
+struct vkd3d_multi_dispatch_indirect_state_args
+{
+    VkDeviceAddress indirect_va;
+    VkDeviceAddress count_va;
+    VkDeviceAddress dispatch_va;
+    VkDeviceAddress root_parameters_va;
+    VkDeviceAddress root_parameter_template_va;
+    uint32_t stride_words;
+    uint32_t dispatch_offset_words;
+};
+
 struct vkd3d_multi_dispatch_indirect_ops
 {
     VkPipelineLayout vk_multi_dispatch_indirect_layout;
+    VkPipelineLayout vk_multi_dispatch_indirect_state_layout;
     VkPipeline vk_multi_dispatch_indirect_pipeline;
+    VkPipeline vk_multi_dispatch_indirect_state_pipeline;
 };
 
 HRESULT vkd3d_multi_dispatch_indirect_ops_init(struct vkd3d_multi_dispatch_indirect_ops *meta_predicate_ops,
@@ -3854,6 +3870,8 @@ void vkd3d_meta_get_predicate_pipeline(struct vkd3d_meta_ops *meta_ops,
 
 void vkd3d_meta_get_multi_dispatch_indirect_pipeline(struct vkd3d_meta_ops *meta_ops,
         struct vkd3d_multi_dispatch_indirect_info *info);
+void vkd3d_meta_get_multi_dispatch_indirect_state_pipeline(struct vkd3d_meta_ops *meta_ops,
+        struct vkd3d_multi_dispatch_indirect_info *info);
 
 static inline uint32_t vkd3d_meta_get_multi_dispatch_indirect_workgroup_size(void)
 {
diff --git a/libs/vkd3d/vkd3d_shaders.h b/libs/vkd3d/vkd3d_shaders.h
index 801521f25..605b00d67 100644
--- a/libs/vkd3d/vkd3d_shaders.h
+++ b/libs/vkd3d/vkd3d_shaders.h
@@ -48,6 +48,7 @@ enum vkd3d_meta_copy_mode
 #include <cs_execute_indirect_patch.h>
 #include <cs_execute_indirect_patch_debug_ring.h>
 #include <cs_execute_indirect_multi_dispatch.h>
+#include <cs_execute_indirect_multi_dispatch_state.h>
 #include <vs_fullscreen_layer.h>
 #include <vs_fullscreen.h>
 #include <gs_fullscreen.h>

From 69698f2be5bcb13dbe3fd1e714f03fa6eb8f81f9 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 15 Mar 2023 19:59:52 +0100
Subject: [PATCH 12/16] vkd3d: Ensure push UBO path flushes all dirty state.

If we only had dirty root constants but not raw VAs,
we'd forget to update those VAs.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index dcada8491..8614acfee 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -5737,6 +5737,11 @@ static void d3d12_command_list_update_root_descriptors(struct d3d12_command_list
                 VKD3D_SCRATCH_POOL_KIND_UNIFORM_UPLOAD, sizeof(root_parameter_data),
                 D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT, ~0u, &alloc);
         ptr_root_parameter_data = alloc.host_ptr;
+
+        /* Dirty all state that enters push UBO block to make sure it's emitted.
+         * Push descriptors that are not raw VA can be emitted on a partial basis.
+         * Root constants and tables are always considered dirty here, so omit that. */
+        bindings->root_descriptor_dirty_mask |= root_signature->root_descriptor_raw_va_mask;
     }
     else
         ptr_root_parameter_data = &root_parameter_data;

From 06aa7d8211e07fed522892122bb93262cd46254d Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 15 Mar 2023 20:04:18 +0100
Subject: [PATCH 13/16] vkd3d: Remove TODOs from multi-indirect-dispatch tests.

Have to use the magic VKD3D_CONFIG to pass tests for now, otherwise they
are skipped.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 tests/d3d12_command.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/tests/d3d12_command.c b/tests/d3d12_command.c
index 2f874b996..9ca149a75 100644
--- a/tests/d3d12_command.c
+++ b/tests/d3d12_command.c
@@ -1600,7 +1600,7 @@ void test_execute_indirect_multi_dispatch_root_descriptors(void)
     {
         uint32_t value;
         value = get_readback_uint(&rb, i, 0, 0);
-        todo ok(value == expected_counts[i], "Value %u: Expected %u, got %u.\n", i, expected_counts[i], value);
+        todo_if(!signature) ok(value == expected_counts[i], "Value %u: Expected %u, got %u.\n", i, expected_counts[i], value);
     }
 
     release_resource_readback(&rb);
@@ -1765,7 +1765,7 @@ void test_execute_indirect_multi_dispatch_root_constants(void)
         }
         expected += 7; /* For the single 1, 1, 1 dispatch. */
         value = get_readback_uint(&rb, test_index, 0, 0);
-        todo ok(value == expected, "Iteration %u: Expected %u, got %u.\n", test_index, expected, value);
+        todo_if(!signature) ok(value == expected, "Iteration %u: Expected %u, got %u.\n", test_index, expected, value);
     }
 
     release_resource_readback(&rb);

From 83f3e202355ef9bdccd66b95b8e88f626650064c Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 15 Mar 2023 20:23:07 +0100
Subject: [PATCH 14/16] vkd3d: Hoist execute indirect patch work to
 init_cmd_buffer.

Add extra flags to consider COMPUTE / UNIFORM_BIT when patching root
parameters as well.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c       | 133 +++++++++++++++++++++++++------------
 libs/vkd3d/vkd3d_private.h |   1 +
 2 files changed, 90 insertions(+), 44 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 8614acfee..b6431593c 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -4774,14 +4774,21 @@ static HRESULT d3d12_command_list_build_init_commands(struct d3d12_command_list
 
     if (list->execute_indirect.has_emitted_indirect_to_compute_barrier)
     {
+        VkPipelineStageFlags dst_stages = VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT;
         /* We've patched an indirect command stream here, so do the final barrier now. */
         barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
         barrier.pNext = NULL;
         barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
         barrier.dstAccessMask = VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
+
+        if (list->execute_indirect.has_emitted_indirect_to_compute_cbv_barrier)
+        {
+            barrier.dstAccessMask |= VK_ACCESS_UNIFORM_READ_BIT;
+            dst_stages |= VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;
+        }
+
         VK_CALL(vkCmdPipelineBarrier(list->vk_init_commands, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
-                VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
-                0, 1, &barrier, 0, NULL, 0, NULL));
+                dst_stages, 0, 1, &barrier, 0, NULL, 0, NULL));
     }
 
     if ((vr = VK_CALL(vkEndCommandBuffer(list->vk_init_commands))) < 0)
@@ -5112,6 +5119,7 @@ static void d3d12_command_list_reset_internal_state(struct d3d12_command_list *l
     list->query_resolve_count = 0;
 
     list->execute_indirect.has_emitted_indirect_to_compute_barrier = false;
+    list->execute_indirect.has_emitted_indirect_to_compute_cbv_barrier = false;
     list->execute_indirect.has_observed_transition_to_indirect = false;
 }
 
@@ -6202,6 +6210,7 @@ static bool d3d12_command_list_emit_multi_dispatch_indirect_count(struct d3d12_c
     const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
     struct vkd3d_multi_dispatch_indirect_info pipeline_info;
     struct vkd3d_multi_dispatch_indirect_args args;
+    VkCommandBuffer vk_patch_cmd_buffer;
     VkMemoryBarrier vk_barrier;
 
     vkd3d_meta_get_multi_dispatch_indirect_pipeline(&list->device->meta_ops, &pipeline_info);
@@ -6212,8 +6221,32 @@ static bool d3d12_command_list_emit_multi_dispatch_indirect_count(struct d3d12_c
         return false;
 
     d3d12_command_list_end_current_render_pass(list, true);
-    d3d12_command_list_invalidate_current_pipeline(list, true);
-    d3d12_command_list_invalidate_root_parameters(list, &list->compute_bindings, true);
+
+    vk_barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
+    vk_barrier.pNext = NULL;
+    vk_barrier.srcAccessMask = 0;
+    vk_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
+
+    if (!list->execute_indirect.has_observed_transition_to_indirect)
+    {
+        /* Fast path, throw the resolve to the init command buffer. */
+        d3d12_command_allocator_allocate_init_command_buffer(list->allocator, list);
+        vk_patch_cmd_buffer = list->vk_init_commands;
+        if (!list->execute_indirect.has_emitted_indirect_to_compute_barrier)
+        {
+            VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+                    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 1, &vk_barrier, 0, NULL, 0, NULL));
+            list->execute_indirect.has_emitted_indirect_to_compute_barrier = true;
+        }
+    }
+    else
+    {
+        vk_patch_cmd_buffer = list->vk_command_buffer;
+        VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+                VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 1, &vk_barrier, 0, NULL, 0, NULL));
+        d3d12_command_list_invalidate_current_pipeline(list, true);
+        d3d12_command_list_invalidate_root_parameters(list, &list->compute_bindings, true);
+    }
 
     args.indirect_va = indirect_args;
     args.count_va = count_arg;
@@ -6221,35 +6254,26 @@ static bool d3d12_command_list_emit_multi_dispatch_indirect_count(struct d3d12_c
     args.stride_words = stride / sizeof(uint32_t);
     args.max_commands = max_commands;
 
-    /* TODO: We can hoist the command similar to execute indirect template resolve. */
-
-    VK_CALL(vkCmdBindPipeline(list->vk_command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
+    VK_CALL(vkCmdBindPipeline(vk_patch_cmd_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
             pipeline_info.vk_pipeline));
-    VK_CALL(vkCmdPushConstants(list->vk_command_buffer,
+    VK_CALL(vkCmdPushConstants(vk_patch_cmd_buffer,
             pipeline_info.vk_pipeline_layout, VK_SHADER_STAGE_COMPUTE_BIT,
             0, sizeof(args), &args));
 
-    vk_barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
-    vk_barrier.pNext = NULL;
-    vk_barrier.srcAccessMask = 0;
-    vk_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
-
-    VK_CALL(vkCmdPipelineBarrier(list->vk_command_buffer,
-            VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
-            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
-            0, 1, &vk_barrier, 0, NULL, 0, NULL));
-
-    VK_CALL(vkCmdDispatch(list->vk_command_buffer,
+    VK_CALL(vkCmdDispatch(vk_patch_cmd_buffer,
             vkd3d_compute_workgroup_count(max_commands, vkd3d_meta_get_multi_dispatch_indirect_workgroup_size()),
             1, 1));
 
-    vk_barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
-    vk_barrier.dstAccessMask = VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
+    if (vk_patch_cmd_buffer == list->vk_command_buffer)
+    {
+        vk_barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+        vk_barrier.dstAccessMask = VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
 
-    VK_CALL(vkCmdPipelineBarrier(list->vk_command_buffer,
-            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
-            VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
-            0, 1, &vk_barrier, 0, NULL, 0, NULL));
+        VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer,
+                VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+                0, 1, &vk_barrier, 0, NULL, 0, NULL));
+    }
 
     VKD3D_BREADCRUMB_COMMAND(EXECUTE_INDIRECT_PATCH_COMPUTE);
     return true;
@@ -6267,6 +6291,7 @@ static bool d3d12_command_list_emit_multi_dispatch_indirect_count_state(struct d
     struct vkd3d_multi_dispatch_indirect_info pipeline_info;
     struct vkd3d_multi_dispatch_indirect_state_args args;
     struct vkd3d_scratch_allocation template_scratch;
+    VkCommandBuffer vk_patch_cmd_buffer;
     VkMemoryBarrier vk_barrier;
 
     vkd3d_meta_get_multi_dispatch_indirect_state_pipeline(&list->device->meta_ops, &pipeline_info);
@@ -6304,33 +6329,56 @@ static bool d3d12_command_list_emit_multi_dispatch_indirect_count_state(struct d
     args.stride_words = stride / sizeof(uint32_t);
     args.dispatch_offset_words = signature->state_template.compute.dispatch_offset_words;
 
-    /* TODO: We can hoist the command similar to execute indirect template resolve. */
-
-    VK_CALL(vkCmdBindPipeline(list->vk_command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
-            pipeline_info.vk_pipeline));
-    VK_CALL(vkCmdPushConstants(list->vk_command_buffer,
-            pipeline_info.vk_pipeline_layout, VK_SHADER_STAGE_COMPUTE_BIT,
-            0, sizeof(args), &args));
-
     vk_barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
     vk_barrier.pNext = NULL;
     vk_barrier.srcAccessMask = 0;
     vk_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
 
-    VK_CALL(vkCmdPipelineBarrier(list->vk_command_buffer,
+    if (!list->execute_indirect.has_observed_transition_to_indirect)
+    {
+        /* Fast path, throw the resolve to the init command buffer. */
+        d3d12_command_allocator_allocate_init_command_buffer(list->allocator, list);
+        vk_patch_cmd_buffer = list->vk_init_commands;
+        if (!list->execute_indirect.has_emitted_indirect_to_compute_barrier)
+        {
+            VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+                    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 1, &vk_barrier, 0, NULL, 0, NULL));
+            list->execute_indirect.has_emitted_indirect_to_compute_barrier = true;
+            list->execute_indirect.has_emitted_indirect_to_compute_cbv_barrier = true;
+        }
+    }
+    else
+    {
+        vk_patch_cmd_buffer = list->vk_command_buffer;
+        VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+                VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 1, &vk_barrier, 0, NULL, 0, NULL));
+        d3d12_command_list_invalidate_current_pipeline(list, true);
+        d3d12_command_list_invalidate_root_parameters(list, &list->compute_bindings, true);
+    }
+
+    VK_CALL(vkCmdBindPipeline(vk_patch_cmd_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
+            pipeline_info.vk_pipeline));
+    VK_CALL(vkCmdPushConstants(vk_patch_cmd_buffer,
+            pipeline_info.vk_pipeline_layout, VK_SHADER_STAGE_COMPUTE_BIT,
+            0, sizeof(args), &args));
+
+    VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer,
             VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
             VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
             0, 1, &vk_barrier, 0, NULL, 0, NULL));
 
-    VK_CALL(vkCmdDispatch(list->vk_command_buffer, max_commands, 1, 1));
+    VK_CALL(vkCmdDispatch(vk_patch_cmd_buffer, max_commands, 1, 1));
 
-    vk_barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
-    vk_barrier.dstAccessMask = VK_ACCESS_INDIRECT_COMMAND_READ_BIT | VK_ACCESS_UNIFORM_READ_BIT;
+    if (vk_patch_cmd_buffer == list->vk_command_buffer)
+    {
+        vk_barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+        vk_barrier.dstAccessMask = VK_ACCESS_INDIRECT_COMMAND_READ_BIT | VK_ACCESS_UNIFORM_READ_BIT;
 
-    VK_CALL(vkCmdPipelineBarrier(list->vk_command_buffer,
-            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
-            VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
-            0, 1, &vk_barrier, 0, NULL, 0, NULL));
+        VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer,
+                VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                0, 1, &vk_barrier, 0, NULL, 0, NULL));
+    }
 
     VKD3D_BREADCRUMB_COMMAND(EXECUTE_INDIRECT_PATCH_STATE_COMPUTE);
     return true;
@@ -11262,9 +11310,6 @@ static void d3d12_command_list_execute_indirect_state_template_compute(
             count_va, &dispatch_scratch, &ubo_scratch))
         return;
 
-    d3d12_command_list_invalidate_current_pipeline(list, true);
-    d3d12_command_list_invalidate_root_parameters(list, &list->compute_bindings, true);
-
     if (!d3d12_command_list_update_compute_state(list))
     {
         WARN("Failed to update compute state, ignoring dispatch.\n");
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 70dfde748..482467767 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -2594,6 +2594,7 @@ struct d3d12_command_list
     {
         bool has_observed_transition_to_indirect;
         bool has_emitted_indirect_to_compute_barrier;
+        bool has_emitted_indirect_to_compute_cbv_barrier;
     } execute_indirect;
 
     VkCommandBuffer vk_command_buffer;

From 11d731c30b132523c3fc33510c797365597e1a38 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 15 Mar 2023 20:34:58 +0100
Subject: [PATCH 15/16] tests: Update multi-dispatch-indirect tests with late
 barrier.

Make sure we can exercise both code paths.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 tests/d3d12_command.c | 30 ++++++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/tests/d3d12_command.c b/tests/d3d12_command.c
index 9ca149a75..1dd16badd 100644
--- a/tests/d3d12_command.c
+++ b/tests/d3d12_command.c
@@ -1573,6 +1573,16 @@ void test_execute_indirect_multi_dispatch_root_descriptors(void)
                     indirect, offsetof(struct test_data, dispatches[test_index]),
                     indirect, offsetof(struct test_data, dispatch_counts[iteration]));
         }
+
+        if (test_index == 6)
+        {
+            /* Test case with late indirect update. Just make sure we can exercise both
+             * code paths. */
+            transition_resource_state(context.list, indirect, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT,
+                    D3D12_RESOURCE_STATE_COPY_SOURCE);
+            transition_resource_state(context.list, indirect, D3D12_RESOURCE_STATE_COPY_SOURCE,
+                    D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT);
+        }
     }
 
     transition_resource_state(context.list, output, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COPY_SOURCE);
@@ -1740,6 +1750,16 @@ void test_execute_indirect_multi_dispatch_root_constants(void)
 
         /* Also test behavior for cleared root constant state. cbv.z should be cleared to 0 here. */
         ID3D12GraphicsCommandList_Dispatch(context.list, 1, 1, 1);
+
+        if (test_index == 6)
+        {
+            /* Test case with late indirect update. Just make sure we can exercise both
+             * code paths. */
+            transition_resource_state(context.list, indirect, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT,
+                    D3D12_RESOURCE_STATE_COPY_SOURCE);
+            transition_resource_state(context.list, indirect, D3D12_RESOURCE_STATE_COPY_SOURCE,
+                    D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT);
+        }
     }
 
     transition_resource_state(context.list, output, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COPY_SOURCE);
@@ -1885,6 +1905,16 @@ void test_execute_indirect_multi_dispatch(void)
                     indirect, 16 + 12 * test_index,
                     indirect, 4 * iteration);
         }
+
+        if (test_index == 6)
+        {
+            /* Test case with late indirect update. Just make sure we can exercise both
+             * code paths. */
+            transition_resource_state(context.list, indirect, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT,
+                    D3D12_RESOURCE_STATE_COPY_SOURCE);
+            transition_resource_state(context.list, indirect, D3D12_RESOURCE_STATE_COPY_SOURCE,
+                    D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT);
+        }
     }
 
     transition_resource_state(context.list, output, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COPY_SOURCE);

From 3829dc7c4f1048bc8e0bffbd96a5f4642fb06940 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 15 Mar 2023 21:16:50 +0100
Subject: [PATCH 16/16] vkd3d: Add push UBO workaround for Halo Infinite.

The game sure likes to troll us ... :')

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/device.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index ea89fe060..3a5e29c27 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -461,10 +461,13 @@ static const struct vkd3d_instance_application_meta application_override[] = {
     /* Halo Infinite (1240440).
      * Game relies on NON_ZEROED committed UAVs to be cleared to zero on allocation.
      * This works okay with zerovram on first game boot, but not later, since this memory is guaranteed to be recycled.
-     * Game also relies on indirectly modifying CBV root descriptors, which means we are forced to rely on RAW_VA_CBV. */
+     * Game also relies on indirectly modifying CBV root descriptors, which means we are forced to rely on RAW_VA_CBV.
+     * It also relies on multi-dispatch indirect with state updates which is ... ye.
+     * Need another config flag to workaround that as well. */
     { VKD3D_STRING_COMPARE_EXACT, "HaloInfinite.exe",
             VKD3D_CONFIG_FLAG_ZERO_MEMORY_WORKAROUNDS_COMMITTED_BUFFER_UAV | VKD3D_CONFIG_FLAG_FORCE_RAW_VA_CBV |
-            VKD3D_CONFIG_FLAG_USE_HOST_IMPORT_FALLBACK | VKD3D_CONFIG_FLAG_PREALLOCATE_SRV_MIP_CLAMPS, 0 },
+            VKD3D_CONFIG_FLAG_USE_HOST_IMPORT_FALLBACK | VKD3D_CONFIG_FLAG_PREALLOCATE_SRV_MIP_CLAMPS |
+            VKD3D_CONFIG_FLAG_FORCE_COMPUTE_ROOT_PARAMETERS_PUSH_UBO, 0 },
     /* (1182900) Workaround amdgpu kernel bug with host memory import and concurrent submissions. */
     { VKD3D_STRING_COMPARE_EXACT, "APlagueTaleRequiem_x64.exe", VKD3D_CONFIG_FLAG_USE_HOST_IMPORT_FALLBACK, 0 },
     /* Shadow of the Tomb Raider (750920).
