From 5fa24654c73dba73aa876482aa7d3214d8c7270f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andr=C3=A9=20Almeida?= <andrealmeid@collabora.com>
Date: Fri, 27 Nov 2020 14:05:14 -0300
Subject: [PATCH 2/5] ntdll: Call waitv just when nr_futexes > 1
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

futex_waitv() needs to do an extra copy from userspace compared to
futex(), so use the latter when we are waiting in a single futex.

Signed-off-by: André Almeida <andrealmeid@collabora.com>
---
 dlls/ntdll/unix/fsync.c | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 1ed91ece3f6..4ccf557e587 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -980,10 +980,18 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                 tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
                 tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;

-                ret = futex_wait_multiple( futexes, waitcount, &tmo_p );
+                if (waitcount == 1)
+                    ret = futex_wait( futexes[0].addr, futexes[0].val, &tmo_p );
+                else
+                    ret = futex_wait_multiple( futexes, waitcount, &tmo_p );
             }
             else
-                ret = futex_wait_multiple( futexes, waitcount, NULL );
+            {
+                if (waitcount == 1)
+                    ret = futex_wait( futexes[0].addr, futexes[0].val, NULL );
+                else
+                    ret = futex_wait_multiple( futexes, waitcount, NULL );
+            }

             /* FUTEX_WAIT_MULTIPLE can succeed or return -EINTR, -EAGAIN,
              * -EFAULT/-EACCES, -ETIMEDOUT. In the first three cases we need to
--
2.33.1

From fe7f5575abbbde228cdb8843eb6929b5f0877572 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andr=C3=A9=20Almeida?= <andrealmeid@collabora.com>
Date: Wed, 20 Oct 2021 10:35:58 -0300
Subject: [PATCH 3/5] ntdll/fsync: Encapsulate timeout conversion
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Simplify the wait path by dealing with the timeout conversion
inside of futex_wait.

Signed-off-by: André Almeida <andrealmeid@collabora.com>
---
 dlls/ntdll/unix/fsync.c | 94 ++++++++++++++++++-----------------------
 1 file changed, 42 insertions(+), 52 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 4ccf557e587..ecc8abc1d67 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -76,10 +76,32 @@ static inline void small_pause(void)
 #endif
 }

+static LONGLONG update_timeout( ULONGLONG end )
+{
+    LARGE_INTEGER now;
+    LONGLONG timeleft;
+
+    NtQuerySystemTime( &now );
+    timeleft = end - now.QuadPart;
+    if (timeleft < 0) timeleft = 0;
+    return timeleft;
+}
+
 static inline int futex_wait_multiple( const struct futex_wait_block *futexes,
-        int count, const struct timespec *timeout )
+        int count, const ULONGLONG *end )
 {
-    return syscall( __NR_futex, futexes, 31, count, timeout, 0, 0 );
+   if (end)
+   {
+        LONGLONG timeleft = update_timeout( *end );
+        struct timespec timeout;
+        timeout.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
+        timeout.tv_nsec = (timeleft % TICKSPERSEC) * 100;
+        return syscall( __NR_futex, futexes, 31, count, timeout, 0, 0 );
+   }
+   else
+   {
+        return syscall( __NR_futex, futexes, 31, count, NULL, 0, 0 );
+   }
 }

 static inline int futex_wake( int *addr, int val )
@@ -87,9 +109,20 @@ static inline int futex_wake( int *addr, int val )
     return syscall( __NR_futex, addr, 1, val, NULL, 0, 0 );
 }

-static inline int futex_wait( int *addr, int val, struct timespec *timeout )
+static inline int futex_wait( int *addr, int val, const ULONGLONG *end )
 {
-    return syscall( __NR_futex, addr, 0, val, timeout, 0, 0 );
+    if (end)
+    {
+        LONGLONG timeleft = update_timeout( *end );
+        struct timespec timeout;
+        timeout.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
+        timeout.tv_nsec = (timeleft % TICKSPERSEC) * 100;
+        return syscall( __NR_futex, addr, 0, val, &timeout, 0, 0 );
+    }
+    else
+    {
+        return syscall( __NR_futex, addr, 0, val, NULL, 0, 0 );
+    }
 }

 static unsigned int spincount = 100;
@@ -645,17 +678,6 @@ NTSTATUS fsync_query_mutex( HANDLE handle, void *info, ULONG *ret_len )
     return STATUS_SUCCESS;
 }

-static LONGLONG update_timeout( ULONGLONG end )
-{
-    LARGE_INTEGER now;
-    LONGLONG timeleft;
-
-    NtQuerySystemTime( &now );
-    timeleft = end - now.QuadPart;
-    if (timeleft < 0) timeleft = 0;
-    return timeleft;
-}
-
 static NTSTATUS do_single_wait( int *addr, int val, ULONGLONG *end, BOOLEAN alertable )
 {
     int ret;
@@ -677,32 +699,14 @@ static NTSTATUS do_single_wait( int *addr, int val, ULONGLONG *end, BOOLEAN aler
 #endif
         futexes[0].bitset = futexes[1].bitset = ~0;

-        if (end)
-        {
-            LONGLONG timeleft = update_timeout( *end );
-            struct timespec tmo_p;
-            tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
-            tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
-            ret = futex_wait_multiple( futexes, 2, &tmo_p );
-        }
-        else
-            ret = futex_wait_multiple( futexes, 2, NULL );
+        ret = futex_wait_multiple( futexes, 2, end );

         if (__atomic_load_n( apc_futex, __ATOMIC_SEQ_CST ))
             return STATUS_USER_APC;
     }
     else
     {
-        if (end)
-        {
-            LONGLONG timeleft = update_timeout( *end );
-            struct timespec tmo_p;
-            tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
-            tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
-            ret = futex_wait( addr, val, &tmo_p );
-        }
-        else
-            ret = futex_wait( addr, val, NULL );
+        ret = futex_wait( addr, val, end );
     }

     if (!ret)
@@ -973,25 +977,11 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                 TRACE("Wait timed out.\n");
                 return STATUS_TIMEOUT;
             }
-            else if (timeout)
-            {
-                LONGLONG timeleft = update_timeout( end );
-                struct timespec tmo_p;
-                tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
-                tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;

-                if (waitcount == 1)
-                    ret = futex_wait( futexes[0].addr, futexes[0].val, &tmo_p );
-                else
-                    ret = futex_wait_multiple( futexes, waitcount, &tmo_p );
-            }
+            if (waitcount == 1)
+                ret = futex_wait( futexes[0].addr, futexes[0].val, timeout ? &end : NULL );
             else
-            {
-                if (waitcount == 1)
-                    ret = futex_wait( futexes[0].addr, futexes[0].val, NULL );
-                else
-                    ret = futex_wait_multiple( futexes, waitcount, NULL );
-            }
+                ret = futex_wait_multiple( futexes, waitcount, timeout ? &end : NULL );

             /* FUTEX_WAIT_MULTIPLE can succeed or return -EINTR, -EAGAIN,
              * -EFAULT/-EACCES, -ETIMEDOUT. In the first three cases we need to
--
2.33.1

From 86d3547ea3899e2def64ef1e2bab5e0ed760d961 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andr=C3=A9=20Almeida?= <andrealmeid@collabora.com>
Date: Thu, 21 Oct 2021 13:36:14 -0300
Subject: [PATCH 4/5] ntdll/fsync: Support futex_waitv() API
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Since an interface for wait on multiple futexes was merged, we no longer
need to support different interfaces. Drop out FUTEX_WAIT_MULTIPLE
(opcode 31) in favor of the futex_waitv() interface accepted by
upstream Linux.

Signed-off-by: André Almeida <andrealmeid@collabora.com>
---
 dlls/ntdll/unix/fsync.c | 101 ++++++++++++++++++++--------------------
 server/fsync.c          |  19 ++------
 2 files changed, 55 insertions(+), 65 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index ecc8abc1d67..261f45ac4bf 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -41,6 +41,7 @@
 # include <sys/syscall.h>
 #endif
 #include <unistd.h>
+#include <stdint.h>

 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -56,16 +57,30 @@
 WINE_DEFAULT_DEBUG_CHANNEL(fsync);

 #include "pshpack4.h"
-struct futex_wait_block
-{
-    int *addr;
-#if __SIZEOF_POINTER__ == 4
-    int pad;
+#include "poppack.h"
+
+/* futex_waitv interface */
+
+#ifndef __NR_futex_waitv
+
+# define __NR_futex_waitv 449
+# define FUTEX_32 2
+struct futex_waitv {
+    uint64_t   val;
+    uint64_t   uaddr;
+    uint32_t   flags;
+    uint32_t __reserved;
+};
+
 #endif
-    int val;
-    int bitset;
+
+#define u64_to_ptr(x) (void *)(uintptr_t)(x)
+
+struct timespec64
+{
+    long long tv_sec;
+    long long tv_nsec;
 };
-#include "poppack.h"

 static inline void small_pause(void)
 {
@@ -87,20 +102,29 @@ static LONGLONG update_timeout( ULONGLONG end )
     return timeleft;
 }

-static inline int futex_wait_multiple( const struct futex_wait_block *futexes,
+static inline void futex_vector_set( struct futex_waitv *waitv, int *addr, int val )
+{
+    waitv->uaddr = (uintptr_t) addr;
+    waitv->val = val;
+    waitv->flags = FUTEX_32;
+    waitv->__reserved = 0;
+}
+
+static inline int futex_wait_multiple( const struct futex_waitv *futexes,
         int count, const ULONGLONG *end )
 {
    if (end)
    {
-        LONGLONG timeleft = update_timeout( *end );
-        struct timespec timeout;
-        timeout.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
-        timeout.tv_nsec = (timeleft % TICKSPERSEC) * 100;
-        return syscall( __NR_futex, futexes, 31, count, timeout, 0, 0 );
+        struct timespec64 timeout;
+        ULONGLONG tmp = *end - SECS_1601_TO_1970 * TICKSPERSEC;
+        timeout.tv_sec = tmp / (ULONGLONG)TICKSPERSEC;
+        timeout.tv_nsec = (tmp % TICKSPERSEC) * 100;
+
+        return syscall( __NR_futex_waitv, futexes, count, 0, &timeout, CLOCK_REALTIME );
    }
    else
    {
-        return syscall( __NR_futex, futexes, 31, count, NULL, 0, 0 );
+        return syscall( __NR_futex_waitv, futexes, count, 0, NULL, 0 );
    }
 }

@@ -134,8 +158,7 @@ int do_fsync(void)

     if (do_fsync_cached == -1)
     {
-        static const struct timespec zero;
-        futex_wait_multiple( NULL, 0, &zero );
+        syscall( __NR_futex_waitv, NULL, 0, 0, NULL, 0 );
         do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
         if (getenv("WINEFSYNC_SPINCOUNT"))
             spincount = atoi(getenv("WINEFSYNC_SPINCOUNT"));
@@ -685,19 +708,13 @@ static NTSTATUS do_single_wait( int *addr, int val, ULONGLONG *end, BOOLEAN aler
     if (alertable)
     {
         int *apc_futex = ntdll_get_thread_data()->fsync_apc_futex;
-        struct futex_wait_block futexes[2];
+        struct futex_waitv futexes[2];

         if (__atomic_load_n( apc_futex, __ATOMIC_SEQ_CST ))
             return STATUS_USER_APC;

-        futexes[0].addr = addr;
-        futexes[0].val = val;
-        futexes[1].addr = apc_futex;
-        futexes[1].val = 0;
-#if __SIZEOF_POINTER__ == 4
-        futexes[0].pad = futexes[1].pad = 0;
-#endif
-        futexes[0].bitset = futexes[1].bitset = ~0;
+        futex_vector_set( &futexes[0], addr, val );
+        futex_vector_set( &futexes[1], apc_futex, 0 );

         ret = futex_wait_multiple( futexes, 2, end );

@@ -722,7 +739,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
 {
     static const LARGE_INTEGER zero = {0};

-    struct futex_wait_block futexes[MAXIMUM_WAIT_OBJECTS + 1];
+    struct futex_waitv futexes[MAXIMUM_WAIT_OBJECTS + 1];
     struct fsync *objs[MAXIMUM_WAIT_OBJECTS];
     int has_fsync = 0, has_server = 0;
     BOOL msgwait = FALSE;
@@ -852,8 +869,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                             small_pause();
                         }

-                        futexes[i].addr = &semaphore->count;
-                        futexes[i].val = 0;
+                        futex_vector_set( &futexes[i], &semaphore->count, 0 );
                         break;
                     }
                     case FSYNC_MUTEX:
@@ -885,8 +901,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                             small_pause();
                         }

-                        futexes[i].addr = &mutex->tid;
-                        futexes[i].val  = tid;
+                        futex_vector_set( &futexes[i], &mutex->tid, tid );
                         break;
                     }
                     case FSYNC_AUTO_EVENT:
@@ -907,8 +922,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                             small_pause();
                         }

-                        futexes[i].addr = &event->signaled;
-                        futexes[i].val = 0;
+                        futex_vector_set( &futexes[i], &event->signaled, 0 );
                         break;
                     }
                     case FSYNC_MANUAL_EVENT:
@@ -930,8 +944,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                             small_pause();
                         }

-                        futexes[i].addr = &event->signaled;
-                        futexes[i].val = 0;
+                        futex_vector_set( &futexes[i], &event->signaled, 0 );
                         break;
                     }
                     default:
@@ -942,26 +955,14 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                 else
                 {
                     /* Avoid breaking things entirely. */
-                    futexes[i].addr = &dummy_futex;
-                    futexes[i].val = dummy_futex;
+                    futex_vector_set( &futexes[i], &dummy_futex, dummy_futex );
                 }
-
-#if __SIZEOF_POINTER__ == 4
-                futexes[i].pad = 0;
-#endif
-                futexes[i].bitset = ~0;
             }

             if (alertable)
             {
                 /* We already checked if it was signaled; don't bother doing it again. */
-                futexes[i].addr = ntdll_get_thread_data()->fsync_apc_futex;
-                futexes[i].val = 0;
-#if __SIZEOF_POINTER__ == 4
-                futexes[i].pad = 0;
-#endif
-                futexes[i].bitset = ~0;
-                i++;
+                futex_vector_set( &futexes[i++], ntdll_get_thread_data()->fsync_apc_futex, 0 );
             }
             waitcount = i;

@@ -979,7 +980,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
             }

             if (waitcount == 1)
-                ret = futex_wait( futexes[0].addr, futexes[0].val, timeout ? &end : NULL );
+                ret = futex_wait( u64_to_ptr(futexes[0].uaddr), futexes[0].val, timeout ? &end : NULL );
             else
                 ret = futex_wait_multiple( futexes, waitcount, timeout ? &end : NULL );

diff --git a/server/fsync.c b/server/fsync.c
index 411918aa2be..237e8f2b4a4 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -47,21 +47,11 @@
 #include "fsync.h"

 #include "pshpack4.h"
-struct futex_wait_block
-{
-    int *addr;
-#if __SIZEOF_POINTER__ == 4
-    int pad;
-#endif
-    int val;
-};
 #include "poppack.h"

-static inline int futex_wait_multiple( const struct futex_wait_block *futexes,
-        int count, const struct timespec *timeout )
-{
-    return syscall( __NR_futex, futexes, 31, count, timeout, 0, 0 );
-}
+#ifndef __NR_futex_waitv
+#define __NR_futex_waitv 449
+#endif

 int do_fsync(void)
 {
@@ -70,8 +60,7 @@ int do_fsync(void)

     if (do_fsync_cached == -1)
     {
-        static const struct timespec zero;
-        futex_wait_multiple( NULL, 0, &zero );
+        syscall( __NR_futex_waitv, 0, 0, 0, 0, 0);
         do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
     }

--
2.33.1

From 5116e14a507f9fbe4a26234924db06ff6a0366f0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andr=C3=A9=20Almeida?= <andrealmeid@collabora.com>
Date: Thu, 21 Oct 2021 20:33:58 -0300
Subject: [PATCH 5/5] ntdll/fsync: Use absolute timeouts for futex_wait
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Use the FUTEX_WAIT_BITSET operation instead of FUTEX_WAIT, that allow us
to use absolute timeouts rather than relative ones that requires an
extra syscall to update the timeout.

Signed-off-by: André Almeida <andrealmeid@collabora.com>
---
 dlls/ntdll/unix/fsync.c | 14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 261f45ac4bf..1291f3171a1 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -59,6 +59,10 @@ WINE_DEFAULT_DEBUG_CHANNEL(fsync);
 #include "pshpack4.h"
 #include "poppack.h"

+#define FUTEX_WAIT_BITSET	9
+#define FUTEX_CLOCK_REALTIME	256
+#define FUTEX_BITSET_MATCH_ANY	0xffffffff
+
 /* futex_waitv interface */

 #ifndef __NR_futex_waitv
@@ -137,11 +141,13 @@ static inline int futex_wait( int *addr, int val, const ULONGLONG *end )
 {
     if (end)
     {
-        LONGLONG timeleft = update_timeout( *end );
         struct timespec timeout;
-        timeout.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
-        timeout.tv_nsec = (timeleft % TICKSPERSEC) * 100;
-        return syscall( __NR_futex, addr, 0, val, &timeout, 0, 0 );
+        ULONGLONG tmp = *end - SECS_1601_TO_1970 * TICKSPERSEC;
+        timeout.tv_sec = tmp / (ULONGLONG)TICKSPERSEC;
+        timeout.tv_nsec = (tmp % TICKSPERSEC) * 100;
+
+        return syscall( __NR_futex, addr, FUTEX_WAIT_BITSET | FUTEX_CLOCK_REALTIME,
+			val, &timeout, 0, FUTEX_BITSET_MATCH_ANY );
     }
     else
     {
--
2.33.1

From a55a995020e09bfb844b12cac02351cf970287c7 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Mon, 1 Nov 2021 14:25:42 +0200
Subject: [PATCH] HAX: Disable fsync if we detect the old futex2 patches.

futex_waitv() has been accepted into locking/core branch of kernel.org's
tip repo and has a fixed syscall number.

Even though the syscall number matches (449) there were changes that
result in 100% CPU utilization at all times when running with the old,
downstream version of the futex2 patches.

The new patches do not come with the sysfs entries so we can use that
for the detection.

Fixes: https://github.com/ValveSoftware/wine/pull/128
---
 dlls/ntdll/unix/fsync.c | 8 ++++++++
 server/fsync.c          | 9 +++++++++
 2 files changed, 17 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 1291f3171a1..8f07ed59ae0 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -164,6 +164,14 @@ int do_fsync(void)

     if (do_fsync_cached == -1)
     {
+        FILE *f;
+        if ((f = fopen( "/sys/kernel/futex2/wait", "r" )))
+        {
+            fclose(f);
+            do_fsync_cached = 0;
+            return do_fsync_cached;
+        }
+
         syscall( __NR_futex_waitv, NULL, 0, 0, NULL, 0 );
         do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
         if (getenv("WINEFSYNC_SPINCOUNT"))
diff --git a/server/fsync.c b/server/fsync.c
index 237e8f2b4a4..45760bc0320 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -60,6 +60,15 @@ int do_fsync(void)

     if (do_fsync_cached == -1)
     {
+        FILE *f;
+        if ((f = fopen( "/sys/kernel/futex2/wait", "r" )))
+        {
+            fclose(f);
+            do_fsync_cached = 0;
+            fprintf( stderr, "fsync: old futex2 patches detected, disabling.\n" );
+            return do_fsync_cached;
+        }
+
         syscall( __NR_futex_waitv, 0, 0, 0, 0, 0);
         do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
     }
From 3196885798787b6a52dbef0f3968f6b5e0216c56 Mon Sep 17 00:00:00 2001
From: Dmitry Skvortsov <lvb.crd@protonmail.com>
Date: Sun, 26 Dec 2021 16:32:58 +0300
Subject: [PATCH 1/2] Separate check for definition of FUTEX_32 and struct futex_waitv

---
 dlls/ntdll/unix/fsync.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 39d969f061d..c6869b62b4b 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -64,8 +64,10 @@ WINE_DEFAULT_DEBUG_CHANNEL(fsync);
 /* futex_waitv interface */

 #ifndef __NR_futex_waitv
-
 # define __NR_futex_waitv 449
+#endif
+
+#ifndef FUTEX_32
 # define FUTEX_32 2
 struct futex_waitv {
     uint64_t   val;
@@ -73,7 +75,6 @@ struct futex_waitv {
     uint32_t   flags;
     uint32_t __reserved;
 };
-
 #endif

 #define u64_to_ptr(x) (void *)(uintptr_t)(x)
--
2.34.1

From 2c15b20ad7dd57778ad2354a14dd441d1cd6cf4f Mon Sep 17 00:00:00 2001
From: Dmitry Skvortsov <lvb.crd@protonmail.com>
Date: Sun, 26 Dec 2021 16:45:21 +0300
Subject: [PATCH 2/2] Add check for linux/futex.h

---
 configure               | 6 ++++++
 configure.ac            | 1 +
 dlls/ntdll/unix/fsync.c | 3 +++
 include/config.h.in     | 3 +++
 4 files changed, 13 insertions(+)

diff --git a/configure b/configure
index ab3aa34a922..d2bcd778c59 100755
--- a/configure
+++ b/configure
@@ -8317,6 +8317,12 @@ if test "x$ac_cv_header_linux_filter_h" = xyes
 then :
   printf "%s\n" "#define HAVE_LINUX_FILTER_H 1" >>confdefs.h

+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/futex.h" "ac_cv_header_linux_futex_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_futex_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_FUTEX_H 1" >>confdefs.h
+
 fi
 ac_fn_c_check_header_compile "$LINENO" "linux/hdreg.h" "ac_cv_header_linux_hdreg_h" "$ac_includes_default"
 if test "x$ac_cv_header_linux_hdreg_h" = xyes
diff --git a/include/config.h.in b/include/config.h.in
index 9eb052c6248..910cce10693 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -200,6 +200,9 @@
 /* Define to 1 if you have the <linux/filter.h> header file. */
 #undef HAVE_LINUX_FILTER_H

+/* Define to 1 if you have the <linux/futex.h> header file. */
+#undef HAVE_LINUX_FUTEX_H
+
 /* Define if Linux-style gethostbyname_r and gethostbyaddr_r are available */
 #undef HAVE_LINUX_GETHOSTBYNAME_R_6

diff --git a/configure.ac b/configure.ac
index 3071da61b62..cfe27460a96 100644
--- a/configure.ac
+++ b/configure.ac
@@ -450,2 +450,3 @@ AC_CHECK_HEADERS(\
 	linux/filter.h \
+	linux/futex.h \
 	linux/hdreg.h \
diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index c6869b62b4b..6d69c643244 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -27,6 +27,9 @@
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
+#ifdef HAVE_LINUX_FUTEX_H
+# include <linux/futex.h>
+#endif
 #include <limits.h>
 #include <stdarg.h>
 #include <stdio.h>
--
2.34.1

From 5726c4a62f9febce68a352d1e8a99a15325fe25c Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 6 Apr 2021 19:43:48 +0300
Subject: [PATCH] ntdll: Simulate async file read and IO cancellation to
 workaround AC:Odyssey out of order dialogues bug.

CW-Bug-ID: #18881
---
 dlls/ntdll/unix/file.c   | 237 +++++++++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/loader.c |   6 +-
 2 files changed, 242 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 3f60060bb38..850c70a6b2b 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -5295,6 +5295,230 @@ static NTSTATUS set_pending_write( HANDLE device )
     return status;
 }

+static pthread_mutex_t async_file_read_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t async_file_read_cond = PTHREAD_COND_INITIALIZER;
+
+struct async_file_read_job
+{
+    HANDLE handle;
+    int unix_handle;
+    int needs_close;
+    HANDLE event;
+    IO_STATUS_BLOCK *io;
+    void *buffer;
+    ULONG length;
+    LARGE_INTEGER offset;
+    DWORD thread_id;
+    LONG  cancelled;
+    struct list queue_entry;
+    struct async_file_read_job *next;
+};
+
+
+static struct list async_file_read_queue = LIST_INIT( async_file_read_queue );
+static struct async_file_read_job *async_file_read_running, *async_file_read_free;
+
+static void async_file_complete_io( struct async_file_read_job *job, NTSTATUS status, ULONG total )
+{
+    job->io->u.Status = status;
+    job->io->Information = total;
+
+    if (job->event) NtSetEvent( job->event, NULL );
+}
+
+static void *async_file_read_thread(void *dummy)
+{
+    struct async_file_read_job *job, *ptr;
+    ULONG buffer_length = 0;
+    void *buffer = NULL;
+    struct list *entry;
+    NTSTATUS status;
+    ULONG total;
+    int result;
+
+    pthread_mutex_lock( &async_file_read_mutex );
+    while (1)
+    {
+        while (!(entry = list_head( &async_file_read_queue )))
+        {
+            pthread_cond_wait( &async_file_read_cond, &async_file_read_mutex );
+            continue;
+        }
+
+        job = LIST_ENTRY( entry, struct async_file_read_job, queue_entry );
+        list_remove( entry );
+
+        total = 0;
+
+        if ( job->cancelled )
+        {
+            pthread_mutex_unlock( &async_file_read_mutex );
+            status = STATUS_CANCELLED;
+            goto done;
+        }
+
+        job->next = async_file_read_running;
+        async_file_read_running = job;
+        pthread_mutex_unlock( &async_file_read_mutex );
+
+        if (!buffer_length)
+        {
+            buffer = malloc(job->length);
+            buffer_length = job->length;
+        }
+        else if (buffer_length < job->length)
+        {
+            buffer = realloc(buffer, job->length);
+            buffer_length = job->length;
+        }
+
+        while ((result = pread( job->unix_handle, buffer, job->length, job->offset.QuadPart )) == -1)
+        {
+            if (errno != EINTR)
+            {
+                status = errno_to_status( errno );
+                goto done;
+            }
+            if (job->cancelled)
+                break;
+        }
+
+        total = result;
+        status = (total || !job->length) ? STATUS_SUCCESS : STATUS_END_OF_FILE;
+done:
+        if (job->needs_close) close( job->unix_handle );
+
+        if (!InterlockedCompareExchange(&job->cancelled, 1, 0))
+        {
+            if (status == STATUS_SUCCESS)
+                memcpy( job->buffer, buffer, total );
+
+            async_file_complete_io( job, status, total );
+        }
+
+        pthread_mutex_lock( &async_file_read_mutex );
+
+        if (status != STATUS_CANCELLED)
+        {
+            ptr = async_file_read_running;
+            if (job == ptr)
+            {
+                async_file_read_running = job->next;
+            }
+            else
+            {
+                while (ptr && ptr->next != job)
+                    ptr = ptr->next;
+
+                assert( ptr );
+                ptr->next = job->next;
+            }
+        }
+
+        job->next = async_file_read_free;
+        async_file_read_free = job;
+    }
+
+    return NULL;
+}
+
+static pthread_once_t async_file_read_once = PTHREAD_ONCE_INIT;
+
+static void async_file_read_init(void)
+{
+    pthread_t async_file_read_thread_id;
+    pthread_attr_t pthread_attr;
+
+    ERR("HACK: AC Odyssey async read workaround.\n");
+
+    pthread_attr_init( &pthread_attr );
+    pthread_attr_setscope( &pthread_attr, PTHREAD_SCOPE_SYSTEM );
+    pthread_attr_setdetachstate( &pthread_attr, PTHREAD_CREATE_DETACHED );
+
+    pthread_create( &async_file_read_thread_id, &pthread_attr, (void * (*)(void *))async_file_read_thread, NULL);
+    pthread_attr_destroy( &pthread_attr );
+}
+
+static NTSTATUS queue_async_file_read( HANDLE handle, int unix_handle, int needs_close, HANDLE event,
+                            IO_STATUS_BLOCK *io, void *buffer, ULONG length, LARGE_INTEGER *offset )
+{
+    struct async_file_read_job *job;
+
+    pthread_once( &async_file_read_once, async_file_read_init );
+
+    NtResetEvent( event, NULL );
+
+    pthread_mutex_lock( &async_file_read_mutex );
+
+    if (async_file_read_free)
+    {
+        job = async_file_read_free;
+        async_file_read_free = async_file_read_free->next;
+    }
+    else
+    {
+        if (!(job = malloc( sizeof(*job) )))
+        {
+            pthread_mutex_unlock( &async_file_read_mutex );
+            return STATUS_NO_MEMORY;
+        }
+    }
+
+    job->handle = handle;
+    job->unix_handle = unix_handle;
+    job->needs_close = needs_close;
+    job->event = event;
+    job->io = io;
+    job->buffer = buffer;
+    job->length = length;
+    job->offset = *offset;
+    job->thread_id = GetCurrentThreadId();
+    job->cancelled = 0;
+
+    list_add_tail( &async_file_read_queue, &job->queue_entry );
+
+    pthread_cond_signal( &async_file_read_cond );
+    pthread_mutex_unlock( &async_file_read_mutex );
+
+    return STATUS_PENDING;
+}
+
+static NTSTATUS cancel_async_file_read( HANDLE handle, IO_STATUS_BLOCK *io )
+{
+    DWORD thread_id = GetCurrentThreadId();
+    struct async_file_read_job *job;
+    unsigned int count = 0;
+
+    TRACE( "handle %p, io %p.\n", handle, io );
+
+    pthread_mutex_lock( &async_file_read_mutex );
+    job = async_file_read_running;
+    while (job)
+    {
+        if (((io && job->io == io)
+                || (!io && job->handle == handle && job->thread_id == thread_id))
+                && !InterlockedCompareExchange(&job->cancelled, 1, 0))
+        {
+            async_file_complete_io( job, STATUS_CANCELLED, 0 );
+            ++count;
+        }
+        job = job->next;
+    }
+
+    LIST_FOR_EACH_ENTRY( job, &async_file_read_queue, struct async_file_read_job, queue_entry )
+    {
+        if (((io && job->io == io)
+                || (!io && job->handle == handle && job->thread_id == thread_id))
+                && !InterlockedCompareExchange(&job->cancelled, 1, 0))
+        {
+            async_file_complete_io( job, STATUS_CANCELLED, 0 );
+            ++count;
+        }
+    }
+
+    pthread_mutex_unlock( &async_file_read_mutex );
+    return count ? STATUS_SUCCESS : STATUS_NOT_FOUND;
+}

 /******************************************************************************
  *              NtReadFile   (NTDLL.@)
@@ -5336,6 +5560,13 @@ NTSTATUS WINAPI NtReadFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, vo
             goto done;
         }

+        if (ac_odyssey && async_read && length && event && !apc)
+        {
+            status = queue_async_file_read( handle, unix_handle, needs_close, event, io, buffer, length, offset );
+            needs_close = 0;
+            goto err;
+        }
+
         if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
         {
             /* async I/O doesn't make sense on regular files */
@@ -6118,6 +6349,9 @@ NTSTATUS WINAPI NtCancelIoFile( HANDLE handle, IO_STATUS_BLOCK *io_status )

     TRACE( "%p %p\n", handle, io_status );

+    if (ac_odyssey && !cancel_async_file_read( handle, NULL ))
+        return (io_status->u.Status = STATUS_SUCCESS);
+
     SERVER_START_REQ( cancel_async )
     {
         req->handle      = wine_server_obj_handle( handle );
@@ -6143,6 +6377,9 @@ NTSTATUS WINAPI NtCancelIoFileEx( HANDLE handle, IO_STATUS_BLOCK *io, IO_STATUS_

     TRACE( "%p %p %p\n", handle, io, io_status );

+    if (ac_odyssey && !cancel_async_file_read( handle, io ))
+        return (io_status->u.Status = STATUS_SUCCESS);
+
     SERVER_START_REQ( cancel_async )
     {
         req->handle = wine_server_obj_handle( handle );
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 7f3d7834a6c..0f3ec16c52f 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -2210,7 +2210,11 @@ static void hacks_init(void)

     if (!strcasecmp(cur_exe, ac_odyssey_exe))
     {
-        ERR("HACK: AC Odyssey sync tweak on.\n");
+        if (do_esync() || do_fsync())
+            ERR("HACK: AC Odyssey sync tweak on.\n");
+        else
+            ERR("Not enabling AC Odyssey sync tweak as esync and fsync are disabled.\n");
+
         ac_odyssey = TRUE;
     }
 }
From c6bad6f294f1d15a7825df71585e695f73bc8561 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 3 Nov 2021 18:07:13 +0300
Subject: [PATCH] ntdll: HACK: Enable WINESTEAMNOEXEC for Mafia II.

CW-Bug-Id: #19605
---
 dlls/ntdll/unix/loader.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 0f3ec16c52f..0a05fb3f10b 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -2201,6 +2201,7 @@ static void hacks_init(void)
     static const char ac_odyssey_exe[] = "ACOdyssey.exe";
     char cur_exe[MAX_PATH];
     DWORD cur_exe_len;
+    const char *sgi;
     int fd;

     fd = open("/proc/self/comm", O_RDONLY);
@@ -2216,7 +2217,12 @@ static void hacks_init(void)
             ERR("Not enabling AC Odyssey sync tweak as esync and fsync are disabled.\n");

         ac_odyssey = TRUE;
+        return;
     }
+
+    sgi = getenv("SteamGameId");
+    if (sgi && !strcmp(sgi, "50130"))
+        setenv("WINESTEAMNOEXEC", "1", 0);
 }

 /***********************************************************************

From 6f2c9858d6bb957b807411b28f8ffd77199eafd4 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 14 Feb 2022 22:40:40 +0300
Subject: [PATCH] fixup! esync, fsync: Yield execution before alertable wait
 for AC Odyssey.

CW-Bug-Id: #18881
---
 dlls/ntdll/unix/loader.c | 16 ++--------------
 1 file changed, 2 insertions(+), 14 deletions(-)

diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 1d4160727e4..301a11c0419 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -2241,23 +2241,11 @@ BOOL ac_odyssey;
 static void hacks_init(void)
 {
     static const char ac_odyssey_exe[] = "ACOdyssey.exe";
-    char cur_exe[MAX_PATH];
-    DWORD cur_exe_len;
     const char *sgi;
-    int fd;
-
-    fd = open("/proc/self/comm", O_RDONLY);
-    cur_exe_len = read(fd, cur_exe, sizeof(cur_exe));
-    close(fd);
-    cur_exe[cur_exe_len - 1] = 0;

-    if (!strcasecmp(cur_exe, ac_odyssey_exe))
+    if (main_argc > 1 && strstr(main_argv[1], ac_odyssey_exe))
     {
-        if (do_esync() || do_fsync())
-            ERR("HACK: AC Odyssey sync tweak on.\n");
-        else
-            ERR("Not enabling AC Odyssey sync tweak as esync and fsync are disabled.\n");
-
+        ERR("HACK: AC Odyssey sync tweak on.\n");
         ac_odyssey = TRUE;
         return;
     }
From d6a237166626d197b1d642f8f7a71900759df2b6 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 15 Feb 2022 17:20:40 +0300
Subject: [PATCH] fsync: Add WINE_FSYNC_SIMULATE_SCHED_QUANTUM config option.

And auto enable it for Uplay laucher.

CW-Bug-Id: #20155
---
 dlls/ntdll/unix/fsync.c        | 20 +++++++++++++++++++-
 dlls/ntdll/unix/loader.c       | 15 ++++++++++++---
 dlls/ntdll/unix/unix_private.h |  1 +
 3 files changed, 32 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index d468782667a..f42e30d0245 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -112,6 +112,18 @@ static inline void futex_vector_set( struct futex_waitv *waitv, int *addr, int v
     waitv->__reserved = 0;
 }

+static void simulate_sched_quantum(void)
+{
+    LARGE_INTEGER now;
+    ULONG64 wait_end;
+
+    if (!fsync_simulate_sched_quantum) return;
+
+    NtQuerySystemTime( &now );
+    wait_end = (now.QuadPart / 10 + 499) / 500;
+    usleep( wait_end * 500 - (now.QuadPart / 10) );
+}
+
 static inline int futex_wait_multiple( const struct futex_waitv *futexes,
         int count, const ULONGLONG *end )
 {
@@ -756,8 +768,8 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,

     struct futex_waitv futexes[MAXIMUM_WAIT_OBJECTS + 1];
     struct fsync *objs[MAXIMUM_WAIT_OBJECTS];
+    BOOL msgwait = FALSE, waited = FALSE;
     int has_fsync = 0, has_server = 0;
-    BOOL msgwait = FALSE;
     int dummy_futex = 0;
     unsigned int spin;
     LONGLONG timeleft;
@@ -879,6 +891,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                                     && __sync_val_compare_and_swap( &semaphore->count, current, current - 1 ) == current)
                             {
                                 TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                if (waited) simulate_sched_quantum();
                                 return i;
                             }
                             small_pause();
@@ -896,6 +909,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                         {
                             TRACE("Woken up by handle %p [%d].\n", handles[i], i);
                             mutex->count++;
+                            if (waited) simulate_sched_quantum();
                             return i;
                         }

@@ -905,6 +919,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                             {
                                 TRACE("Woken up by handle %p [%d].\n", handles[i], i);
                                 mutex->count = 1;
+                                if (waited) simulate_sched_quantum();
                                 return i;
                             }
                             else if (tid == ~0 && (tid = __sync_val_compare_and_swap( &mutex->tid, ~0, GetCurrentThreadId() )) == ~0)
@@ -932,6 +947,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                                     usleep( 0 );

                                 TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                if (waited) simulate_sched_quantum();
                                 return i;
                             }
                             small_pause();
@@ -954,6 +970,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                                     usleep( 0 );

                                 TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                if (waited) simulate_sched_quantum();
                                 return i;
                             }
                             small_pause();
@@ -1008,6 +1025,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                 TRACE("Wait timed out.\n");
                 return STATUS_TIMEOUT;
             }
+            else waited = TRUE;
         } /* while (1) */
     }
     else
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 301a11c0419..f078a967be8 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -2237,11 +2237,13 @@ static struct unix_funcs unix_funcs =
 };

 BOOL ac_odyssey;
+BOOL fsync_simulate_sched_quantum;

 static void hacks_init(void)
 {
+    static const char upc_exe[] = "Ubisoft Game Launcher\\upc.exe";
     static const char ac_odyssey_exe[] = "ACOdyssey.exe";
-    const char *sgi;
+    const char *env_str;

     if (main_argc > 1 && strstr(main_argv[1], ac_odyssey_exe))
     {
@@ -2249,9 +2251,16 @@ static void hacks_init(void)
         ac_odyssey = TRUE;
         return;
     }
+    env_str = getenv("WINE_FSYNC_SIMULATE_SCHED_QUANTUM");
+    if (env_str)
+        fsync_simulate_sched_quantum = !!atoi(env_str);
+    else if (main_argc > 1)
+        fsync_simulate_sched_quantum = !!strstr(main_argv[1], upc_exe);
+    if (fsync_simulate_sched_quantum)
+        ERR("HACK: Simulating sched quantum in fsync.\n");

-    sgi = getenv("SteamGameId");
-    if (sgi && !strcmp(sgi, "50130"))
+    env_str = getenv("SteamGameId");
+    if (env_str && !strcmp(env_str, "50130"))
         setenv("WINESTEAMNOEXEC", "1", 0);
 }

diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index d1840de8876..4bf0e7cb84e 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -148,6 +148,7 @@ extern struct ldt_copy __wine_ldt_copy DECLSPEC_HIDDEN;
 #endif

 extern BOOL ac_odyssey DECLSPEC_HIDDEN;
+extern BOOL fsync_simulate_sched_quantum DECLSPEC_HIDDEN;

 extern void init_environment( int argc, char *argv[], char *envp[] ) DECLSPEC_HIDDEN;
 extern void init_startup_info(void) DECLSPEC_HIDDEN;
From b3fb8a5543db15280952042152f5218ee994b011 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 15 Feb 2022 22:00:23 +0300
Subject: [PATCH] fixup! fsync: Add WINE_FSYNC_SIMULATE_SCHED_QUANTUM config
 option.

---
 dlls/ntdll/unix/fsync.c | 11 ++++-------
 1 file changed, 4 insertions(+), 7 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index f42e30d0245..0f19c63a5f2 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -114,14 +114,11 @@ static inline void futex_vector_set( struct futex_waitv *waitv, int *addr, int v

 static void simulate_sched_quantum(void)
 {
-    LARGE_INTEGER now;
-    ULONG64 wait_end;
-
     if (!fsync_simulate_sched_quantum) return;
-
-    NtQuerySystemTime( &now );
-    wait_end = (now.QuadPart / 10 + 499) / 500;
-    usleep( wait_end * 500 - (now.QuadPart / 10) );
+    /* futex wait is often very quick to resume a waiting thread when woken.
+     * That reveals synchonization bugs in some games which happen to work on
+     * Windows due to the waiting threads having some minimal delay to wake up. */
+    usleep(0);
 }

 static inline int futex_wait_multiple( const struct futex_waitv *futexes,
