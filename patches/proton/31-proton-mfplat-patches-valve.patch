From a7abf29970fadc9493cae9c50d25487324f5c315 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 26 Jan 2022 21:24:07 +0100
Subject: [PATCH] winegstreamer: Introduce new wg_transform struct.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
---
 dlls/winegstreamer/Makefile.in    |  1 +
 dlls/winegstreamer/gst_private.h  |  3 ++
 dlls/winegstreamer/main.c         | 14 +++++++
 dlls/winegstreamer/unix_private.h | 31 ++++++++++++++
 dlls/winegstreamer/unixlib.h      |  8 ++++
 dlls/winegstreamer/wg_parser.c    | 20 +++++++--
 dlls/winegstreamer/wg_transform.c | 69 +++++++++++++++++++++++++++++++
 dlls/winegstreamer/wma_decoder.c  | 20 +++++++++
 8 files changed, 162 insertions(+), 4 deletions(-)
 create mode 100644 dlls/winegstreamer/unix_private.h
 create mode 100644 dlls/winegstreamer/wg_transform.c

diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index c53e914e246..52295418f0f 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -13,6 +13,7 @@ C_SRCS = \
 	mfplat.c \
 	quartz_parser.c \
 	wg_parser.c \
+	wg_transform.c \
 	wm_asyncreader.c \
 	wm_reader.c \
 	wm_syncreader.c \
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 222bce3b2c7..df82b229143 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -96,6 +96,9 @@ uint64_t wg_parser_stream_get_duration(struct wg_parser_stream *stream) DECLSPEC
 void wg_parser_stream_seek(struct wg_parser_stream *stream, double rate,
         uint64_t start_pos, uint64_t stop_pos, DWORD start_flags, DWORD stop_flags) DECLSPEC_HIDDEN;

+struct wg_transform *wg_transform_create(void) DECLSPEC_HIDDEN;
+void wg_transform_destroy(struct wg_transform *transform) DECLSPEC_HIDDEN;
+
 unsigned int wg_format_get_max_size(const struct wg_format *format);

 HRESULT avi_splitter_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index 260dd208e2f..f23fa3abcdf 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -254,6 +254,20 @@ void wg_parser_stream_seek(struct wg_parser_stream *stream, double rate,
     __wine_unix_call(unix_handle, unix_wg_parser_stream_seek, &params);
 }

+struct wg_transform *wg_transform_create(void)
+{
+    struct wg_transform_create_params params = {0};
+
+    if (__wine_unix_call(unix_handle, unix_wg_transform_create, &params))
+        return NULL;
+    return params.transform;
+}
+
+void wg_transform_destroy(struct wg_transform *transform)
+{
+    __wine_unix_call(unix_handle, unix_wg_transform_destroy, transform);
+}
+
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
     if (reason == DLL_PROCESS_ATTACH)
diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
new file mode 100644
index 00000000000..375d33e7728
--- /dev/null
+++ b/dlls/winegstreamer/unix_private.h
@@ -0,0 +1,31 @@
+/*
+ * winegstreamer Unix library interface
+ *
+ * Copyright 2020-2021 Zebediah Figura for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WINEGSTREAMER_UNIX_PRIVATE_H
+#define __WINE_WINEGSTREAMER_UNIX_PRIVATE_H
+
+#include "unixlib.h"
+
+extern bool init_gstreamer(void) DECLSPEC_HIDDEN;
+
+extern NTSTATUS wg_transform_create(void *args) DECLSPEC_HIDDEN;
+extern NTSTATUS wg_transform_destroy(void *args) DECLSPEC_HIDDEN;
+
+#endif /* __WINE_WINEGSTREAMER_UNIX_PRIVATE_H */
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 82bb534b938..c8b98da3a64 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -217,6 +217,11 @@ struct wg_parser_stream_seek_params
     DWORD start_flags, stop_flags;
 };

+struct wg_transform_create_params
+{
+    struct wg_transform *transform;
+};
+
 enum unix_funcs
 {
     unix_wg_parser_create,
@@ -250,6 +255,9 @@ enum unix_funcs
     unix_wg_parser_stream_get_duration,
     unix_wg_parser_stream_get_language,
     unix_wg_parser_stream_seek,
+
+    unix_wg_transform_create,
+    unix_wg_transform_destroy,

     unix_wg_parser_stream_drain,
 };
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 013566b25e9..ac8c5a2b95c 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -37,7 +37,7 @@
 #include "winternl.h"
 #include "dshow.h"

-#include "unixlib.h"
+#include "unix_private.h"

 typedef enum
 {
@@ -51,7 +51,7 @@ typedef enum
  * debug logging instead of Wine debug logging. In order to be safe we forbid
  * any use of Wine debug logging in this entire file. */

-GST_DEBUG_CATEGORY_STATIC(wine);
+GST_DEBUG_CATEGORY(wine);
 #define GST_CAT_DEFAULT wine

 typedef BOOL (*init_gst_cb)(struct wg_parser *parser);
@@ -1963,6 +1963,16 @@ static void init_gstreamer_once(void)
             gst_version_string(), GST_VERSION_MAJOR, GST_VERSION_MINOR, GST_VERSION_MICRO);
 }

+bool init_gstreamer(void)
+{
+    static pthread_once_t init_once = PTHREAD_ONCE_INIT;
+
+    if (pthread_once(&init_once, init_gstreamer_once))
+        return false;
+
+    return true;
+}
+
 static NTSTATUS wg_parser_create(void *args)
 {
     static const init_gst_cb init_funcs[] =
@@ -1973,11 +1983,10 @@ static NTSTATUS wg_parser_create(void *args)
         [WG_PARSER_WAVPARSE] = wave_parser_init_gst,
     };

-    static pthread_once_t once = PTHREAD_ONCE_INIT;
     struct wg_parser_create_params *params = args;
     struct wg_parser *parser;

-    if (pthread_once(&once, init_gstreamer_once))
+    if (!init_gstreamer())
         return E_FAIL;

     if (!(parser = calloc(1, sizeof(*parser))))
@@ -2053,4 +2062,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     X(wg_parser_stream_get_duration),
     X(wg_parser_stream_get_language),
     X(wg_parser_stream_seek),
+
+    X(wg_transform_create),
+    X(wg_transform_destroy),

     X(wg_parser_stream_drain),
 };
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
new file mode 100644
index 00000000000..822740da0d7
--- /dev/null
+++ b/dlls/winegstreamer/wg_transform.c
@@ -0,0 +1,69 @@
+/*
+ * GStreamer transform backend
+ *
+ * Copyright 2022 RÃ©mi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdio.h>
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/audio/audio.h>
+
+#include "winternl.h"
+#include "dshow.h"
+
+#include "unix_private.h"
+
+GST_DEBUG_CATEGORY_EXTERN(wine);
+#define GST_CAT_DEFAULT wine
+
+struct wg_transform
+{
+};
+
+NTSTATUS wg_transform_destroy(void *args)
+{
+    struct wg_transform *transform = args;
+
+    free(transform);
+    return S_OK;
+}
+
+NTSTATUS wg_transform_create(void *args)
+{
+    struct wg_transform_create_params *params = args;
+    struct wg_transform *transform;
+
+    if (!init_gstreamer())
+        return E_FAIL;
+
+    if (!(transform = calloc(1, sizeof(*transform))))
+        return E_OUTOFMEMORY;
+
+    GST_INFO("Created winegstreamer transform %p.", transform);
+    params->transform = transform;
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 847387d3c22..1544e8e4c9b 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -53,6 +53,8 @@ struct wma_decoder
     LONG refcount;
     IMFMediaType *input_type;
     IMFMediaType *output_type;
+
+    struct wg_transform *wg_transform;
 };

 static inline struct wma_decoder *impl_from_IUnknown(IUnknown *iface)
@@ -56,6 +58,19 @@ static struct wma_decoder *impl_from_IMFTransform(IMFTransform *iface)
     return CONTAINING_RECORD(iface, struct wma_decoder, IMFTransform_iface);
 }

+static HRESULT try_create_wg_transform(struct wma_decoder *decoder)
+{
+    if (decoder->wg_transform)
+        wg_transform_destroy(decoder->wg_transform);
+
+    decoder->wg_transform = wg_transform_create();
+    if (decoder->wg_transform)
+        return S_OK;
+
+    WARN("Failed to create wg_transform.\n");
+    return E_FAIL;
+}
+
 static HRESULT WINAPI wma_decoder_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
 {
     struct wma_decoder *decoder = impl_from_IMFTransform(iface);
@@ -104,6 +119,8 @@ static ULONG WINAPI unknown_Release(IUnknown *iface)

     if (!refcount)
     {
+        if (decoder->wg_transform)
+            wg_transform_destroy(decoder->wg_transform);
         if (decoder->input_type)
             IMFMediaType_Release(decoder->input_type);
         if (decoder->output_type)
@@ -438,6 +455,9 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
     if (FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *)decoder->output_type)))
         goto failed;

+    if (FAILED(hr = try_create_wg_transform(decoder)))
+        goto failed;
+
     return S_OK;

 failed:
From 182c97dcfd8f52da51b5e59c661b6d9ed408b5f0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 14:02:52 +0100
Subject: [PATCH] winegstreamer: Introduce new wg_encoded_format struct.

And use it for decoder transform input types.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
---
 dlls/winegstreamer/gst_private.h |  1 +
 dlls/winegstreamer/mfplat.c      | 84 ++++++++++++++++++++++++++++++++
 dlls/winegstreamer/unixlib.h     | 25 ++++++++++
 dlls/winegstreamer/wma_decoder.c | 12 +++++
 4 files changed, 122 insertions(+)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index df82b229143..cec52e976ec 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -120,6 +120,7 @@ extern HRESULT mfplat_DllRegisterServer(void) DECLSPEC_HIDDEN;

 IMFMediaType *mf_media_type_from_wg_format(const struct wg_format *format) DECLSPEC_HIDDEN;
 void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format) DECLSPEC_HIDDEN;
+void mf_media_type_to_wg_encoded_format(IMFMediaType *type, struct wg_encoded_format *format) DECLSPEC_HIDDEN;

 HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj) DECLSPEC_HIDDEN;

diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index a111bbe196d..61c7fe28a63 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -760,3 +760,87 @@ void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
     else
         FIXME("Unrecognized major type %s.\n", debugstr_guid(&major_type));
 }
+
+static void mf_media_type_to_wg_encoded_format_wma(IMFMediaType *type, struct wg_encoded_format *format,
+        UINT32 version)
+{
+    UINT32 rate, depth, channels, block_align, bytes_per_second, codec_data_len;
+    BYTE codec_data[64];
+
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &rate)))
+    {
+        FIXME("Sample rate is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_NUM_CHANNELS, &channels)))
+    {
+        FIXME("Channel count is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_align)))
+    {
+        FIXME("Block alignment is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &depth)))
+    {
+        FIXME("Depth is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetBlob(type, &MF_MT_USER_DATA, codec_data, sizeof(codec_data), &codec_data_len)))
+    {
+        FIXME("Codec data is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &bytes_per_second)))
+    {
+        FIXME("Bitrate is not set.\n");
+        bytes_per_second = 0;
+    }
+
+    format->encoded_type = WG_ENCODED_TYPE_WMA;
+    format->u.xwma.version = version;
+    format->u.xwma.bitrate = bytes_per_second * 8;
+    format->u.xwma.rate = rate;
+    format->u.xwma.depth = depth;
+    format->u.xwma.channels = channels;
+    format->u.xwma.block_align = block_align;
+    format->u.xwma.codec_data_len = codec_data_len;
+    memcpy(format->u.xwma.codec_data, codec_data, codec_data_len);
+}
+
+void mf_media_type_to_wg_encoded_format(IMFMediaType *type, struct wg_encoded_format *format)
+{
+    GUID major_type, subtype;
+
+    memset(format, 0, sizeof(*format));
+
+    if (FAILED(IMFMediaType_GetMajorType(type, &major_type)))
+    {
+        FIXME("Major type is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+    {
+        FIXME("Subtype is not set.\n");
+        return;
+    }
+
+    if (IsEqualGUID(&major_type, &MFMediaType_Audio))
+    {
+        if (IsEqualGUID(&subtype, &MEDIASUBTYPE_MSAUDIO1))
+            mf_media_type_to_wg_encoded_format_wma(type, format, 1);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV8))
+            mf_media_type_to_wg_encoded_format_wma(type, format, 2);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV9))
+            mf_media_type_to_wg_encoded_format_wma(type, format, 3);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_WMAudio_Lossless))
+            mf_media_type_to_wg_encoded_format_wma(type, format, 4);
+        else
+            FIXME("Unimplemented audio subtype %s.\n", debugstr_guid(&subtype));
+    }
+    else
+    {
+        FIXME("Unimplemented major type %s.\n", debugstr_guid(&major_type));
+    }
+}
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index c8b98da3a64..ea46de4cce1 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -91,6 +91,31 @@ struct wg_format
     } u;
 };

+struct wg_encoded_format
+{
+    enum wg_encoded_type
+    {
+        WG_ENCODED_TYPE_UNKNOWN,
+        WG_ENCODED_TYPE_WMA,
+        WG_ENCODED_TYPE_XMA,
+    } encoded_type;
+
+    union
+    {
+        struct
+        {
+            uint32_t version;
+            uint32_t bitrate;
+            uint32_t rate;
+            uint32_t depth;
+            uint32_t channels;
+            uint32_t block_align;
+            uint32_t codec_data_len;
+            unsigned char codec_data[64];
+        } xwma;
+    } u;
+};
+
 enum wg_parser_event_type
 {
     WG_PARSER_EVENT_NONE = 0,
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 1544e8e4c9b..2b543426524 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -64,8 +64,20 @@ static inline struct wma_decoder *impl_from_IUnknown(IUnknown *iface)

 static HRESULT try_create_wg_transform(struct wma_decoder *decoder)
 {
+    struct wg_encoded_format input_format;
+    struct wg_format output_format;
+
     if (decoder->wg_transform)
         wg_transform_destroy(decoder->wg_transform);
+    decoder->wg_transform = NULL;
+
+    mf_media_type_to_wg_encoded_format(decoder->input_type, &input_format);
+    if (input_format.encoded_type == WG_ENCODED_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    mf_media_type_to_wg_format(decoder->output_type, &output_format);
+    if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;

     decoder->wg_transform = wg_transform_create();
     if (decoder->wg_transform)
From 4d41b5a70a95a76f1c4863f4bd1cbab7ca2cc9cb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 14:22:59 +0100
Subject: [PATCH] winegstreamer: Create static pads on wg_transform struct.

With caps created from the input / output formats.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
---
 dlls/winegstreamer/gst_private.h  |  3 +-
 dlls/winegstreamer/main.c         |  9 ++-
 dlls/winegstreamer/unix_private.h |  1 +
 dlls/winegstreamer/unixlib.h      |  2 +
 dlls/winegstreamer/wg_parser.c    |  2 +-
 dlls/winegstreamer/wg_transform.c | 93 +++++++++++++++++++++++++++++++
 dlls/winegstreamer/wma_decoder.c  |  2 +-
 7 files changed, 107 insertions(+), 5 deletions(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index cec52e976ec..5d198f57dc7 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -96,7 +96,8 @@ uint64_t wg_parser_stream_get_duration(struct wg_parser_stream *stream) DECLSPEC
 void wg_parser_stream_seek(struct wg_parser_stream *stream, double rate,
         uint64_t start_pos, uint64_t stop_pos, DWORD start_flags, DWORD stop_flags) DECLSPEC_HIDDEN;

-struct wg_transform *wg_transform_create(void) DECLSPEC_HIDDEN;
+struct wg_transform *wg_transform_create(const struct wg_encoded_format *input_format,
+                const struct wg_format *output_format) DECLSPEC_HIDDEN;
 void wg_transform_destroy(struct wg_transform *transform) DECLSPEC_HIDDEN;

 unsigned int wg_format_get_max_size(const struct wg_format *format);
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index f23fa3abcdf..6dfa9eb5c82 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -254,9 +254,14 @@ void wg_parser_stream_seek(struct wg_parser_stream *stream, double rate,
     __wine_unix_call(unix_handle, unix_wg_parser_stream_seek, &params);
 }

-struct wg_transform *wg_transform_create(void)
+struct wg_transform *wg_transform_create(const struct wg_encoded_format *input_format,
+        const struct wg_format *output_format)
 {
-    struct wg_transform_create_params params = {0};
+    struct wg_transform_create_params params =
+    {
+        .input_format = input_format,
+        .output_format = output_format,
+    };

     if (__wine_unix_call(unix_handle, unix_wg_transform_create, &params))
         return NULL;
diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index 375d33e7728..38349eb5e8d 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -24,6 +24,7 @@
 #include "unixlib.h"

 extern bool init_gstreamer(void) DECLSPEC_HIDDEN;
+extern GstCaps *wg_format_to_caps(const struct wg_format *format) DECLSPEC_HIDDEN;

 extern NTSTATUS wg_transform_create(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_destroy(void *args) DECLSPEC_HIDDEN;
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index ea46de4cce1..96cda2e25aa 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -245,6 +245,8 @@ struct wg_parser_stream_seek_params
 struct wg_transform_create_params
 {
     struct wg_transform *transform;
+    const struct wg_encoded_format *input_format;
+    const struct wg_format *output_format;
 };

 enum unix_funcs
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index ac8c5a2b95c..e7e80ecfddf 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -463,7 +463,7 @@ static GstCaps *wg_format_to_caps_video(const struct wg_format *format)
     return caps;
 }

-static GstCaps *wg_format_to_caps(const struct wg_format *format)
+GstCaps *wg_format_to_caps(const struct wg_format *format)
 {
     switch (format->major_type)
     {
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 822740da0d7..146cdd87ae7 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -42,12 +42,77 @@ GST_DEBUG_CATEGORY_EXTERN(wine);

 struct wg_transform
 {
+    GstPad *my_src, *my_sink;
 };

+static GstCaps *wg_format_to_caps_xwma(const struct wg_encoded_format *format)
+{
+    GstBuffer *buffer;
+    GstCaps *caps;
+
+    if (format->encoded_type == WG_ENCODED_TYPE_WMA)
+        caps = gst_caps_new_empty_simple("audio/x-wma");
+    else
+        caps = gst_caps_new_empty_simple("audio/x-xma");
+
+    if (format->u.xwma.version)
+        gst_caps_set_simple(caps, "wmaversion", G_TYPE_INT, format->u.xwma.version, NULL);
+    if (format->u.xwma.bitrate)
+        gst_caps_set_simple(caps, "bitrate", G_TYPE_INT, format->u.xwma.bitrate, NULL);
+    if (format->u.xwma.rate)
+        gst_caps_set_simple(caps, "rate", G_TYPE_INT, format->u.xwma.rate, NULL);
+    if (format->u.xwma.depth)
+        gst_caps_set_simple(caps, "depth", G_TYPE_INT, format->u.xwma.depth, NULL);
+    if (format->u.xwma.channels)
+        gst_caps_set_simple(caps, "channels", G_TYPE_INT, format->u.xwma.channels, NULL);
+    if (format->u.xwma.block_align)
+        gst_caps_set_simple(caps, "block_align", G_TYPE_INT, format->u.xwma.block_align, NULL);
+
+    if (format->u.xwma.codec_data_len)
+    {
+        buffer = gst_buffer_new_and_alloc(format->u.xwma.codec_data_len);
+        gst_buffer_fill(buffer, 0, format->u.xwma.codec_data, format->u.xwma.codec_data_len);
+        gst_caps_set_simple(caps, "codec_data", GST_TYPE_BUFFER, buffer, NULL);
+        gst_buffer_unref(buffer);
+    }
+
+    return caps;
+}
+
+static GstCaps *wg_encoded_format_to_caps(const struct wg_encoded_format *format)
+{
+    switch (format->encoded_type)
+    {
+        case WG_ENCODED_TYPE_UNKNOWN:
+            return NULL;
+        case WG_ENCODED_TYPE_WMA:
+        case WG_ENCODED_TYPE_XMA:
+            return wg_format_to_caps_xwma(format);
+    }
+    assert(0);
+    return NULL;
+}
+
+static GstFlowReturn transform_sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *buffer)
+{
+    struct wg_transform *transform = gst_pad_get_element_private(pad);
+
+    GST_INFO("transform %p, buffer %p.", transform, buffer);
+
+    gst_buffer_unref(buffer);
+
+    return GST_FLOW_OK;
+}
+
 NTSTATUS wg_transform_destroy(void *args)
 {
     struct wg_transform *transform = args;

+    if (transform->my_sink)
+        g_object_unref(transform->my_sink);
+    if (transform->my_src)
+        g_object_unref(transform->my_src);
+
     free(transform);
     return S_OK;
 }
@@ -55,7 +120,11 @@ NTSTATUS wg_transform_destroy(void *args)
 NTSTATUS wg_transform_create(void *args)
 {
     struct wg_transform_create_params *params = args;
+    struct wg_encoded_format input_format = *params->input_format;
+    struct wg_format output_format = *params->output_format;
+    GstCaps *src_caps, *sink_caps;
     struct wg_transform *transform;
+    GstPadTemplate *template;

     if (!init_gstreamer())
         return E_FAIL;
@@ -63,7 +132,31 @@ NTSTATUS wg_transform_create(void *args)
     if (!(transform = calloc(1, sizeof(*transform))))
         return E_OUTOFMEMORY;

+    src_caps = wg_encoded_format_to_caps(&input_format);
+    assert(src_caps);
+    sink_caps = wg_format_to_caps(&output_format);
+    assert(sink_caps);
+
+    template = gst_pad_template_new("src", GST_PAD_SRC, GST_PAD_ALWAYS, src_caps);
+    assert(template);
+    transform->my_src = gst_pad_new_from_template(template, "src");
+    g_object_unref(template);
+    assert(transform->my_src);
+
+    template = gst_pad_template_new("sink", GST_PAD_SINK, GST_PAD_ALWAYS, sink_caps);
+    assert(template);
+    transform->my_sink = gst_pad_new_from_template(template, "sink");
+    g_object_unref(template);
+    assert(transform->my_sink);
+
+    gst_pad_set_element_private(transform->my_sink, transform);
+    gst_pad_set_chain_function(transform->my_sink, transform_sink_chain_cb);
+
     GST_INFO("Created winegstreamer transform %p.", transform);
     params->transform = transform;
+
+    gst_caps_unref(src_caps);
+    gst_caps_unref(sink_caps);
+
     return S_OK;
 }
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 2b543426524..db6c8a677f6 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -79,7 +79,7 @@ static HRESULT try_create_wg_transform(struct wma_decoder *decoder)
     if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
         return MF_E_INVALIDMEDIATYPE;

-    decoder->wg_transform = wg_transform_create();
+    decoder->wg_transform = wg_transform_create(&input_format, &output_format);
     if (decoder->wg_transform)
         return S_OK;

From fc86c0b5360ddc02071ea5cca2b95d2c8df8309e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 14:24:27 +0100
Subject: [PATCH] winegstreamer: Lookup, create and link a decoder element.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
---
 dlls/winegstreamer/wg_transform.c | 140 +++++++++++++++++++++++++++++-
 1 file changed, 138 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 146cdd87ae7..a436d8316dd 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -42,7 +42,9 @@ GST_DEBUG_CATEGORY_EXTERN(wine);

 struct wg_transform
 {
+    GstElement *container;
     GstPad *my_src, *my_sink;
+    GstPad *their_sink, *their_src;
 };

 static GstCaps *wg_format_to_caps_xwma(const struct wg_encoded_format *format)
@@ -108,6 +110,22 @@ NTSTATUS wg_transform_destroy(void *args)
 {
     struct wg_transform *transform = args;

+    if (transform->container)
+        gst_element_set_state(transform->container, GST_STATE_NULL);
+
+    if (transform->their_src && transform->my_sink)
+        gst_pad_unlink(transform->their_src, transform->my_sink);
+    if (transform->their_sink && transform->my_src)
+        gst_pad_unlink(transform->my_src, transform->their_sink);
+
+    if (transform->their_sink)
+        g_object_unref(transform->their_sink);
+    if (transform->their_src)
+        g_object_unref(transform->their_src);
+
+    if (transform->container)
+        g_object_unref(transform->container);
+
     if (transform->my_sink)
         g_object_unref(transform->my_sink);
     if (transform->my_src)
@@ -117,14 +135,85 @@ NTSTATUS wg_transform_destroy(void *args)
     return S_OK;
 }

+static GstElement *try_create_transform(GstCaps *src_caps, GstCaps *sink_caps)
+{
+    GstElement *element = NULL;
+    GList *tmp, *transforms;
+    gchar *type;
+
+    transforms = gst_element_factory_list_get_elements(GST_ELEMENT_FACTORY_TYPE_ANY,
+            GST_RANK_MARGINAL);
+
+    tmp = gst_element_factory_list_filter(transforms, src_caps, GST_PAD_SINK, FALSE);
+    gst_plugin_feature_list_free(transforms);
+    transforms = tmp;
+
+    tmp = gst_element_factory_list_filter(transforms, sink_caps, GST_PAD_SRC, FALSE);
+    gst_plugin_feature_list_free(transforms);
+    transforms = tmp;
+
+    transforms = g_list_sort(transforms, gst_plugin_feature_rank_compare_func);
+    for (tmp = transforms; tmp != NULL && element == NULL; tmp = tmp->next)
+    {
+        type = gst_plugin_feature_get_name(GST_PLUGIN_FEATURE(tmp->data));
+        element = gst_element_factory_create(GST_ELEMENT_FACTORY(tmp->data), NULL);
+        if (!element)
+            GST_WARNING("Failed to create %s element.", type);
+    }
+    gst_plugin_feature_list_free(transforms);
+
+    if (element)
+        GST_INFO("Created %s element %p.", type, element);
+    else
+    {
+        gchar *src_str = gst_caps_to_string(src_caps), *sink_str = gst_caps_to_string(sink_caps);
+        GST_WARNING("Failed to create transform matching caps %s / %s.", src_str, sink_str);
+        g_free(sink_str);
+        g_free(src_str);
+    }
+
+    return element;
+}
+
+static bool transform_append_element(struct wg_transform *transform, GstElement *element,
+        GstElement **first, GstElement **last)
+{
+    gchar *name = gst_element_get_name(element);
+
+    if (!gst_bin_add(GST_BIN(transform->container), element))
+    {
+        GST_ERROR("Failed to add %s element to bin.", name);
+        g_free(name);
+        return false;
+    }
+
+    if (*last && !gst_element_link(*last, element))
+    {
+        GST_ERROR("Failed to link %s element.", name);
+        g_free(name);
+        return false;
+    }
+
+    GST_INFO("Created %s element %p.", name, element);
+    g_free(name);
+
+    if (!*first)
+        *first = element;
+
+    *last = element;
+    return true;
+}
+
 NTSTATUS wg_transform_create(void *args)
 {
     struct wg_transform_create_params *params = args;
     struct wg_encoded_format input_format = *params->input_format;
     struct wg_format output_format = *params->output_format;
-    GstCaps *src_caps, *sink_caps;
+    GstElement *first = NULL, *last = NULL, *element;
     struct wg_transform *transform;
+    GstCaps *src_caps, *sink_caps;
     GstPadTemplate *template;
+    int ret;

     if (!init_gstreamer())
         return E_FAIL;
@@ -137,6 +226,24 @@ NTSTATUS wg_transform_create(void *args)
     sink_caps = wg_format_to_caps(&output_format);
     assert(sink_caps);

+    transform->container = gst_bin_new("wg_transform");
+    assert(transform->container);
+
+    if (!(element = try_create_transform(src_caps, sink_caps)) ||
+            !transform_append_element(transform, element, &first, &last))
+        goto failed;
+
+    if (!(transform->their_sink = gst_element_get_static_pad(first, "sink")))
+    {
+        GST_ERROR("Failed to find target sink pad.");
+        goto failed;
+    }
+    if (!(transform->their_src = gst_element_get_static_pad(last, "src")))
+    {
+        GST_ERROR("Failed to find target src pad.");
+        goto failed;
+    }
+
     template = gst_pad_template_new("src", GST_PAD_SRC, GST_PAD_ALWAYS, src_caps);
     assert(template);
     transform->my_src = gst_pad_new_from_template(template, "src");
@@ -152,11 +259,40 @@ NTSTATUS wg_transform_create(void *args)
     gst_pad_set_element_private(transform->my_sink, transform);
     gst_pad_set_chain_function(transform->my_sink, transform_sink_chain_cb);

+    if ((ret = gst_pad_link(transform->my_src, transform->their_sink)) < 0)
+    {
+        GST_ERROR("Failed to link sink pads, error %d.", ret);
+        goto failed;
+    }
+    if ((ret = gst_pad_link(transform->their_src, transform->my_sink)) < 0)
+    {
+        GST_ERROR("Failed to link source pads, error %d.", ret);
+        goto failed;
+    }
+
+    if (!(ret = gst_pad_set_active(transform->my_sink, 1)))
+        GST_WARNING("Failed to activate my_sink.");
+    if (!(ret = gst_pad_set_active(transform->my_src, 1)))
+        GST_WARNING("Failed to activate my_src.");
+
+    gst_element_set_state(transform->container, GST_STATE_PAUSED);
+    ret = gst_element_get_state(transform->container, NULL, NULL, -1);
+    if (ret == GST_STATE_CHANGE_FAILURE)
+    {
+        GST_ERROR("Failed to play stream.\n");
+        goto failed;
+    }
+
     GST_INFO("Created winegstreamer transform %p.", transform);
     params->transform = transform;

+failed:
     gst_caps_unref(src_caps);
     gst_caps_unref(sink_caps);

-    return S_OK;
+    if (params->transform)
+        return S_OK;
+
+    wg_transform_destroy(transform);
+    return E_FAIL;
 }
From b2444dde8ad804accd68eec6af8e254c1ff6d866 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 14:25:20 +0100
Subject: [PATCH] winegstreamer: Send stream-start and caps events on creation.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
---
 dlls/winegstreamer/wg_transform.c | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index a436d8316dd..d87b8cfa2c4 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -213,6 +213,7 @@ NTSTATUS wg_transform_create(void *args)
     struct wg_transform *transform;
     GstCaps *src_caps, *sink_caps;
     GstPadTemplate *template;
+    GstSegment *segment;
     int ret;

     if (!init_gstreamer())
@@ -283,6 +284,30 @@ NTSTATUS wg_transform_create(void *args)
         goto failed;
     }

+    if (!gst_pad_push_event(transform->my_src, gst_event_new_stream_start("stream")))
+    {
+        GST_ERROR("Failed to send stream-start.");
+        goto failed;
+    }
+
+    if (!gst_pad_push_event(transform->my_src, gst_event_new_caps(src_caps)))
+    {
+        GST_ERROR("Failed to set stream caps.");
+        goto failed;
+    }
+
+    segment = gst_segment_new();
+    gst_segment_init(segment, GST_FORMAT_TIME);
+    segment->start = 0;
+    segment->stop = -1;
+    ret = gst_pad_push_event(transform->my_src, gst_event_new_segment(segment));
+    gst_segment_free(segment);
+    if (!ret)
+    {
+        GST_ERROR("Failed to start new segment.");
+        goto failed;
+    }
+
     GST_INFO("Created winegstreamer transform %p.", transform);
     params->transform = transform;


From 0254d2b54694435894b7f2d305b7863727632253 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 14:25:58 +0100
Subject: [PATCH] winegstreamer: Add an audioconverter and audioresampler
 elements.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
---
 dlls/winegstreamer/unix_private.h |  1 +
 dlls/winegstreamer/wg_parser.c    |  2 +-
 dlls/winegstreamer/wg_transform.c | 23 +++++++++++++++++++++--
 3 files changed, 23 insertions(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index 38349eb5e8d..e6b0f3636f7 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -24,6 +24,7 @@
 #include "unixlib.h"

 extern bool init_gstreamer(void) DECLSPEC_HIDDEN;
+extern GstElement *create_element(const char *name, const char *plugin_set) DECLSPEC_HIDDEN;
 extern GstCaps *wg_format_to_caps(const struct wg_format *format) DECLSPEC_HIDDEN;

 extern NTSTATUS wg_transform_create(void *args) DECLSPEC_HIDDEN;
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index e7e80ecfddf..c19ff2ab4ed 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -1092,7 +1092,7 @@ static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
     }
 }

-static GstElement *create_element(const char *name, const char *plugin_set)
+GstElement *create_element(const char *name, const char *plugin_set)
 {
     GstElement *element;

diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index d87b8cfa2c4..d96923594e2 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -210,9 +210,10 @@ NTSTATUS wg_transform_create(void *args)
     struct wg_encoded_format input_format = *params->input_format;
     struct wg_format output_format = *params->output_format;
     GstElement *first = NULL, *last = NULL, *element;
+    GstCaps *raw_caps, *src_caps, *sink_caps;
     struct wg_transform *transform;
-    GstCaps *src_caps, *sink_caps;
     GstPadTemplate *template;
+    const gchar *media_type;
     GstSegment *segment;
     int ret;

@@ -226,14 +227,31 @@ NTSTATUS wg_transform_create(void *args)
     assert(src_caps);
     sink_caps = wg_format_to_caps(&output_format);
     assert(sink_caps);
+    media_type = gst_structure_get_name(gst_caps_get_structure(sink_caps, 0));
+    raw_caps = gst_caps_new_empty_simple(media_type);
+    assert(raw_caps);

     transform->container = gst_bin_new("wg_transform");
     assert(transform->container);

-    if (!(element = try_create_transform(src_caps, sink_caps)) ||
+    if (!(element = try_create_transform(src_caps, raw_caps)) ||
             !transform_append_element(transform, element, &first, &last))
         goto failed;

+    switch (output_format.major_type)
+    {
+    case WG_MAJOR_TYPE_AUDIO:
+        if (!(element = create_element("audioconvert", "base")) ||
+                !transform_append_element(transform, element, &first, &last))
+            goto failed;
+        if (!(element = create_element("audioresample", "base")) ||
+                !transform_append_element(transform, element, &first, &last))
+            goto failed;
+        break;
+    default:
+        break;
+    }
+
     if (!(transform->their_sink = gst_element_get_static_pad(first, "sink")))
     {
         GST_ERROR("Failed to find target sink pad.");
@@ -312,6 +330,7 @@ NTSTATUS wg_transform_create(void *args)
     params->transform = transform;

 failed:
+    gst_caps_unref(raw_caps);
     gst_caps_unref(src_caps);
     gst_caps_unref(sink_caps);

From 13979069d466f0ec837c5bc57e5aff0076d8757d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 14:28:54 +0100
Subject: [PATCH] winegstreamer: Implement WMA decoder ProcessInput.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
---
 dlls/winegstreamer/gst_private.h  |  1 +
 dlls/winegstreamer/main.c         | 12 +++++++++
 dlls/winegstreamer/unix_private.h |  1 +
 dlls/winegstreamer/unixlib.h      |  9 +++++++
 dlls/winegstreamer/wg_parser.c    |  2 ++
 dlls/winegstreamer/wg_transform.c | 22 ++++++++++++++++
 dlls/winegstreamer/wma_decoder.c  | 43 +++++++++++++++++++++++++++++--
 8 files changed, 88 insertions(+), 8 deletions(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 5d198f57dc7..0fb8aee70ba 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -99,6 +99,7 @@ void wg_parser_stream_seek(struct wg_parser_stream *stream, double rate,
 struct wg_transform *wg_transform_create(const struct wg_encoded_format *input_format,
                 const struct wg_format *output_format) DECLSPEC_HIDDEN;
 void wg_transform_destroy(struct wg_transform *transform) DECLSPEC_HIDDEN;
+HRESULT wg_transform_push_data(struct wg_transform *transform, const void *data, uint32_t size) DECLSPEC_HIDDEN;

 unsigned int wg_format_get_max_size(const struct wg_format *format);

diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index 6dfa9eb5c82..b315d0ce7c1 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -273,6 +273,18 @@ void wg_transform_destroy(struct wg_transform *transform)
     __wine_unix_call(unix_handle, unix_wg_transform_destroy, transform);
 }

+HRESULT wg_transform_push_data(struct wg_transform *transform, const void *data, uint32_t size)
+{
+    struct wg_transform_push_data_params params =
+    {
+        .transform = transform,
+        .data = data,
+        .size = size,
+    };
+
+    return __wine_unix_call(unix_handle, unix_wg_transform_push_data, &params);
+}
+
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
     if (reason == DLL_PROCESS_ATTACH)
diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index e6b0f3636f7..baa7f81926c 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -29,5 +29,6 @@ extern GstCaps *wg_format_to_caps(const struct wg_format *format) DECLSPEC_HIDDE

 extern NTSTATUS wg_transform_create(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_destroy(void *args) DECLSPEC_HIDDEN;
+extern NTSTATUS wg_transform_push_data(void *args) DECLSPEC_HIDDEN;

 #endif /* __WINE_WINEGSTREAMER_UNIX_PRIVATE_H */
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 96cda2e25aa..da283196ff3 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -249,6 +249,13 @@ struct wg_transform_create_params
     const struct wg_format *output_format;
 };

+struct wg_transform_push_data_params
+{
+    struct wg_transform *transform;
+    const void *data;
+    UINT32 size;
+};
+
 enum unix_funcs
 {
     unix_wg_parser_create,
@@ -287,6 +294,8 @@ enum unix_funcs
     unix_wg_transform_destroy,

     unix_wg_parser_stream_drain,
+
+    unix_wg_transform_push_data,
 };

 #endif /* __WINE_WINEGSTREAMER_UNIXLIB_H */
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index c19ff2ab4ed..64c53c6ac98 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -2056,4 +2056,6 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     X(wg_transform_destroy),

     X(wg_parser_stream_drain),
+
+    X(wg_transform_push_data),
 };
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index d96923594e2..2137c4c8821 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -34,6 +34,7 @@

 #include "winternl.h"
 #include "dshow.h"
+#include "mferror.h"

 #include "unix_private.h"

@@ -340,3 +341,24 @@ NTSTATUS wg_transform_create(void *args)
     wg_transform_destroy(transform);
     return E_FAIL;
 }
+
+NTSTATUS wg_transform_push_data(void *args)
+{
+    struct wg_transform_push_data_params *params = args;
+    struct wg_transform *transform = params->transform;
+    GstBuffer *buffer;
+    GstFlowReturn ret;
+
+    buffer = gst_buffer_new_and_alloc(params->size);
+    gst_buffer_fill(buffer, 0, params->data, params->size);
+
+    ret = gst_pad_push(transform->my_src, buffer);
+    if (ret)
+    {
+        GST_ERROR("Failed to push buffer %d", ret);
+        return MF_E_NOTACCEPTING;
+    }
+
+    GST_INFO("Pushed %u bytes", params->size);
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index db6c8a677f6..c9472bde019 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -54,6 +54,7 @@ struct wma_decoder
     IMFMediaType *input_type;
     IMFMediaType *output_type;

+    IMFSample *input_sample;
     struct wg_transform *wg_transform;
 };

@@ -131,6 +132,8 @@ static ULONG WINAPI unknown_Release(IUnknown *iface)

     if (!refcount)
     {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
         if (decoder->wg_transform)
             wg_transform_destroy(decoder->wg_transform);
         if (decoder->input_type)
@@ -480,8 +483,44 @@ static HRESULT WINAPI wma_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAG

 static HRESULT WINAPI wma_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
-    FIXME("iface %p, id %u, sample %p, flags %#x stub!\n", iface, id, sample, flags);
-    return E_NOTIMPL;
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaBuffer *media_buffer;
+    MFT_INPUT_STREAM_INFO info;
+    UINT32 buffer_size;
+    BYTE *buffer;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, sample %p, flags %#x.\n", iface, id, sample, flags);
+
+    if (FAILED(hr = IMFTransform_GetInputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (decoder->input_sample)
+        return MF_E_NOTACCEPTING;
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_GetCurrentLength(media_buffer, &buffer_size)))
+        return hr;
+
+    if (!(buffer_size = (buffer_size / info.cbSize) * info.cbSize))
+        return S_OK;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &buffer, NULL, NULL)))
+        goto done;
+
+    if (SUCCEEDED(hr = wg_transform_push_data(decoder->wg_transform, buffer, buffer_size)))
+        IMFSample_AddRef((decoder->input_sample = sample));
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
 }

 static HRESULT WINAPI wma_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
From e12af1d2882e9291038dddee1928a53f443841f3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 14:31:44 +0100
Subject: [PATCH] winegstreamer: Implement WMA decoder ProcessOutput.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
---
 dlls/winegstreamer/gst_private.h  |  1 +
 dlls/winegstreamer/main.c         | 11 +++++
 dlls/winegstreamer/unix_private.h |  1 +
 dlls/winegstreamer/unixlib.h      | 19 ++++++++
 dlls/winegstreamer/wg_parser.c    |  1 +
 dlls/winegstreamer/wg_transform.c | 76 ++++++++++++++++++++++++++++++-
 dlls/winegstreamer/wma_decoder.c  | 59 +++++++++++++++++++++++-
 8 files changed, 169 insertions(+), 18 deletions(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 0fb8aee70ba..ead2bac4edd 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -100,6 +100,7 @@ struct wg_transform *wg_transform_create(const struct wg_encoded_format *input_f
                 const struct wg_format *output_format) DECLSPEC_HIDDEN;
 void wg_transform_destroy(struct wg_transform *transform) DECLSPEC_HIDDEN;
 HRESULT wg_transform_push_data(struct wg_transform *transform, const void *data, uint32_t size) DECLSPEC_HIDDEN;
+HRESULT wg_transform_read_data(struct wg_transform *transform, struct wg_sample *sample) DECLSPEC_HIDDEN;

 unsigned int wg_format_get_max_size(const struct wg_format *format);

diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index b315d0ce7c1..3533fd59104 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -285,6 +285,17 @@ HRESULT wg_transform_push_data(struct wg_transform *transform, const void *data,
     return __wine_unix_call(unix_handle, unix_wg_transform_push_data, &params);
 }

+HRESULT wg_transform_read_data(struct wg_transform *transform, struct wg_sample *sample)
+{
+    struct wg_transform_read_data_params params =
+    {
+        .transform = transform,
+        .sample = sample,
+    };
+
+    return __wine_unix_call(unix_handle, unix_wg_transform_read_data, &params);
+}
+
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
     if (reason == DLL_PROCESS_ATTACH)
diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index baa7f81926c..1b055436ba5 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -30,5 +30,6 @@ extern GstCaps *wg_format_to_caps(const struct wg_format *format) DECLSPEC_HIDDE
 extern NTSTATUS wg_transform_create(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_destroy(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_push_data(void *args) DECLSPEC_HIDDEN;
+extern NTSTATUS wg_transform_read_data(void *args) DECLSPEC_HIDDEN;

 #endif /* __WINE_WINEGSTREAMER_UNIX_PRIVATE_H */
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index da283196ff3..e7d80147fe5 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -256,6 +256,24 @@ struct wg_transform_push_data_params
     UINT32 size;
 };

+enum wg_sample_flags
+{
+    WG_SAMPLE_FLAG_INCOMPLETE = 1,
+};
+
+struct wg_sample
+{
+    UINT32 flags;
+    BYTE *data;
+    UINT32 size;
+};
+
+struct wg_transform_read_data_params
+{
+    struct wg_transform *transform;
+    struct wg_sample *sample;
+};
+
 enum unix_funcs
 {
     unix_wg_parser_create,
@@ -307,6 +325,7 @@ enum unix_funcs
     unix_wg_parser_stream_drain,

     unix_wg_transform_push_data,
+    unix_wg_transform_read_data,
 };

 #endif /* __WINE_WINEGSTREAMER_UNIXLIB_H */
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 64c53c6ac98..19c2c661253 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -2058,4 +2058,5 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     X(wg_parser_stream_drain),

     X(wg_transform_push_data),
+    X(wg_transform_read_data),
 };
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 2137c4c8821..1f8b35920b4 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -38,14 +38,24 @@

 #include "unix_private.h"

+#include "wine/list.h"
+
 GST_DEBUG_CATEGORY_EXTERN(wine);
 #define GST_CAT_DEFAULT wine

+struct wg_transform_sample
+{
+    struct list entry;
+    GstSample *sample;
+};
+
 struct wg_transform
 {
     GstElement *container;
     GstPad *my_src, *my_sink;
     GstPad *their_sink, *their_src;
+    pthread_mutex_t mutex;
+    struct list samples;
 };

 static GstCaps *wg_format_to_caps_xwma(const struct wg_encoded_format *format)
@@ -99,17 +109,29 @@ static GstCaps *wg_encoded_format_to_caps(const struct wg_encoded_format *format
 static GstFlowReturn transform_sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *buffer)
 {
     struct wg_transform *transform = gst_pad_get_element_private(pad);
+    struct wg_transform_sample *sample;

     GST_INFO("transform %p, buffer %p.", transform, buffer);

-    gst_buffer_unref(buffer);
+    if (!(sample = malloc(sizeof(*sample))))
+        GST_ERROR("Failed to allocate transform sample entry");
+    else
+    {
+        pthread_mutex_lock(&transform->mutex);
+        if (!(sample->sample = gst_sample_new(buffer, NULL, NULL, NULL)))
+            GST_ERROR("Failed to allocate transform sample");
+        list_add_tail(&transform->samples, &sample->entry);
+        pthread_mutex_unlock(&transform->mutex);
+    }

+    gst_buffer_unref(buffer);
     return GST_FLOW_OK;
 }

 NTSTATUS wg_transform_destroy(void *args)
 {
     struct wg_transform *transform = args;
+    struct wg_transform_sample *sample, *next;

     if (transform->container)
         gst_element_set_state(transform->container, GST_STATE_NULL);
@@ -132,6 +154,13 @@ NTSTATUS wg_transform_destroy(void *args)
     if (transform->my_src)
         g_object_unref(transform->my_src);

+    LIST_FOR_EACH_ENTRY_SAFE(sample, next, &transform->samples, struct wg_transform_sample, entry)
+    {
+        gst_sample_unref(sample->sample);
+        list_remove(&sample->entry);
+        free(sample);
+    }
+
     free(transform);
     return S_OK;
 }
@@ -224,6 +253,8 @@ NTSTATUS wg_transform_create(void *args)
     if (!(transform = calloc(1, sizeof(*transform))))
         return E_OUTOFMEMORY;

+    list_init(&transform->samples);
+
     src_caps = wg_encoded_format_to_caps(&input_format);
     assert(src_caps);
     sink_caps = wg_format_to_caps(&output_format);
@@ -362,3 +393,46 @@ NTSTATUS wg_transform_push_data(void *args)
     GST_INFO("Pushed %u bytes", params->size);
     return S_OK;
 }
+
+NTSTATUS wg_transform_read_data(void *args)
+{
+    struct wg_transform_read_data_params *params = args;
+    struct wg_transform *transform = params->transform;
+    struct wg_sample *read_sample = params->sample;
+    struct wg_transform_sample *transform_sample;
+    GstBuffer *buffer;
+    struct list *head;
+    GstMapInfo info;
+
+    pthread_mutex_lock(&transform->mutex);
+    if (!(head = list_head(&transform->samples)))
+    {
+        pthread_mutex_unlock(&transform->mutex);
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    transform_sample = LIST_ENTRY(head, struct wg_transform_sample, entry);
+    buffer = gst_sample_get_buffer(transform_sample->sample);
+
+    gst_buffer_map(buffer, &info, GST_MAP_READ);
+    if (read_sample->size > info.size)
+        read_sample->size = info.size;
+    memcpy(read_sample->data, info.data, read_sample->size);
+    gst_buffer_unmap(buffer, &info);
+
+    if (info.size > read_sample->size)
+    {
+        read_sample->flags |= WG_SAMPLE_FLAG_INCOMPLETE;
+        gst_buffer_resize(buffer, read_sample->size, -1);
+    }
+    else
+    {
+        gst_sample_unref(transform_sample->sample);
+        list_remove(&transform_sample->entry);
+        free(transform_sample);
+    }
+    pthread_mutex_unlock(&transform->mutex);
+
+    GST_INFO("Read %u bytes, flags %#x", read_sample->size, read_sample->flags);
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index c9472bde019..cac345be269 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -526,8 +526,60 @@ static HRESULT WINAPI wma_decoder_ProcessInput(IMFTransform *iface, DWORD id, IM
 static HRESULT WINAPI wma_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("iface %p, flags %#x, count %u, samples %p, status %p stub!\n", iface, flags, count, samples, status);
-    return E_NOTIMPL;
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_sample wg_sample = {0};
+    IMFMediaBuffer *media_buffer;
+    MFT_OUTPUT_STREAM_INFO info;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#x, count %u, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count > 1)
+    {
+        FIXME("Not implemented count %u\n", count);
+        return E_NOTIMPL;
+    }
+
+    if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *status = 0;
+    samples[0].dwStatus = 0;
+    if (!samples[0].pSample)
+    {
+        samples[0].dwStatus = MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE;
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &wg_sample.data, &wg_sample.size, NULL)))
+        goto done;
+
+    if (wg_sample.size < info.cbSize)
+        hr = MF_E_BUFFERTOOSMALL;
+    else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
+    {
+        if (wg_sample.flags & WG_SAMPLE_FLAG_INCOMPLETE)
+            samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_INCOMPLETE;
+    }
+    else
+    {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
+        decoder->input_sample = NULL;
+    }
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
 }

 static const IMFTransformVtbl wma_decoder_vtbl =
From 6cdb3ff4adb3495d9bec127397c277aca0e19205 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 14:32:39 +0100
Subject: [PATCH] winegstreamer: Support XMAudio2 input format in WMA decoder.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
---
 dlls/winegstreamer/mfplat.c       | 18 +++++++++++-------
 dlls/winegstreamer/wg_transform.c | 10 ++++++++--
 dlls/winegstreamer/wma_decoder.c  |  3 +++
 3 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 61c7fe28a63..55287eec5a8 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -29,6 +29,8 @@

 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);

+DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
+
 struct video_processor
 {
     IMFTransform IMFTransform_iface;
@@ -761,8 +763,8 @@ void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
         FIXME("Unrecognized major type %s.\n", debugstr_guid(&major_type));
 }

-static void mf_media_type_to_wg_encoded_format_wma(IMFMediaType *type, struct wg_encoded_format *format,
-        UINT32 version)
+static void mf_media_type_to_wg_encoded_format_xwma(IMFMediaType *type, struct wg_encoded_format *format,
+        enum wg_encoded_type encoded_type, UINT32 version)
 {
     UINT32 rate, depth, channels, block_align, bytes_per_second, codec_data_len;
     BYTE codec_data[64];
@@ -798,7 +800,7 @@ static void mf_media_type_to_wg_encoded_format_wma(IMFMediaType *type, struct wg
         bytes_per_second = 0;
     }

-    format->encoded_type = WG_ENCODED_TYPE_WMA;
+    format->encoded_type = encoded_type;
     format->u.xwma.version = version;
     format->u.xwma.bitrate = bytes_per_second * 8;
     format->u.xwma.rate = rate;
@@ -829,13 +831,15 @@ void mf_media_type_to_wg_encoded_format(IMFMediaType *type, struct wg_encoded_fo
     if (IsEqualGUID(&major_type, &MFMediaType_Audio))
     {
         if (IsEqualGUID(&subtype, &MEDIASUBTYPE_MSAUDIO1))
-            mf_media_type_to_wg_encoded_format_wma(type, format, 1);
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 1);
         else if (IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV8))
-            mf_media_type_to_wg_encoded_format_wma(type, format, 2);
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 2);
         else if (IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV9))
-            mf_media_type_to_wg_encoded_format_wma(type, format, 3);
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 3);
         else if (IsEqualGUID(&subtype, &MFAudioFormat_WMAudio_Lossless))
-            mf_media_type_to_wg_encoded_format_wma(type, format, 4);
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 4);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_XMAudio2))
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_XMA, 2);
         else
             FIXME("Unimplemented audio subtype %s.\n", debugstr_guid(&subtype));
     }
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 1f8b35920b4..256e77429a0 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -64,12 +64,18 @@ static GstCaps *wg_format_to_caps_xwma(const struct wg_encoded_format *format)
     GstCaps *caps;

     if (format->encoded_type == WG_ENCODED_TYPE_WMA)
+    {
         caps = gst_caps_new_empty_simple("audio/x-wma");
+        if (format->u.xwma.version)
+            gst_caps_set_simple(caps, "wmaversion", G_TYPE_INT, format->u.xwma.version, NULL);
+    }
     else
+    {
         caps = gst_caps_new_empty_simple("audio/x-xma");
+        if (format->u.xwma.version)
+            gst_caps_set_simple(caps, "xmaversion", G_TYPE_INT, format->u.xwma.version, NULL);
+    }

-    if (format->u.xwma.version)
-        gst_caps_set_simple(caps, "wmaversion", G_TYPE_INT, format->u.xwma.version, NULL);
     if (format->u.xwma.bitrate)
         gst_caps_set_simple(caps, "bitrate", G_TYPE_INT, format->u.xwma.bitrate, NULL);
     if (format->u.xwma.rate)
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index cac345be269..d6ae7d93a39 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -30,12 +30,15 @@

 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);

+DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
+
 static const GUID *wma_decoder_input_types[] =
 {
     &MEDIASUBTYPE_MSAUDIO1,
     &MFAudioFormat_WMAudioV8,
     &MFAudioFormat_WMAudioV9,
     &MFAudioFormat_WMAudio_Lossless,
+    &MFAudioFormat_XMAudio2,
 };
 static const GUID *wma_decoder_output_types[] =
 {

From 1beb998df6007991345072dc64e498fb47a75681 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 18 Jan 2022 13:09:07 +0100
Subject: [PATCH] winegstreamer: Introduce new H264 decoder transform stub.

As a remplacement for the previously added transform.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/Makefile.in    |   1 +
 dlls/winegstreamer/gst_private.h  |   1 +
 dlls/winegstreamer/h264_decoder.c | 279 ++++++++++++++++++++++++++++++
 dlls/winegstreamer/mfplat.c       |  27 +++
 4 files changed, 308 insertions(+)
 create mode 100644 dlls/winegstreamer/h264_decoder.c

diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index 52295418f0f..b8c61a316a0 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -10,6 +10,7 @@ C_SRCS = \
 	audioconvert.c \
 	colorconvert.c \
 	decode_transform.c \
+	h264_decoder.c \
 	main.c \
 	media_source.c \
 	mfplat.c \
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index ead2bac4edd..7a0078fe2f4 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -128,6 +128,7 @@ void mf_media_type_to_wg_encoded_format(IMFMediaType *type, struct wg_encoded_fo
 HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj) DECLSPEC_HIDDEN;

 HRESULT wma_decoder_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
+HRESULT h264_decoder_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
 HRESULT audio_converter_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
 HRESULT color_converter_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
new file mode 100644
index 00000000000..5db72c55151
--- /dev/null
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -0,0 +1,279 @@
+/* H264 Decoder Transform
+ *
+ * Copyright 2022 RÃ©mi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+#include "wmcodecdsp.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+struct h264_decoder
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+};
+
+static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct h264_decoder, IMFTransform_iface);
+}
+
+static HRESULT WINAPI h264_decoder_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IMFTransform))
+        *out = &decoder->IMFTransform_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI h264_decoder_AddRef(IMFTransform *iface)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&decoder->refcount);
+
+    TRACE("iface %p increasing refcount to %lu.\n", decoder, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI h264_decoder_Release(IMFTransform *iface)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&decoder->refcount);
+
+    TRACE("iface %p decreasing refcount to %lu.\n", decoder, refcount);
+
+    if (!refcount)
+        free(decoder);
+
+    return refcount;
+}
+
+static HRESULT WINAPI h264_decoder_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    FIXME("iface %p, input_minimum %p, input_maximum %p, output_minimum %p, output_maximum %p stub!\n",
+            iface, input_minimum, input_maximum, output_minimum, output_maximum);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    FIXME("iface %p, inputs %p, outputs %p stub!\n", iface, inputs, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    FIXME("iface %p, input_size %lu, inputs %p, output_size %lu, outputs %p stub!\n",
+            iface, input_size, inputs, output_size, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    FIXME("iface %p, id %#lx, info %p stub!\n", iface, id, info);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    FIXME("iface %p, id %#lx, info %p stub!\n", iface, id, info);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("iface %p, attributes %p stub!\n", iface, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %#lx, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %#lx, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    FIXME("iface %p, id %#lx stub!\n", iface, id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    FIXME("iface %p, streams %lu, ids %p stub!\n", iface, streams, ids);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("iface %p, id %#lx, index %#lx, type %p stub!\n", iface, id, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("iface %p, id %#lx, index %#lx, type %p stub!\n", iface, id, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("iface %p, id %#lx, type %p, flags %#lx stub!\n", iface, id, type, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("iface %p, id %#lx, type %p, flags %#lx stub!\n", iface, id, type, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %#lx, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %#lx, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("iface %p, id %#lx, flags %p stub!\n", iface, id, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("iface %p, flags %p stub!\n", iface, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("iface %p, lower %s, upper %s stub!\n", iface,
+            wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("iface %p, id %#lx, event %p stub!\n", iface, id, event);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    FIXME("iface %p, id %#lx, sample %p, flags %#lx stub!\n", iface, id, sample, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    FIXME("iface %p, flags %#lx, count %lu, samples %p, status %p stub!\n", iface, flags, count, samples, status);
+    return E_NOTIMPL;
+}
+
+static const IMFTransformVtbl h264_decoder_vtbl =
+{
+    h264_decoder_QueryInterface,
+    h264_decoder_AddRef,
+    h264_decoder_Release,
+    h264_decoder_GetStreamLimits,
+    h264_decoder_GetStreamCount,
+    h264_decoder_GetStreamIDs,
+    h264_decoder_GetInputStreamInfo,
+    h264_decoder_GetOutputStreamInfo,
+    h264_decoder_GetAttributes,
+    h264_decoder_GetInputStreamAttributes,
+    h264_decoder_GetOutputStreamAttributes,
+    h264_decoder_DeleteInputStream,
+    h264_decoder_AddInputStreams,
+    h264_decoder_GetInputAvailableType,
+    h264_decoder_GetOutputAvailableType,
+    h264_decoder_SetInputType,
+    h264_decoder_SetOutputType,
+    h264_decoder_GetInputCurrentType,
+    h264_decoder_GetOutputCurrentType,
+    h264_decoder_GetInputStatus,
+    h264_decoder_GetOutputStatus,
+    h264_decoder_SetOutputBounds,
+    h264_decoder_ProcessEvent,
+    h264_decoder_ProcessMessage,
+    h264_decoder_ProcessInput,
+    h264_decoder_ProcessOutput,
+};
+
+HRESULT h264_decoder_create(REFIID riid, void **ret)
+{
+    struct h264_decoder *decoder;
+
+    TRACE("riid %s, ret %p.\n", debugstr_guid(riid), ret);
+
+    if (!(decoder = calloc(1, sizeof(*decoder))))
+        return E_OUTOFMEMORY;
+
+    decoder->IMFTransform_iface.lpVtbl = &h264_decoder_vtbl;
+    decoder->refcount = 1;
+
+    *ret = &decoder->IMFTransform_iface;
+    TRACE("Created decoder %p\n", *ret);
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index e1d7a52cc99..6bdf700d5ba 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -401,11 +401,6 @@ static const GUID CLSID_GStreamerByteStreamHandler = {0x317df618, 0x5e5a, 0x468a

 static const GUID CLSID_WINEAudioConverter = {0x6a170414,0xaad9,0x4693,{0xb8,0x06,0x3a,0x0c,0x47,0xc5,0x70,0xd6}};

-static HRESULT h264_decoder_create(REFIID riid, void **ret)
-{
-    return decode_transform_create(riid, ret, DECODER_TYPE_H264);
-}
-
 static HRESULT aac_decoder_create(REFIID riid, void **ret)
 {
     return decode_transform_create(riid, ret, DECODER_TYPE_AAC);
@@ -566,7 +561,7 @@ mfts[] =
         color_converter_supported_types,
     },
     {
-        &CLSID_MSAACDecMFT,
+        &CLSID_MSH264DecoderMFT,
         &MFT_CATEGORY_VIDEO_DECODER,
         h264_decoderW,
         MFT_ENUM_FLAG_SYNCMFT,
From d4187ea663f81ccd58e4a9ed671bc2731cdea6c7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 18 Jan 2022 13:33:36 +0100
Subject: [PATCH] winegstreamer: Return S_OK from H264 decoder GetAttributes.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 5db72c55151..f46d6d77f8e 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -120,7 +120,8 @@ static HRESULT WINAPI h264_decoder_GetOutputStreamInfo(IMFTransform *iface, DWOR
 static HRESULT WINAPI h264_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
 {
     FIXME("iface %p, attributes %p stub!\n", iface, attributes);
-    return E_NOTIMPL;
+
+    return MFCreateAttributes(attributes, 0);
 }

 static HRESULT WINAPI h264_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
From a13f8c564234866ae0365c695eee5b01c0ecc302 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 18 Jan 2022 13:33:36 +0100
Subject: [PATCH] winegstreamer: Return S_OK from H264 decoder ProcessMessage.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index f46d6d77f8e..55f40ad7660 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -216,7 +216,7 @@ static HRESULT WINAPI h264_decoder_ProcessEvent(IMFTransform *iface, DWORD id, I
 static HRESULT WINAPI h264_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
     FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
-    return E_NOTIMPL;
+    return S_OK;
 }

 static HRESULT WINAPI h264_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
From aef0b019c04fd73c735f54b34f74fec5d15ec5d2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 10 Feb 2022 09:54:51 +0100
Subject: [PATCH] winegstreamer: Implement H264 decoder SetInputType.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 37 +++++++++++++++++++++++++++++--
 1 file changed, 35 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 55f40ad7660..e0634bedcaa 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -30,10 +30,16 @@

 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);

+static const GUID *h264_decoder_input_types[] =
+{
+    &MFVideoFormat_H264,
+};
+
 struct h264_decoder
 {
     IMFTransform IMFTransform_iface;
     LONG refcount;
+    IMFMediaType *input_type;
 };

 static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
@@ -78,7 +84,11 @@ static ULONG WINAPI h264_decoder_Release(IMFTransform *iface)
     TRACE("iface %p decreasing refcount to %lu.\n", decoder, refcount);

     if (!refcount)
+    {
+        if (decoder->input_type)
+            IMFMediaType_Release(decoder->input_type);
         free(decoder);
+    }

     return refcount;
 }
@@ -166,8 +176,31 @@ static HRESULT WINAPI h264_decoder_GetOutputAvailableType(IMFTransform *iface, D

 static HRESULT WINAPI h264_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    FIXME("iface %p, id %#lx, type %p, flags %#lx stub!\n", iface, id, type, flags);
-    return E_NOTIMPL;
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    GUID major, subtype;
+    HRESULT hr;
+    ULONG i;
+
+    TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+        FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return E_INVALIDARG;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Video))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(h264_decoder_input_types); ++i)
+        if (IsEqualGUID(&subtype, h264_decoder_input_types[i]))
+            break;
+    if (i == ARRAY_SIZE(h264_decoder_input_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (decoder->input_type)
+        IMFMediaType_Release(decoder->input_type);
+    IMFMediaType_AddRef((decoder->input_type = type));
+
+    return S_OK;
 }

 static HRESULT WINAPI h264_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
From d9b859997b6fc2d5d7348205fc2e511c328a9873 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 10 Feb 2022 09:55:30 +0100
Subject: [PATCH] winegstreamer: Implement H264 decoder GetOutputAvailableType.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 141 +++++++++++++++++++++++++++++-
 1 file changed, 138 insertions(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index e0634bedcaa..78bf317c36f 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -34,6 +34,14 @@ static const GUID *h264_decoder_input_types[] =
 {
     &MFVideoFormat_H264,
 };
+static const GUID *h264_decoder_output_types[] =
+{
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_YV12,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_YUY2,
+};

 struct h264_decoder
 {
@@ -47,6 +55,103 @@ static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
     return CONTAINING_RECORD(iface, struct h264_decoder, IMFTransform_iface);
 }

+static HRESULT fill_output_media_type(IMFMediaType *media_type, IMFMediaType *default_type)
+{
+    UINT32 value, width, height;
+    UINT64 value64;
+    GUID subtype;
+    HRESULT hr;
+
+    if (FAILED(hr = IMFMediaType_GetGUID(media_type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &value64)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_FRAME_SIZE, &value64)))
+            value64 = (UINT64)1920 << 32 | 1080;
+        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_SIZE, value64)))
+            return hr;
+    }
+    width = value64 >> 32;
+    height = value64;
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_FRAME_RATE, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_FRAME_RATE, &value64)))
+            value64 = (UINT64)30000 << 32 | 1001;
+        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_RATE, value64)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_PIXEL_ASPECT_RATIO, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_PIXEL_ASPECT_RATIO, &value64)))
+            value64 = (UINT64)1 << 32 | 1;
+        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_PIXEL_ASPECT_RATIO, value64)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_SAMPLE_SIZE, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_SAMPLE_SIZE, &value)))
+        {
+            if (IsEqualGUID(&subtype, &MFVideoFormat_YUY2))
+                value = width * height * 2;
+            else
+                value = width * height * 3 / 2;
+        }
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_SAMPLE_SIZE, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_DEFAULT_STRIDE, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_DEFAULT_STRIDE, &value)))
+        {
+            if (IsEqualGUID(&subtype, &MFVideoFormat_YUY2))
+                value = width * 2;
+            else
+                value = width;
+        }
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_DEFAULT_STRIDE, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_INTERLACE_MODE, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_INTERLACE_MODE, &value)))
+            value = MFVideoInterlace_MixedInterlaceOrProgressive;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_INTERLACE_MODE, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, &value)))
+            value = 1;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_VIDEO_ROTATION, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_VIDEO_ROTATION, &value)))
+            value = 0;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_VIDEO_ROTATION, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_FIXED_SIZE_SAMPLES, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_FIXED_SIZE_SAMPLES, &value)))
+            value = 1;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_FIXED_SIZE_SAMPLES, value)))
+            return hr;
+    }
+
+    return S_OK;
+}
+
 static HRESULT WINAPI h264_decoder_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
@@ -170,8 +275,38 @@ static HRESULT WINAPI h264_decoder_GetInputAvailableType(IMFTransform *iface, DW
 static HRESULT WINAPI h264_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("iface %p, id %#lx, index %#lx, type %p stub!\n", iface, id, index, type);
-    return E_NOTIMPL;
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaType *media_type;
+    const GUID *output_type;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, index %#lx, type %p.\n", iface, id, index, type);
+
+    if (!decoder->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *type = NULL;
+
+    if (index >= ARRAY_SIZE(h264_decoder_output_types))
+        return MF_E_NO_MORE_TYPES;
+    output_type = h264_decoder_output_types[index];
+
+    if (FAILED(hr = MFCreateMediaType(&media_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, output_type)))
+        goto done;
+
+    hr = fill_output_media_type(media_type, NULL);
+
+done:
+    if (SUCCEEDED(hr))
+        IMFMediaType_AddRef((*type = media_type));
+
+    IMFMediaType_Release(media_type);
+    return hr;
 }

 static HRESULT WINAPI h264_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
@@ -184,7 +319,7 @@ static HRESULT WINAPI h264_decoder_SetInputType(IMFTransform *iface, DWORD id, I
     TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);

     if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
-        FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+            FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
         return E_INVALIDARG;

     if (!IsEqualGUID(&major, &MFMediaType_Video))
From 2ce8f6c136202c16eb903220a2730942b00ae52c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 10 Feb 2022 09:55:46 +0100
Subject: [PATCH] winegstreamer: Implement H264 decoder GetInputAvailableType.

Required by Shadow Warrior 2.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 23 +++++++++++++++++++++--
 1 file changed, 21 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 78bf317c36f..7aca79e7a86 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -268,8 +268,27 @@ static HRESULT WINAPI h264_decoder_AddInputStreams(IMFTransform *iface, DWORD st
 static HRESULT WINAPI h264_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("iface %p, id %#lx, index %#lx, type %p stub!\n", iface, id, index, type);
-    return E_NOTIMPL;
+    IMFMediaType *media_type;
+    const GUID *subtype;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, index %#lx, type %p.\n", iface, id, index, type);
+
+    *type = NULL;
+
+    if (index >= ARRAY_SIZE(h264_decoder_input_types))
+        return MF_E_NO_MORE_TYPES;
+    subtype = h264_decoder_input_types[index];
+
+    if (FAILED(hr = MFCreateMediaType(&media_type)))
+        return hr;
+
+    if (SUCCEEDED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)) &&
+            SUCCEEDED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, subtype)))
+        IMFMediaType_AddRef((*type = media_type));
+
+    IMFMediaType_Release(media_type);
+    return hr;
 }

 static HRESULT WINAPI h264_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
From 14706e4f94cb61177826ac8970e796fc1f572fb4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 10 Feb 2022 09:56:08 +0100
Subject: [PATCH] winegstreamer: Implement H264 decoder SetOutputType.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 39 +++++++++++++++++++++++++++++--
 1 file changed, 37 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 7aca79e7a86..2cfc1ac0d05 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -48,6 +48,7 @@ struct h264_decoder
     IMFTransform IMFTransform_iface;
     LONG refcount;
     IMFMediaType *input_type;
+    IMFMediaType *output_type;
 };

 static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
@@ -192,6 +193,8 @@ static ULONG WINAPI h264_decoder_Release(IMFTransform *iface)
     {
         if (decoder->input_type)
             IMFMediaType_Release(decoder->input_type);
+        if (decoder->output_type)
+            IMFMediaType_Release(decoder->output_type);
         free(decoder);
     }

@@ -350,6 +353,12 @@ static HRESULT WINAPI h264_decoder_SetInputType(IMFTransform *iface, DWORD id, I
     if (i == ARRAY_SIZE(h264_decoder_input_types))
         return MF_E_INVALIDMEDIATYPE;

+    if (decoder->output_type)
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+
     if (decoder->input_type)
         IMFMediaType_Release(decoder->input_type);
     IMFMediaType_AddRef((decoder->input_type = type));
@@ -359,8 +368,34 @@ static HRESULT WINAPI h264_decoder_SetInputType(IMFTransform *iface, DWORD id, I

 static HRESULT WINAPI h264_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    FIXME("iface %p, id %#lx, type %p, flags %#lx stub!\n", iface, id, type, flags);
-    return E_NOTIMPL;
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    GUID major, subtype;
+    HRESULT hr;
+    ULONG i;
+
+    TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);
+
+    if (!decoder->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+            FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Video))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(h264_decoder_output_types); ++i)
+        if (IsEqualGUID(&subtype, h264_decoder_output_types[i]))
+            break;
+    if (i == ARRAY_SIZE(h264_decoder_output_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (decoder->output_type)
+        IMFMediaType_Release(decoder->output_type);
+    IMFMediaType_AddRef((decoder->output_type = type));
+
+    return S_OK;
 }

 static HRESULT WINAPI h264_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
From da890b23a3504ee9afca1a12a4c29680f33eb458 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 10 Feb 2022 09:56:23 +0100
Subject: [PATCH] winegstreamer: Implement H264 decoder GetInputStreamInfo.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 2cfc1ac0d05..1ccb5f39908 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -225,8 +225,20 @@ static HRESULT WINAPI h264_decoder_GetStreamIDs(IMFTransform *iface, DWORD input

 static HRESULT WINAPI h264_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
 {
-    FIXME("iface %p, id %#lx, info %p stub!\n", iface, id, info);
-    return E_NOTIMPL;
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, id %#lx, info %p.\n", iface, id, info);
+
+    if (!decoder->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    info->hnsMaxLatency = 0;
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER | MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE;
+    info->cbSize = 0x1000;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+
+    return S_OK;
 }

 static HRESULT WINAPI h264_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
From 62f0f599b09103652c63d0f1d73eb8ac875ff440 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 10 Feb 2022 09:56:35 +0100
Subject: [PATCH] winegstreamer: Implement H264 decoder GetOutputStreamInfo.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 21 +++++++++++++++++++--
 1 file changed, 19 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 1ccb5f39908..eadb28cdaaa 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -243,8 +243,25 @@ static HRESULT WINAPI h264_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD

 static HRESULT WINAPI h264_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
 {
-    FIXME("iface %p, id %#lx, info %p stub!\n", iface, id, info);
-    return E_NOTIMPL;
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaType *media_type;
+    UINT32 sample_size;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, info %p.\n", iface, id, info);
+
+    if (!decoder->input_type || !decoder->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    media_type = decoder->output_type;
+
+    info->dwFlags = MFT_OUTPUT_STREAM_WHOLE_SAMPLES | MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER | MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE;
+    if (FAILED(hr = IMFMediaType_GetUINT32(media_type, &MF_MT_SAMPLE_SIZE, &sample_size)))
+        sample_size = 1920 * 1080 * 2;
+    info->cbSize = sample_size;
+    info->cbAlignment = 0;
+
+    return S_OK;
 }

 static HRESULT WINAPI h264_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
From 24312f557589df704155d6870e5e680df87b11ca Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 14:33:39 +0100
Subject: [PATCH] winegstreamer: Add H264 encoded format support in
 wg_transform.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 36 +++++++++++++++++-
 dlls/winegstreamer/mfplat.c       | 37 ++++++++++++++++++
 dlls/winegstreamer/unixlib.h      |  8 ++++
 dlls/winegstreamer/wg_transform.c | 63 +++++++++++++++++++++++++++++++
 4 files changed, 143 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index eadb28cdaaa..b7de097fc7d 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -49,6 +49,8 @@ struct h264_decoder
     LONG refcount;
     IMFMediaType *input_type;
     IMFMediaType *output_type;
+
+    struct wg_transform *wg_transform;
 };

 static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
@@ -56,6 +58,30 @@ static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
     return CONTAINING_RECORD(iface, struct h264_decoder, IMFTransform_iface);
 }

+static HRESULT try_create_wg_transform(struct h264_decoder *decoder)
+{
+    struct wg_encoded_format input_format;
+    struct wg_format output_format;
+
+    if (decoder->wg_transform)
+        wg_transform_destroy(decoder->wg_transform);
+
+    mf_media_type_to_wg_encoded_format(decoder->input_type, &input_format);
+    if (input_format.encoded_type == WG_ENCODED_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    mf_media_type_to_wg_format(decoder->output_type, &output_format);
+    if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    decoder->wg_transform = wg_transform_create(&input_format, &output_format);
+    if (decoder->wg_transform)
+        return S_OK;
+
+    WARN("Failed to create H264 wg_transform.\n");
+    return E_FAIL;
+}
+
 static HRESULT fill_output_media_type(IMFMediaType *media_type, IMFMediaType *default_type)
 {
     UINT32 value, width, height;
@@ -191,6 +217,8 @@ static ULONG WINAPI h264_decoder_Release(IMFTransform *iface)

     if (!refcount)
     {
+        if (decoder->wg_transform)
+            wg_transform_destroy(decoder->wg_transform);
         if (decoder->input_type)
             IMFMediaType_Release(decoder->input_type);
         if (decoder->output_type)
@@ -424,7 +452,13 @@ static HRESULT WINAPI h264_decoder_SetOutputType(IMFTransform *iface, DWORD id,
         IMFMediaType_Release(decoder->output_type);
     IMFMediaType_AddRef((decoder->output_type = type));

-    return S_OK;
+    if (FAILED(hr = try_create_wg_transform(decoder)))
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+
+    return hr;
 }

 static HRESULT WINAPI h264_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 67c11ce75d7..4ff174a2083 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -838,6 +838,36 @@ static void mf_media_type_to_wg_encoded_format_xwma(IMFMediaType *type, struct w
     memcpy(format->u.xwma.codec_data, codec_data, codec_data_len);
 }

+static void mf_media_type_to_wg_encoded_format_h264(IMFMediaType *type, struct wg_encoded_format *format)
+{
+    UINT64 frame_rate, frame_size;
+    UINT32 profile, level;
+
+    format->encoded_type = WG_ENCODED_TYPE_H264;
+    format->u.h264.width = 0;
+    format->u.h264.height = 0;
+    format->u.h264.fps_n = 1;
+    format->u.h264.fps_d = 1;
+
+    if (SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &frame_size)))
+    {
+        format->u.h264.width = (UINT32)(frame_size >> 32);
+        format->u.h264.height = (UINT32)frame_size;
+    }
+
+    if (SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_RATE, &frame_rate)) && (UINT32)frame_rate)
+    {
+        format->u.h264.fps_n = (UINT32)(frame_rate >> 32);
+        format->u.h264.fps_d = (UINT32)frame_rate;
+    }
+
+    if (SUCCEEDED(IMFMediaType_GetUINT32(type, &MF_MT_MPEG2_PROFILE, &profile)))
+        format->u.h264.profile = profile;
+
+    if (SUCCEEDED(IMFMediaType_GetUINT32(type, &MF_MT_MPEG2_LEVEL, &level)))
+        format->u.h264.level = level;
+}
+
 void mf_media_type_to_wg_encoded_format(IMFMediaType *type, struct wg_encoded_format *format)
 {
     GUID major_type, subtype;
@@ -870,6 +900,13 @@ void mf_media_type_to_wg_encoded_format(IMFMediaType *type, struct wg_encoded_fo
         else
             FIXME("Unimplemented audio subtype %s.\n", debugstr_guid(&subtype));
     }
+    else if (IsEqualGUID(&major_type, &MFMediaType_Video))
+    {
+        if (IsEqualGUID(&subtype, &MFVideoFormat_H264))
+            mf_media_type_to_wg_encoded_format_h264(type, format);
+        else
+            FIXME("Unimplemented audio subtype %s.\n", debugstr_guid(&subtype));
+    }
     else
     {
         FIXME("Unimplemented major type %s.\n", debugstr_guid(&major_type));
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index e7d80147fe5..7892e2813fc 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -98,6 +98,7 @@ struct wg_encoded_format
         WG_ENCODED_TYPE_UNKNOWN,
         WG_ENCODED_TYPE_WMA,
         WG_ENCODED_TYPE_XMA,
+        WG_ENCODED_TYPE_H264,
     } encoded_type;

     union
@@ -113,6 +114,13 @@ struct wg_encoded_format
             uint32_t codec_data_len;
             unsigned char codec_data[64];
         } xwma;
+        struct
+        {
+            int32_t width, height;
+            uint32_t fps_n, fps_d;
+            uint32_t profile;
+            uint32_t level;
+        } h264;
     } u;
 };

diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 256e77429a0..2956ddf753b 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -98,6 +98,64 @@ static GstCaps *wg_format_to_caps_xwma(const struct wg_encoded_format *format)
     return caps;
 }

+static GstCaps *wg_format_to_caps_h264(const struct wg_encoded_format *format)
+{
+    const char *profile, *level;
+    GstCaps *caps;
+
+    caps = gst_caps_new_empty_simple("video/x-h264");
+    gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, "byte-stream", NULL);
+    gst_caps_set_simple(caps, "alignment", G_TYPE_STRING, "au", NULL);
+
+    if (format->u.h264.width)
+        gst_caps_set_simple(caps, "width", G_TYPE_INT, format->u.h264.width, NULL);
+    if (format->u.h264.height)
+        gst_caps_set_simple(caps, "height", G_TYPE_INT, format->u.h264.height, NULL);
+    if (format->u.h264.fps_n || format->u.h264.fps_d)
+        gst_caps_set_simple(caps, "framerate", GST_TYPE_FRACTION, format->u.h264.fps_n, format->u.h264.fps_d, NULL);
+
+    switch (format->u.h264.profile)
+    {
+        case /* eAVEncH264VProfile_Main */ 77:  profile = "main"; break;
+        case /* eAVEncH264VProfile_High */ 100: profile = "high"; break;
+        case /* eAVEncH264VProfile_444 */  244: profile = "high-4:4:4"; break;
+        default:
+            GST_ERROR("Unrecognized H.264 profile attribute %u.", format->u.h264.profile);
+            /* fallthrough */
+        case 0: profile = NULL;
+    }
+    if (profile)
+        gst_caps_set_simple(caps, "profile", G_TYPE_STRING, profile, NULL);
+
+    switch (format->u.h264.level)
+    {
+        case /* eAVEncH264VLevel1 */   10: level = "1";   break;
+        case /* eAVEncH264VLevel1_1 */ 11: level = "1.1"; break;
+        case /* eAVEncH264VLevel1_2 */ 12: level = "1.2"; break;
+        case /* eAVEncH264VLevel1_3 */ 13: level = "1.3"; break;
+        case /* eAVEncH264VLevel2 */   20: level = "2";   break;
+        case /* eAVEncH264VLevel2_1 */ 21: level = "2.1"; break;
+        case /* eAVEncH264VLevel2_2 */ 22: level = "2.2"; break;
+        case /* eAVEncH264VLevel3 */   30: level = "3";   break;
+        case /* eAVEncH264VLevel3_1 */ 31: level = "3.1"; break;
+        case /* eAVEncH264VLevel3_2 */ 32: level = "3.2"; break;
+        case /* eAVEncH264VLevel4 */   40: level = "4";   break;
+        case /* eAVEncH264VLevel4_1 */ 41: level = "4.1"; break;
+        case /* eAVEncH264VLevel4_2 */ 42: level = "4.2"; break;
+        case /* eAVEncH264VLevel5 */   50: level = "5";   break;
+        case /* eAVEncH264VLevel5_1 */ 51: level = "5.1"; break;
+        case /* eAVEncH264VLevel5_2 */ 52: level = "5.2"; break;
+        default:
+            GST_ERROR("Unrecognized H.264 level attribute %u.", format->u.h264.level);
+            /* fallthrough */
+        case 0: level = NULL;
+    }
+    if (level)
+        gst_caps_set_simple(caps, "level", G_TYPE_STRING, level, NULL);
+
+    return caps;
+}
+
 static GstCaps *wg_encoded_format_to_caps(const struct wg_encoded_format *format)
 {
     switch (format->encoded_type)
@@ -107,6 +165,8 @@ static GstCaps *wg_encoded_format_to_caps(const struct wg_encoded_format *format
         case WG_ENCODED_TYPE_WMA:
         case WG_ENCODED_TYPE_XMA:
             return wg_format_to_caps_xwma(format);
+        case WG_ENCODED_TYPE_H264:
+            return wg_format_to_caps_h264(format);
     }
     assert(0);
     return NULL;
@@ -286,7 +346,10 @@ NTSTATUS wg_transform_create(void *args)
                 !transform_append_element(transform, element, &first, &last))
             goto failed;
         break;
+    case WG_MAJOR_TYPE_VIDEO:
+        break;
     default:
+        assert(0);
         break;
     }

From 5a8875b0c253f433a3c381a6ad342ef48b0d9a6b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 10 Feb 2022 09:56:47 +0100
Subject: [PATCH] winegstreamer: Implement H264 decoder ProcessInput.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 30 ++++++++++++++++++++++++++++--
 1 file changed, 28 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index b7de097fc7d..268262a0f18 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -506,8 +506,34 @@ static HRESULT WINAPI h264_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSA

 static HRESULT WINAPI h264_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
-    FIXME("iface %p, id %#lx, sample %p, flags %#lx stub!\n", iface, id, sample, flags);
-    return E_NOTIMPL;
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaBuffer *media_buffer;
+    MFT_INPUT_STREAM_INFO info;
+    DWORD buffer_size;
+    BYTE *buffer;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, sample %p, flags %#lx.\n", iface, id, sample, flags);
+
+    if (FAILED(hr = IMFTransform_GetInputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &buffer, NULL, &buffer_size)))
+        goto done;
+
+    hr = wg_transform_push_data(decoder->wg_transform, buffer, buffer_size);
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
 }

 static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
From e6a374bd7eba342a3501477e774ea7e58dd7f58f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 10 Feb 2022 09:57:10 +0100
Subject: [PATCH] winegstreamer: Implement H264 decoder ProcessOutput.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 50 +++++++++++++++++++++++++++++--
 1 file changed, 48 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 268262a0f18..44d55ae061f 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -539,8 +539,54 @@ static HRESULT WINAPI h264_decoder_ProcessInput(IMFTransform *iface, DWORD id, I
 static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("iface %p, flags %#lx, count %lu, samples %p, status %p stub!\n", iface, flags, count, samples, status);
-    return E_NOTIMPL;
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_sample wg_sample = {0};
+    IMFMediaBuffer *media_buffer;
+    MFT_OUTPUT_STREAM_INFO info;
+    DWORD buffer_size;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#lx, count %lu, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count > 1)
+    {
+        FIXME("Not implemented count %lu\n", count);
+        return E_NOTIMPL;
+    }
+
+    if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *status = 0;
+    samples[0].dwStatus = 0;
+    if (!samples[0].pSample)
+    {
+        samples[0].dwStatus = MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE;
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &wg_sample.data, &buffer_size, NULL)))
+        goto done;
+    wg_sample.size = buffer_size;
+
+    if (wg_sample.size < info.cbSize)
+        hr = MF_E_BUFFERTOOSMALL;
+    else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
+        hr = IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    if (FAILED(hr))
+        IMFMediaBuffer_SetCurrentLength(media_buffer, 0);
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
 }

 static const IMFTransformVtbl h264_decoder_vtbl =
From 1f577e3a9cdff29b907ee9bbf999427146c7a0b2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 14:34:12 +0100
Subject: [PATCH] winegstreamer: Add timestamps and duration to H264 decoded
 samples.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c |  6 ++++++
 dlls/winegstreamer/unixlib.h      |  4 ++++
 dlls/winegstreamer/wg_transform.c | 11 +++++++++++
 3 files changed, 21 insertions(+)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 44d55ae061f..69e747f1dc0 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -578,7 +578,13 @@ static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flag
     if (wg_sample.size < info.cbSize)
         hr = MF_E_BUFFERTOOSMALL;
     else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
+    {
+        if (wg_sample.flags & WG_SAMPLE_FLAG_HAS_PTS)
+            IMFSample_SetSampleTime(samples[0].pSample, wg_sample.pts);
+        if (wg_sample.flags & WG_SAMPLE_FLAG_HAS_DURATION)
+            IMFSample_SetSampleDuration(samples[0].pSample, wg_sample.duration);
         hr = IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
+    }

     IMFMediaBuffer_Unlock(media_buffer);

diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 7892e2813fc..5890780c64c 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -267,6 +267,8 @@ struct wg_transform_push_data_params
 enum wg_sample_flags
 {
     WG_SAMPLE_FLAG_INCOMPLETE = 1,
+    WG_SAMPLE_FLAG_HAS_PTS = 2,
+    WG_SAMPLE_FLAG_HAS_DURATION = 4,
 };

 struct wg_sample
@@ -274,6 +276,8 @@ struct wg_sample
     UINT32 flags;
     BYTE *data;
     UINT32 size;
+    /* pts and duration are in 100-nanosecond units. */
+    ULONGLONG pts, duration;
 };

 struct wg_transform_read_data_params
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 2956ddf753b..93e777ba39a 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -489,6 +489,17 @@ NTSTATUS wg_transform_read_data(void *args)
     memcpy(read_sample->data, info.data, read_sample->size);
     gst_buffer_unmap(buffer, &info);

+    if (buffer->pts != GST_CLOCK_TIME_NONE)
+    {
+        read_sample->flags |= WG_SAMPLE_FLAG_HAS_PTS;
+        read_sample->pts = buffer->pts / 100;
+    }
+    if (buffer->duration != GST_CLOCK_TIME_NONE)
+    {
+        read_sample->flags |= WG_SAMPLE_FLAG_HAS_DURATION;
+        read_sample->duration = buffer->duration / 100;
+    }
+
     if (info.size > read_sample->size)
     {
         read_sample->flags |= WG_SAMPLE_FLAG_INCOMPLETE;
From 5519610d889b79df7109ab8fe0c0002de9d78eeb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 10 Feb 2022 09:57:36 +0100
Subject: [PATCH] winegstreamer: Support dynamic wg_transform video format
 change.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 26 ++++++++++++-
 dlls/winegstreamer/unix_private.h |  2 +
 dlls/winegstreamer/unixlib.h      |  1 +
 dlls/winegstreamer/wg_parser.c    |  4 +-
 dlls/winegstreamer/wg_transform.c | 61 ++++++++++++++++++++++++++++++-
 5 files changed, 89 insertions(+), 5 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 69e747f1dc0..219790128da 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -51,6 +51,7 @@ struct h264_decoder
     IMFMediaType *output_type;

     struct wg_transform *wg_transform;
+    struct wg_format wg_format;
 };

 static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
@@ -378,7 +379,7 @@ static HRESULT WINAPI h264_decoder_GetOutputAvailableType(IMFTransform *iface, D
     if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, output_type)))
         goto done;

-    hr = fill_output_media_type(media_type, NULL);
+    hr = fill_output_media_type(media_type, decoder->output_type);

 done:
     if (SUCCEEDED(hr))
@@ -427,6 +428,7 @@ static HRESULT WINAPI h264_decoder_SetOutputType(IMFTransform *iface, DWORD id,
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
     GUID major, subtype;
+    BOOL identical;
     HRESULT hr;
     ULONG i;

@@ -449,7 +451,13 @@ static HRESULT WINAPI h264_decoder_SetOutputType(IMFTransform *iface, DWORD id,
         return MF_E_INVALIDMEDIATYPE;

     if (decoder->output_type)
+    {
+        if (SUCCEEDED(hr = IMFMediaType_Compare(decoder->output_type, (IMFAttributes *)type,
+                MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &identical)) && identical)
+            return S_OK;
         IMFMediaType_Release(decoder->output_type);
+    }
+
     IMFMediaType_AddRef((decoder->output_type = type));

     if (FAILED(hr = try_create_wg_transform(decoder)))
@@ -543,6 +551,7 @@ static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flag
     struct wg_sample wg_sample = {0};
     IMFMediaBuffer *media_buffer;
     MFT_OUTPUT_STREAM_INFO info;
+    IMFMediaType *media_type;
     DWORD buffer_size;
     HRESULT hr;

@@ -575,6 +584,7 @@ static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flag
         goto done;
     wg_sample.size = buffer_size;

+    wg_sample.format = &decoder->wg_format;
     if (wg_sample.size < info.cbSize)
         hr = MF_E_BUFFERTOOSMALL;
     else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
@@ -585,6 +595,20 @@ static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flag
             IMFSample_SetSampleDuration(samples[0].pSample, wg_sample.duration);
         hr = IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
     }
+    else if (hr == MF_E_TRANSFORM_STREAM_CHANGE)
+    {
+        media_type = mf_media_type_from_wg_format(&decoder->wg_format);
+        IMFMediaType_SetUINT32(media_type, &MF_MT_SAMPLE_SIZE, wg_sample.size);
+        IMFMediaType_DeleteItem(media_type, &MF_MT_FRAME_RATE);
+        IMFMediaType_DeleteItem(decoder->output_type, &MF_MT_DEFAULT_STRIDE);
+        fill_output_media_type(media_type, decoder->output_type);
+
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = media_type;
+
+        samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+        *status |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+    }

     IMFMediaBuffer_Unlock(media_buffer);

diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index 1b055436ba5..88566ab1db5 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -26,6 +26,8 @@
 extern bool init_gstreamer(void) DECLSPEC_HIDDEN;
 extern GstElement *create_element(const char *name, const char *plugin_set) DECLSPEC_HIDDEN;
 extern GstCaps *wg_format_to_caps(const struct wg_format *format) DECLSPEC_HIDDEN;
+extern void wg_format_from_caps(struct wg_format *format, const GstCaps *caps) DECLSPEC_HIDDEN;
+extern bool wg_format_compare(const struct wg_format *a, const struct wg_format *b) DECLSPEC_HIDDEN;

 extern NTSTATUS wg_transform_create(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_destroy(void *args) DECLSPEC_HIDDEN;
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 5890780c64c..2e9625fed4e 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -278,6 +278,7 @@ struct wg_sample
     UINT32 size;
     /* pts and duration are in 100-nanosecond units. */
     ULONGLONG pts, duration;
+    struct wg_format *format;
 };

 struct wg_transform_read_data_params
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 19c2c661253..9e1fc5d1357 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -308,7 +308,7 @@ static void wg_format_from_caps_video_cinepak(struct wg_format *format, const Gs
     format->u.video.fps_d = fps_d;
 }

-static void wg_format_from_caps(struct wg_format *format, const GstCaps *caps)
+void wg_format_from_caps(struct wg_format *format, const GstCaps *caps)
 {
     const GstStructure *structure = gst_caps_get_structure(caps, 0);
     const char *name = gst_structure_get_name(structure);
@@ -478,7 +478,7 @@ GstCaps *wg_format_to_caps(const struct wg_format *format)
     return NULL;
 }

-static bool wg_format_compare(const struct wg_format *a, const struct wg_format *b)
+bool wg_format_compare(const struct wg_format *a, const struct wg_format *b)
 {
     if (a->major_type != b->major_type)
         return false;
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 93e777ba39a..df37b4e8543 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -56,6 +56,7 @@ struct wg_transform
     GstPad *their_sink, *their_src;
     pthread_mutex_t mutex;
     struct list samples;
+    GstCaps *sink_caps;
 };

 static GstCaps *wg_format_to_caps_xwma(const struct wg_encoded_format *format)
@@ -184,7 +185,7 @@ static GstFlowReturn transform_sink_chain_cb(GstPad *pad, GstObject *parent, Gst
     else
     {
         pthread_mutex_lock(&transform->mutex);
-        if (!(sample->sample = gst_sample_new(buffer, NULL, NULL, NULL)))
+        if (!(sample->sample = gst_sample_new(buffer, transform->sink_caps, NULL, NULL)))
             GST_ERROR("Failed to allocate transform sample");
         list_add_tail(&transform->samples, &sample->entry);
         pthread_mutex_unlock(&transform->mutex);
@@ -194,6 +195,38 @@ static GstFlowReturn transform_sink_chain_cb(GstPad *pad, GstObject *parent, Gst
     return GST_FLOW_OK;
 }

+static gboolean transform_sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    struct wg_transform *transform = gst_pad_get_element_private(pad);
+
+    GST_INFO("transform %p, type \"%s\".", transform, GST_EVENT_TYPE_NAME(event));
+
+    switch (event->type)
+    {
+    case GST_EVENT_CAPS:
+    {
+        GstCaps *caps;
+        gchar *str;
+
+        gst_event_parse_caps(event, &caps);
+        str = gst_caps_to_string(caps);
+        GST_WARNING("Got caps \"%s\".", str);
+        g_free(str);
+
+        pthread_mutex_lock(&transform->mutex);
+        gst_caps_unref(transform->sink_caps);
+        transform->sink_caps = gst_caps_ref(caps);
+        pthread_mutex_unlock(&transform->mutex);
+        break;
+    }
+    default:
+        GST_WARNING("Ignoring \"%s\" event.", GST_EVENT_TYPE_NAME(event));
+    }
+
+    gst_event_unref(event);
+    return TRUE;
+}
+
 NTSTATUS wg_transform_destroy(void *args)
 {
     struct wg_transform *transform = args;
@@ -311,7 +344,7 @@ NTSTATUS wg_transform_create(void *args)
     GstPadTemplate *template;
     const gchar *media_type;
     GstSegment *segment;
-    int ret;
+    int i, ret;

     if (!init_gstreamer())
         return E_FAIL;
@@ -329,6 +362,7 @@ NTSTATUS wg_transform_create(void *args)
     raw_caps = gst_caps_new_empty_simple(media_type);
     assert(raw_caps);

+    transform->sink_caps = gst_caps_copy(sink_caps);
     transform->container = gst_bin_new("wg_transform");
     assert(transform->container);

@@ -347,6 +381,12 @@ NTSTATUS wg_transform_create(void *args)
             goto failed;
         break;
     case WG_MAJOR_TYPE_VIDEO:
+        if (!(element = create_element("videoconvert", "base")) ||
+                !transform_append_element(transform, element, &first, &last))
+            goto failed;
+        for (i = 0; i < gst_caps_get_size(sink_caps); ++i)
+            gst_structure_remove_fields(gst_caps_get_structure(sink_caps, i),
+                    "width", "height", NULL);
         break;
     default:
         assert(0);
@@ -377,6 +417,7 @@ NTSTATUS wg_transform_create(void *args)
     assert(transform->my_sink);

     gst_pad_set_element_private(transform->my_sink, transform);
+    gst_pad_set_event_function(transform->my_sink, transform_sink_event_cb);
     gst_pad_set_chain_function(transform->my_sink, transform_sink_chain_cb);

     if ((ret = gst_pad_link(transform->my_src, transform->their_sink)) < 0)
@@ -469,9 +510,11 @@ NTSTATUS wg_transform_read_data(void *args)
     struct wg_transform *transform = params->transform;
     struct wg_sample *read_sample = params->sample;
     struct wg_transform_sample *transform_sample;
+    struct wg_format buffer_format;
     GstBuffer *buffer;
     struct list *head;
     GstMapInfo info;
+    GstCaps *caps;

     pthread_mutex_lock(&transform->mutex);
     if (!(head = list_head(&transform->samples)))
@@ -483,6 +526,20 @@ NTSTATUS wg_transform_read_data(void *args)
     transform_sample = LIST_ENTRY(head, struct wg_transform_sample, entry);
     buffer = gst_sample_get_buffer(transform_sample->sample);

+    if (read_sample->format)
+    {
+        if (!(caps = gst_sample_get_caps(transform_sample->sample)))
+            caps = transform->sink_caps;
+        wg_format_from_caps(&buffer_format, caps);
+        if (!wg_format_compare(read_sample->format, &buffer_format))
+        {
+            *read_sample->format = buffer_format;
+            read_sample->size = gst_buffer_get_size(buffer);
+            pthread_mutex_unlock(&transform->mutex);
+            return MF_E_TRANSFORM_STREAM_CHANGE;
+        }
+    }
+
     gst_buffer_map(buffer, &info, GST_MAP_READ);
     if (read_sample->size > info.size)
         read_sample->size = info.size;
From 653649989217881800aa20f66f209ef4825e2d38 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 10 Feb 2022 09:58:20 +0100
Subject: [PATCH] winegstreamer: Fixup H264 decoder NV12 plane alignment.

To match what native does. Many games that use the H264 decoder directly
rely on this as they hardcode various aspects of the alignment in their
logic (and each game a different one).

Note: There may be a way to have it done by GStreamer, as libav natively
decode H264 into aligned planes, but somehow and somewhere in the chain
the planes are re-aligned.

Hard Reset Redux crashes if MF_MT_MINIMUM_DISPLAY_APERTURE attribute is
set (and it doesn't need it as its videos are 720p).

For: Call of Duty III, Shadow Warrior 2.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 40 +++++++++++++++++++++++++++++++
 1 file changed, 40 insertions(+)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 219790128da..66ecfad84de 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -86,6 +86,7 @@ static HRESULT try_create_wg_transform(struct h264_decoder *decoder)
 static HRESULT fill_output_media_type(IMFMediaType *media_type, IMFMediaType *default_type)
 {
     UINT32 value, width, height;
+    MFVideoArea aperture = {0};
     UINT64 value64;
     GUID subtype;
     HRESULT hr;
@@ -177,6 +178,17 @@ static HRESULT fill_output_media_type(IMFMediaType *media_type, IMFMediaType *de
             return hr;
     }

+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE, NULL)))
+    {
+        if (default_type && SUCCEEDED(hr = IMFMediaType_GetBlob(default_type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
+                (BYTE *)&aperture, sizeof(aperture), NULL)))
+        {
+            if (FAILED(hr = IMFMediaType_SetBlob(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
+                    (BYTE *)&aperture, sizeof(aperture))))
+                return hr;
+        }
+    }
+
     return S_OK;
 }

@@ -551,7 +563,9 @@ static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flag
     struct wg_sample wg_sample = {0};
     IMFMediaBuffer *media_buffer;
     MFT_OUTPUT_STREAM_INFO info;
+    MFVideoArea aperture = {0};
     IMFMediaType *media_type;
+    UINT32 align, offset;
     DWORD buffer_size;
     HRESULT hr;

@@ -593,6 +607,17 @@ static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flag
             IMFSample_SetSampleTime(samples[0].pSample, wg_sample.pts);
         if (wg_sample.flags & WG_SAMPLE_FLAG_HAS_DURATION)
             IMFSample_SetSampleDuration(samples[0].pSample, wg_sample.duration);
+
+        if (decoder->wg_format.u.video.format == WG_VIDEO_FORMAT_NV12 &&
+                (align = decoder->wg_format.u.video.height & 15))
+        {
+            offset = decoder->wg_format.u.video.width * decoder->wg_format.u.video.height;
+            align = (16 - align) * decoder->wg_format.u.video.width;
+            memmove(wg_sample.data + offset + align, wg_sample.data + offset,
+                    wg_sample.size - offset);
+            wg_sample.size += align;
+        }
+
         hr = IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
     }
     else if (hr == MF_E_TRANSFORM_STREAM_CHANGE)
@@ -603,6 +628,21 @@ static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flag
         IMFMediaType_DeleteItem(decoder->output_type, &MF_MT_DEFAULT_STRIDE);
         fill_output_media_type(media_type, decoder->output_type);

+        if (decoder->wg_format.u.video.format == WG_VIDEO_FORMAT_NV12 &&
+                (align = decoder->wg_format.u.video.height & 15))
+        {
+            aperture.Area.cx = decoder->wg_format.u.video.width;
+            aperture.Area.cy = decoder->wg_format.u.video.height;
+            IMFMediaType_SetBlob(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
+                    (BYTE *)&aperture, sizeof(aperture));
+
+            aperture.Area.cy += 16 - align;
+            IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_SIZE,
+                    (UINT64)aperture.Area.cx << 32 | aperture.Area.cy);
+            IMFMediaType_SetUINT32(media_type, &MF_MT_SAMPLE_SIZE,
+                    aperture.Area.cx * aperture.Area.cy * 3 / 2);
+        }
+
         IMFMediaType_Release(decoder->output_type);
         decoder->output_type = media_type;

From 3f86ff74c2a8a82913bbb35d9ee4f90eca855976 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 21:46:08 +0100
Subject: [PATCH] winegstreamer: Use an optional h264parse wg_transform
 element.

Required for Mortal Kombat 11.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/wg_transform.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index df37b4e8543..e3b7d8ed056 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -366,6 +366,17 @@ NTSTATUS wg_transform_create(void *args)
     transform->container = gst_bin_new("wg_transform");
     assert(transform->container);

+    switch (input_format.encoded_type)
+    {
+    case WG_ENCODED_TYPE_H264:
+        if ((element = create_element("h264parse", "base")) &&
+                !transform_append_element(transform, element, &first, &last))
+            goto failed;
+        break;
+    default:
+        break;
+    }
+
     if (!(element = try_create_transform(src_caps, raw_caps)) ||
             !transform_append_element(transform, element, &first, &last))
         goto failed;
From bc56611bc058a0b6bd6c517d35055d5e78826b29 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 10 Feb 2022 09:58:32 +0100
Subject: [PATCH] HACK: winegstreamer: Fake H264 timestamps if framerate cannot
 be trusted.

Fixes MK11 video framerate.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 12 ++++++++++++
 dlls/winegstreamer/wg_transform.c | 10 ++++++++--
 2 files changed, 20 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 66ecfad84de..ba6e681890b 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -52,6 +52,7 @@ struct h264_decoder

     struct wg_transform *wg_transform;
     struct wg_format wg_format;
+    ULONGLONG last_pts;
 };

 static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
@@ -75,6 +76,7 @@ static HRESULT try_create_wg_transform(struct h264_decoder *decoder)
     if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
         return MF_E_INVALIDMEDIATYPE;

+    decoder->last_pts = 0;
     decoder->wg_transform = wg_transform_create(&input_format, &output_format);
     if (decoder->wg_transform)
         return S_OK;
@@ -567,6 +569,7 @@ static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flag
     IMFMediaType *media_type;
     UINT32 align, offset;
     DWORD buffer_size;
+    UINT64 framerate;
     HRESULT hr;

     TRACE("iface %p, flags %#lx, count %lu, samples %p, status %p.\n", iface, flags, count, samples, status);
@@ -603,6 +606,15 @@ static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flag
         hr = MF_E_BUFFERTOOSMALL;
     else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
     {
+        if (!(wg_sample.flags & (WG_SAMPLE_FLAG_HAS_PTS|WG_SAMPLE_FLAG_HAS_DURATION)))
+        {
+            IMFMediaType_GetUINT64(decoder->output_type, &MF_MT_FRAME_RATE, &framerate);
+            wg_sample.pts = decoder->last_pts;
+            wg_sample.duration = (UINT64)10000000 * (UINT32)framerate / (framerate >> 32);
+            wg_sample.flags |= (WG_SAMPLE_FLAG_HAS_PTS|WG_SAMPLE_FLAG_HAS_DURATION);
+            decoder->last_pts += wg_sample.duration;
+        }
+
         if (wg_sample.flags & WG_SAMPLE_FLAG_HAS_PTS)
             IMFSample_SetSampleTime(samples[0].pSample, wg_sample.pts);
         if (wg_sample.flags & WG_SAMPLE_FLAG_HAS_DURATION)
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index e3b7d8ed056..1c9dc6f72bb 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -522,6 +522,7 @@ NTSTATUS wg_transform_read_data(void *args)
     struct wg_sample *read_sample = params->sample;
     struct wg_transform_sample *transform_sample;
     struct wg_format buffer_format;
+    bool broken_timestamp = false;
     GstBuffer *buffer;
     struct list *head;
     GstMapInfo info;
@@ -549,6 +550,11 @@ NTSTATUS wg_transform_read_data(void *args)
             pthread_mutex_unlock(&transform->mutex);
             return MF_E_TRANSFORM_STREAM_CHANGE;
         }
+
+        if (buffer_format.major_type == WG_MAJOR_TYPE_VIDEO
+                && buffer_format.u.video.fps_n <= 1
+                && buffer_format.u.video.fps_d <= 1)
+            broken_timestamp = true;
     }

     gst_buffer_map(buffer, &info, GST_MAP_READ);
@@ -557,12 +563,12 @@ NTSTATUS wg_transform_read_data(void *args)
     memcpy(read_sample->data, info.data, read_sample->size);
     gst_buffer_unmap(buffer, &info);

-    if (buffer->pts != GST_CLOCK_TIME_NONE)
+    if (buffer->pts != GST_CLOCK_TIME_NONE && !broken_timestamp)
     {
         read_sample->flags |= WG_SAMPLE_FLAG_HAS_PTS;
         read_sample->pts = buffer->pts / 100;
     }
-    if (buffer->duration != GST_CLOCK_TIME_NONE)
+    if (buffer->duration != GST_CLOCK_TIME_NONE && !broken_timestamp)
     {
         read_sample->flags |= WG_SAMPLE_FLAG_HAS_DURATION;
         read_sample->duration = buffer->duration / 100;
From 700febaaa6cfa82a10625bc48e780d365aa2f006 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 8 Feb 2022 11:21:39 +0100
Subject: [PATCH] winegstreamer: Reset internal format on BEGIN_STREAMING
 message.

In order to regenerate a MF_E_TRANSFORM_STREAM_CHANGE status on next
successful ProcessOutput. CoD: Black Ops 3 depends on this, or crashes
if MF_E_TRANSFORM_STREAM_CHANGE isn't returned when the campaign intro
video begins to play.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index ba6e681890b..ede0bd36bce 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -522,7 +522,19 @@ static HRESULT WINAPI h264_decoder_ProcessEvent(IMFTransform *iface, DWORD id, I

 static HRESULT WINAPI h264_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+
     FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
+
+    switch (message)
+    {
+    case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
+        memset(&decoder->wg_format, 0, sizeof(decoder->wg_format));
+        break;
+    default:
+        break;
+    }
+
     return S_OK;
 }

From 36f27ef3ce2e9226724eaa4e31843ae436897217 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 14:36:32 +0100
Subject: [PATCH] winegstreamer: Reimplement AAC decoder using wg_transform.

For Call of Duty III, possibly others. This will need to be split.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
CW-Bug-Id: #19362
---
 dlls/winegstreamer/Makefile.in    |   1 +
 dlls/winegstreamer/aac_decoder.c  | 622 ++++++++++++++++++++++++++++++
 dlls/winegstreamer/gst_private.h  |   1 +
 dlls/winegstreamer/mfplat.c       |  73 ++++
 dlls/winegstreamer/unixlib.h      |   8 +
 dlls/winegstreamer/wg_transform.c |  48 +++
 6 files changed, 753 insertions(+)
 create mode 100644 dlls/winegstreamer/aac_decoder.c

diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index b8c61a316a0..71d741519f2 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -7,6 +7,7 @@ EXTRAINCL = $(GSTREAMER_CFLAGS)
 EXTRALIBS = $(GSTREAMER_LIBS) $(PTHREAD_LIBS)

 C_SRCS = \
+	aac_decoder.c \
 	audioconvert.c \
 	h264_decoder.c \
 	main.c \
diff --git a/dlls/winegstreamer/aac_decoder.c b/dlls/winegstreamer/aac_decoder.c
new file mode 100644
index 00000000000..3b3383a52ab
--- /dev/null
+++ b/dlls/winegstreamer/aac_decoder.c
@@ -0,0 +1,622 @@
+/* AAC Decoder Transform
+ *
+ * Copyright 2022 RÃ©mi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+#include "wmcodecdsp.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+static const GUID *aac_decoder_input_types[] =
+{
+    &MFAudioFormat_AAC,
+};
+static const GUID *aac_decoder_output_types[] =
+{
+    &MFAudioFormat_PCM,
+    &MFAudioFormat_Float,
+};
+
+struct aac_decoder
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+    IMFMediaType *input_type;
+    IMFMediaType *output_type;
+
+    IMFSample *input_sample;
+    struct wg_transform *wg_transform;
+};
+
+static struct aac_decoder *impl_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct aac_decoder, IMFTransform_iface);
+}
+
+static void try_create_wg_transform(struct aac_decoder *decoder)
+{
+    struct wg_encoded_format input_format;
+    struct wg_format output_format;
+
+    if (!decoder->input_type || !decoder->output_type)
+        return;
+
+    if (decoder->wg_transform)
+        wg_transform_destroy(decoder->wg_transform);
+
+    mf_media_type_to_wg_encoded_format(decoder->input_type, &input_format);
+    if (input_format.encoded_type == WG_ENCODED_TYPE_UNKNOWN)
+        return;
+
+    mf_media_type_to_wg_format(decoder->output_type, &output_format);
+    if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return;
+
+    decoder->wg_transform = wg_transform_create(&input_format, &output_format);
+    if (!decoder->wg_transform)
+        WARN("Failed to create wg_transform.\n");
+}
+
+static HRESULT WINAPI aac_decoder_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IMFTransform))
+        *out = &decoder->IMFTransform_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI aac_decoder_AddRef(IMFTransform *iface)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&decoder->refcount);
+
+    TRACE("iface %p increasing refcount to %u.\n", decoder, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI aac_decoder_Release(IMFTransform *iface)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&decoder->refcount);
+
+    TRACE("iface %p decreasing refcount to %u.\n", decoder, refcount);
+
+    if (!refcount)
+    {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
+        if (decoder->wg_transform)
+            wg_transform_destroy(decoder->wg_transform);
+        if (decoder->input_type)
+            IMFMediaType_Release(decoder->input_type);
+        if (decoder->output_type)
+            IMFMediaType_Release(decoder->output_type);
+        free(decoder);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI aac_decoder_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    FIXME("iface %p, input_minimum %p, input_maximum %p, output_minimum %p, output_maximum %p stub!\n",
+            iface, input_minimum, input_maximum, output_minimum, output_maximum);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    FIXME("iface %p, inputs %p, outputs %p stub!\n", iface, inputs, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    FIXME("iface %p, input_size %u, inputs %p, output_size %u, outputs %p stub!\n",
+            iface, input_size, inputs, output_size, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    UINT32 block_alignment;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
+
+    if (!decoder->input_type || !decoder->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
+        return hr;
+
+    info->hnsMaxLatency = 0;
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES|MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER
+            |MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE|MFT_INPUT_STREAM_HOLDS_BUFFERS;
+    info->cbSize = 0;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    UINT32 channel_count, block_alignment;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
+
+    if (!decoder->input_type || !decoder->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->output_type, &MF_MT_AUDIO_NUM_CHANNELS, &channel_count)))
+        return hr;
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
+        return hr;
+
+    info->dwFlags = 0;
+    info->cbSize = 0x1800 * block_alignment * channel_count;
+    info->cbAlignment = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI aac_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("iface %p, attributes %p stub!\n", iface, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    FIXME("iface %p, id %u stub!\n", iface, id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    FIXME("iface %p, streams %u, ids %p stub!\n", iface, streams, ids);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, index %u, type %p stub!\n", iface, id, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    UINT32 channel_count, sample_size, sample_rate, block_alignment;
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaType *media_type;
+    const GUID *output_type;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, index %u, type %p.\n", iface, id, index, type);
+
+    if (!decoder->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *type = NULL;
+
+    if (index >= ARRAY_SIZE(aac_decoder_output_types))
+        return MF_E_NO_MORE_TYPES;
+    index = ARRAY_SIZE(aac_decoder_output_types) - index - 1;
+    output_type = aac_decoder_output_types[index];
+
+    if (FAILED(hr = MFCreateMediaType(&media_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, output_type)))
+        goto done;
+
+    if (IsEqualGUID(output_type, &MFAudioFormat_Float))
+        sample_size = 32;
+    else if (IsEqualGUID(output_type, &MFAudioFormat_PCM))
+        sample_size = 16;
+    else
+    {
+        FIXME("Subtype %s not implemented!\n", debugstr_guid(output_type));
+        hr = E_NOTIMPL;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, sample_size)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_NUM_CHANNELS, &channel_count)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_NUM_CHANNELS, channel_count)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &sample_rate)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, sample_rate)))
+        goto done;
+
+    block_alignment = sample_size * channel_count / 8;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, block_alignment)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, sample_rate * block_alignment)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, 1)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_FIXED_SIZE_SAMPLES, 1)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_PREFER_WAVEFORMATEX, 1)))
+        goto done;
+
+done:
+    if (SUCCEEDED(hr))
+        IMFMediaType_AddRef((*type = media_type));
+
+    IMFMediaType_Release(media_type);
+    return hr;
+}
+
+static HRESULT WINAPI aac_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    MF_ATTRIBUTE_TYPE item_type;
+    GUID major, subtype;
+    HRESULT hr;
+    ULONG i;
+
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+        FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Audio))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(aac_decoder_input_types); ++i)
+        if (IsEqualGUID(&subtype, aac_decoder_input_types[i]))
+            break;
+    if (i == ARRAY_SIZE(aac_decoder_input_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_USER_DATA, &item_type)) ||
+        item_type != MF_ATTRIBUTE_BLOB)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_NUM_CHANNELS, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_PREFER_WAVEFORMATEX, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (!decoder->input_type && FAILED(hr = MFCreateMediaType(&decoder->input_type)))
+        return hr;
+
+    if (decoder->output_type)
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+
+    return IMFMediaType_CopyAllItems(type, (IMFAttributes *)decoder->input_type);
+}
+
+static HRESULT WINAPI aac_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    MF_ATTRIBUTE_TYPE item_type;
+    ULONG i, sample_size;
+    GUID major, subtype;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+        FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Audio))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(aac_decoder_output_types); ++i)
+        if (IsEqualGUID(&subtype, aac_decoder_output_types[i]))
+            break;
+    if (i == ARRAY_SIZE(aac_decoder_output_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (IsEqualGUID(&subtype, &MFAudioFormat_Float))
+        sample_size = 32;
+    else if (IsEqualGUID(&subtype, &MFAudioFormat_PCM))
+        sample_size = 16;
+    else
+    {
+        FIXME("Subtype %s not implemented!\n", debugstr_guid(&subtype));
+        hr = E_NOTIMPL;
+        return hr;
+    }
+
+    if (FAILED(IMFMediaType_SetUINT32(decoder->input_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, sample_size)))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_NUM_CHANNELS, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (!decoder->output_type && FAILED(hr = MFCreateMediaType(&decoder->output_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *)decoder->output_type)))
+        return hr;
+
+    try_create_wg_transform(decoder);
+    return S_OK;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("iface %p, id %u, flags %p stub!\n", iface, id, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("iface %p, flags %p stub!\n", iface, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("iface %p, lower %s, upper %s stub!\n", iface,
+            wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("iface %p, id %u, event %p stub!\n", iface, id, event);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
+    return S_OK;
+}
+
+static HRESULT WINAPI aac_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaBuffer *media_buffer;
+    MFT_INPUT_STREAM_INFO info;
+    UINT32 buffer_size;
+    BYTE *buffer;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, sample %p, flags %#x.\n", iface, id, sample, flags);
+
+    if (FAILED(hr = IMFTransform_GetInputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (decoder->input_sample)
+        return MF_E_NOTACCEPTING;
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &buffer, NULL, &buffer_size)))
+        goto done;
+
+    if (SUCCEEDED(hr = wg_transform_push_data(decoder->wg_transform, buffer, buffer_size)))
+        IMFSample_AddRef((decoder->input_sample = sample));
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
+}
+
+static HRESULT WINAPI aac_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_sample wg_sample = {0};
+    IMFMediaBuffer *media_buffer;
+    MFT_OUTPUT_STREAM_INFO info;
+    UINT32 buffer_size;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#x, count %u, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count > 1)
+    {
+        FIXME("Not implemented count %u\n", count);
+        return E_NOTIMPL;
+    }
+
+    if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *status = 0;
+    samples[0].dwStatus = 0;
+    if (!samples[0].pSample)
+    {
+        samples[0].dwStatus = MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE;
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &wg_sample.data, &wg_sample.size, NULL)))
+        goto done;
+    wg_sample.size = buffer_size;
+
+    if (wg_sample.size < info.cbSize)
+        hr = MF_E_BUFFERTOOSMALL;
+    else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
+    {
+        if (wg_sample.flags & WG_SAMPLE_FLAG_INCOMPLETE)
+            samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_INCOMPLETE;
+    }
+    else
+    {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
+        decoder->input_sample = NULL;
+    }
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
+}
+
+static const IMFTransformVtbl aac_decoder_vtbl =
+{
+    aac_decoder_QueryInterface,
+    aac_decoder_AddRef,
+    aac_decoder_Release,
+    aac_decoder_GetStreamLimits,
+    aac_decoder_GetStreamCount,
+    aac_decoder_GetStreamIDs,
+    aac_decoder_GetInputStreamInfo,
+    aac_decoder_GetOutputStreamInfo,
+    aac_decoder_GetAttributes,
+    aac_decoder_GetInputStreamAttributes,
+    aac_decoder_GetOutputStreamAttributes,
+    aac_decoder_DeleteInputStream,
+    aac_decoder_AddInputStreams,
+    aac_decoder_GetInputAvailableType,
+    aac_decoder_GetOutputAvailableType,
+    aac_decoder_SetInputType,
+    aac_decoder_SetOutputType,
+    aac_decoder_GetInputCurrentType,
+    aac_decoder_GetOutputCurrentType,
+    aac_decoder_GetInputStatus,
+    aac_decoder_GetOutputStatus,
+    aac_decoder_SetOutputBounds,
+    aac_decoder_ProcessEvent,
+    aac_decoder_ProcessMessage,
+    aac_decoder_ProcessInput,
+    aac_decoder_ProcessOutput,
+};
+
+HRESULT aac_decoder_create(REFIID riid, void **ret)
+{
+    struct aac_decoder *decoder;
+
+    TRACE("riid %s, ret %p.\n", debugstr_guid(riid), ret);
+
+    if (!(decoder = calloc(1, sizeof(*decoder))))
+        return E_OUTOFMEMORY;
+
+    decoder->IMFTransform_iface.lpVtbl = &aac_decoder_vtbl;
+    decoder->refcount = 1;
+
+    *ret = &decoder->IMFTransform_iface;
+    TRACE("Created decoder %p\n", *ret);
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 00fa2553d9a..0834de8bcab 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -127,6 +127,7 @@ void mf_media_type_to_wg_encoded_format(IMFMediaType *type, struct wg_encoded_fo

 HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj) DECLSPEC_HIDDEN;

+HRESULT aac_decoder_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
 HRESULT wma_decoder_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
 HRESULT h264_decoder_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
 HRESULT audio_converter_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 4ff174a2083..008e95d46bf 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -30,6 +30,7 @@
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);

 DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
+DEFINE_MEDIATYPE_GUID(MFAudioFormat_RAW_AAC, WAVE_FORMAT_RAW_AAC1);

 struct video_processor
 {
@@ -401,11 +401,6 @@ static const GUID CLSID_GStreamerByteStreamHandler = {0x317df618, 0x5e5a, 0x468a

 static const GUID CLSID_WINEAudioConverter = {0x6a170414,0xaad9,0x4693,{0xb8,0x06,0x3a,0x0c,0x47,0xc5,0x70,0xd6}};

-static HRESULT aac_decoder_create(REFIID riid, void **ret)
-{
-    return decode_transform_create(riid, ret, DECODER_TYPE_AAC);
-}
-
 static const struct class_object
 {
     const GUID *clsid;
@@ -838,6 +864,51 @@ static void mf_media_type_to_wg_encoded_format_xwma(IMFMediaType *type, struct w
     memcpy(format->u.xwma.codec_data, codec_data, codec_data_len);
 }

+static void mf_media_type_to_wg_encoded_format_aac(IMFMediaType *type, struct wg_encoded_format *format)
+{
+    UINT32 codec_data_len, payload_type, profile_level_indication;
+    BYTE codec_data[64];
+
+    /* Audio specific config is stored at after HEAACWAVEINFO in MF_MT_USER_DATA
+     * https://docs.microsoft.com/en-us/windows/win32/api/mmreg/ns-mmreg-heaacwaveformat
+     */
+    struct
+    {
+        WORD payload_type;
+        WORD profile_level_indication;
+        WORD type;
+        WORD reserved1;
+        DWORD reserved2;
+    } *aac_info = (void *)codec_data;
+
+    if (FAILED(IMFMediaType_GetBlob(type, &MF_MT_USER_DATA, codec_data, sizeof(codec_data), &codec_data_len)))
+    {
+        FIXME("Codec data is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AAC_PAYLOAD_TYPE, &payload_type)))
+    {
+        FIXME("AAC payload type is not set.\n");
+        payload_type = aac_info->payload_type;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION, &profile_level_indication)))
+    {
+        FIXME("AAC provile level indication is not set.\n");
+        profile_level_indication = aac_info->profile_level_indication;
+    }
+
+    format->encoded_type = WG_ENCODED_TYPE_AAC;
+    format->u.aac.payload_type = payload_type;
+    format->u.aac.profile_level_indication = profile_level_indication;
+    format->u.aac.codec_data_len = 0;
+
+    if (codec_data_len > sizeof(*aac_info))
+    {
+        format->u.aac.codec_data_len = codec_data_len - sizeof(*aac_info);
+        memcpy(format->u.aac.codec_data, codec_data + sizeof(*aac_info), codec_data_len - sizeof(*aac_info));
+    }
+}
+
 static void mf_media_type_to_wg_encoded_format_h264(IMFMediaType *type, struct wg_encoded_format *format)
 {
     UINT64 frame_rate, frame_size;
@@ -897,6 +968,8 @@ void mf_media_type_to_wg_encoded_format(IMFMediaType *type, struct wg_encoded_fo
             mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 4);
         else if (IsEqualGUID(&subtype, &MFAudioFormat_XMAudio2))
             mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_XMA, 2);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_AAC))
+            mf_media_type_to_wg_encoded_format_aac(type, format);
         else
             FIXME("Unimplemented audio subtype %s.\n", debugstr_guid(&subtype));
     }
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 2e9625fed4e..1566748def5 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -98,6 +98,7 @@ struct wg_encoded_format
         WG_ENCODED_TYPE_UNKNOWN,
         WG_ENCODED_TYPE_WMA,
         WG_ENCODED_TYPE_XMA,
+        WG_ENCODED_TYPE_AAC,
         WG_ENCODED_TYPE_H264,
     } encoded_type;

@@ -115,6 +116,13 @@ struct wg_encoded_format
             unsigned char codec_data[64];
         } xwma;
         struct
+        {
+            uint32_t payload_type;
+            uint32_t profile_level_indication;
+            uint32_t codec_data_len;
+            unsigned char codec_data[64];
+        } aac;
+        struct
         {
             int32_t width, height;
             uint32_t fps_n, fps_d;
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 1c9dc6f72bb..775ac14e6a5 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -99,6 +99,52 @@ static GstCaps *wg_format_to_caps_xwma(const struct wg_encoded_format *format)
     return caps;
 }

+static GstCaps *wg_format_to_caps_aac(const struct wg_encoded_format *format)
+{
+    const char *profile, *level, *stream_format;
+    GstBuffer *buffer;
+    GstCaps *caps;
+
+    caps = gst_caps_new_empty_simple("audio/mpeg");
+    gst_caps_set_simple(caps, "mpegversion", G_TYPE_INT, 4, NULL);
+
+    switch (format->u.aac.payload_type)
+    {
+        case 0: stream_format = "raw"; break;
+        case 1: stream_format = "adts"; break;
+        case 2: stream_format = "adif"; break;
+        case 3: stream_format = "loas"; break;
+        default: stream_format = "raw"; break;
+    }
+    if (stream_format)
+        gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, stream_format, NULL);
+
+    switch (format->u.aac.profile_level_indication)
+    {
+        case 0x29: profile = "lc"; level = "2";  break;
+        case 0x2A: profile = "lc"; level = "4"; break;
+        case 0x2B: profile = "lc"; level = "5"; break;
+        default:
+            GST_FIXME("Unrecognized profile-level-indication %u\n", format->u.aac.profile_level_indication);
+            /* fallthrough */
+        case 0x00: case 0xFE: profile = level = NULL; break; /* unspecified */
+    }
+    if (profile)
+        gst_caps_set_simple(caps, "profile", G_TYPE_STRING, profile, NULL);
+    if (level)
+        gst_caps_set_simple(caps, "level", G_TYPE_STRING, level, NULL);
+
+    if (format->u.aac.codec_data_len)
+    {
+        buffer = gst_buffer_new_and_alloc(format->u.aac.codec_data_len);
+        gst_buffer_fill(buffer, 0, format->u.aac.codec_data, format->u.aac.codec_data_len);
+        gst_caps_set_simple(caps, "codec_data", GST_TYPE_BUFFER, buffer, NULL);
+        gst_buffer_unref(buffer);
+    }
+
+    return caps;
+}
+
 static GstCaps *wg_format_to_caps_h264(const struct wg_encoded_format *format)
 {
     const char *profile, *level;
@@ -166,6 +212,8 @@ static GstCaps *wg_encoded_format_to_caps(const struct wg_encoded_format *format
         case WG_ENCODED_TYPE_WMA:
         case WG_ENCODED_TYPE_XMA:
             return wg_format_to_caps_xwma(format);
+        case WG_ENCODED_TYPE_AAC:
+            return wg_format_to_caps_aac(format);
         case WG_ENCODED_TYPE_H264:
             return wg_format_to_caps_h264(format);
     }
From 7ec3158fe73bbe005f18c67f4c2c6c0f9dd14334 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Mon, 24 Jan 2022 00:46:03 -0500
Subject: [PATCH] winegstreamer: After failing to create decodebin parser, try
 protonvideoconv.

---
 dlls/winegstreamer/wg_parser.c | 69 +++++++++++++++++++++++++++++++++-
 1 file changed, 68 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 0db0519ff98..178c47d5d32 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -91,6 +91,8 @@ struct wg_parser

     bool unlimited_buffering;
     struct wg_format input_format;
+
+    bool use_mediaconv;
 };

 struct wg_parser_stream
@@ -943,6 +945,34 @@ static GstAutoplugSelectResult autoplug_select_cb(GstElement *bin, GstPad *pad,
     return GST_AUTOPLUG_SELECT_TRY;
 }

+static gint find_videoconv_cb(gconstpointer a, gconstpointer b)
+{
+    const GValue *val_a = a, *val_b = b;
+    GstElementFactory *factory_a = g_value_get_object(val_a), *factory_b = g_value_get_object(val_b);
+    const char *name_a = gst_element_factory_get_longname(factory_a), *name_b = gst_element_factory_get_longname(factory_b);
+
+    if (!strcmp(name_a, "Proton video converter"))
+        return -1;
+    if (!strcmp(name_b, "Proton video converter"))
+        return 1;
+    return 0;
+}
+
+static GValueArray *autoplug_sort_cb(GstElement *bin, GstPad *pad,
+        GstCaps *caps, GValueArray *factories, gpointer user)
+{
+    struct wg_parser *parser = user;
+    GValueArray *ret = g_value_array_copy(factories);
+
+    if (!parser->use_mediaconv)
+        return NULL;
+
+    GST_DEBUG("parser %p.", parser);
+
+    g_value_array_sort(ret, find_videoconv_cb);
+    return ret;
+}
+
 static void no_more_pads_cb(GstElement *element, gpointer user)
 {
     struct wg_parser *parser = user;
@@ -1801,9 +1831,12 @@ static gboolean src_activate_mode_cb(GstPad *pad, GstObject *parent, GstPadMode
     return FALSE;
 }

+static BOOL decodebin_parser_init_gst(struct wg_parser *parser);
+
 static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer user)
 {
     struct wg_parser *parser = user;
+    const GstStructure *structure;
     gchar *dbg_info = NULL;
     GError *err = NULL;

@@ -1838,6 +1871,21 @@ static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer use
         pthread_cond_signal(&parser->init_cond);
         break;

+    case GST_MESSAGE_ELEMENT:
+        structure = gst_message_get_structure(msg);
+        if (gst_structure_has_name(structure, "missing-plugin"))
+        {
+            pthread_mutex_lock(&parser->mutex);
+            if (!parser->use_mediaconv && parser->init_gst == decodebin_parser_init_gst)
+            {
+                GST_WARNING("Autoplugged element failed to initialise, trying again with protonvideoconvert.");
+                parser->error = true;
+                pthread_cond_signal(&parser->init_cond);
+            }
+            pthread_mutex_unlock(&parser->mutex);
+        }
+        break;
+
     default:
         break;
     }
@@ -1976,6 +2024,7 @@ static NTSTATUS wg_parser_connect(void *args)
 {
     const struct wg_parser_connect_params *params = args;
     struct wg_parser *parser = params->parser;
+    bool use_mediaconv = false;
     unsigned int i;
     HRESULT hr;
     int ret;
@@ -1993,9 +2042,16 @@ static NTSTATUS wg_parser_connect(void *args)
     if (!parser->pull_mode)
         gst_pad_set_active(parser->my_src, 1);
     ret = gst_element_get_state(parser->container, NULL, NULL, -1);
+
     if (ret == GST_STATE_CHANGE_FAILURE)
     {
-        GST_ERROR("Failed to play stream.\n");
+        if (!parser->use_mediaconv && parser->init_gst == decodebin_parser_init_gst && parser->pull_mode)
+        {
+            GST_WARNING("Failed to play media, trying again with protonvideoconvert.");
+            use_mediaconv = true;
+        }
+        else
+            GST_ERROR("Failed to play stream.\n");
         goto out;
     }

@@ -2005,6 +2061,8 @@ static NTSTATUS wg_parser_connect(void *args)
         pthread_cond_wait(&parser->init_cond, &parser->mutex);
     if (parser->error)
     {
+        if (!parser->use_mediaconv && parser->init_gst == decodebin_parser_init_gst)
+            use_mediaconv = true;
         pthread_mutex_unlock(&parser->mutex);
         goto out;
     }
@@ -2113,6 +2171,14 @@ static NTSTATUS wg_parser_connect(void *args)
     pthread_mutex_unlock(&parser->mutex);
     pthread_cond_signal(&parser->read_cond);

+    if (use_mediaconv)
+    {
+        parser->use_mediaconv = true;
+        hr = wg_parser_connect(args);
+        parser->use_mediaconv = false;
+        return hr;
+    }
+
     return E_FAIL;
 }

@@ -2227,6 +2293,7 @@ static BOOL decodebin_parser_init_gst(struct wg_parser *parser)
     g_signal_connect(element, "pad-added", G_CALLBACK(pad_added_cb), parser);
     g_signal_connect(element, "pad-removed", G_CALLBACK(pad_removed_cb), parser);
     g_signal_connect(element, "autoplug-select", G_CALLBACK(autoplug_select_cb), parser);
+    g_signal_connect(element, "autoplug-sort", G_CALLBACK(autoplug_sort_cb), parser);
     g_signal_connect(element, "no-more-pads", G_CALLBACK(no_more_pads_cb), parser);

     parser->their_sink = gst_element_get_static_pad(element, "sink");
From 62f18137cb5ff9b468079d7d1f26a512bdb66c90 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 15 Feb 2022 10:51:42 +0100
Subject: [PATCH] fixup! winegstreamer: After failing to create decodebin
 parser, try protonvideoconv.

---
 dlls/winegstreamer/wg_parser.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 89a64339413..337953db78d 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -30,6 +30,7 @@
 #include <stdarg.h>
 #include <stdio.h>

+#define GLIB_VERSION_MIN_REQUIRED GLIB_VERSION_2_30
 #include <gst/gst.h>
 #include <gst/video/video.h>
 #include <gst/audio/audio.h>
From 90c099fcb690675226493994c445df025ad00076 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 7 Feb 2022 17:19:31 -0600
Subject: [PATCH] winegstreamer: Release stream_cs on error in stream_thread().

This fixes a deadlock when trying to skip video in Persona 4 Golden.

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
(cherry picked from commit fc5719e4c57079b19bde8d169bf0b55194649e73)
---
 dlls/winegstreamer/wm_asyncreader.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winegstreamer/wm_asyncreader.c b/dlls/winegstreamer/wm_asyncreader.c
index aa15a5a77f9..12b63cd4ac1 100644
--- a/dlls/winegstreamer/wm_asyncreader.c
+++ b/dlls/winegstreamer/wm_asyncreader.c
@@ -146,6 +146,7 @@ static DWORD WINAPI stream_thread(void *arg)
             else if (hr != NS_E_NO_MORE_SAMPLES)
             {
                 ERR("Failed to get sample, hr %#x.\n", hr);
+                LeaveCriticalSection(&reader->stream_cs);
                 return 0;
             }
         }
From e55e47086014d7a7be94da17b4be7cf312e8ad80 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 4 Feb 2022 16:44:54 -0600
Subject: [PATCH] HACK: winegstreamer: Report BGRx for Persona 4 Golden.

---
 dlls/winegstreamer/wm_reader.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index ab49045ddab..8d004662599 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1508,6 +1508,17 @@ static HRESULT init_stream(struct wm_reader *reader, QWORD file_size)
              * Shadowgrounds provides wmv3 video and assumes that the initial
              * video type will be BGR. */
             stream->format.u.video.format = WG_VIDEO_FORMAT_BGR;
+            {
+                /* HACK: Persona 4 Golden tries to read compressed samples, and
+                 * then autoplug them via quartz to a filter that only accepts
+                 * BGRx. This is not trivial to implement. Return BGRx from the
+                 * wmvcore reader for now. */
+
+                const char *id = getenv("SteamGameId");
+
+                if (id && !strcmp(id, "1113000"))
+                    stream->format.u.video.format = WG_VIDEO_FORMAT_BGRx;
+            }
         }
         wg_parser_stream_enable(stream->wg_stream, &stream->format, NULL);
     }
From 3e920115088e5320e7615ccb3fbe8403cc41e497 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 28 Oct 2021 17:46:32 -0500
Subject: [PATCH] winegstreamer: Use unlimited buffering for the WM reader
 objects.

---
 dlls/winegstreamer/wm_reader.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 8d004662599..594b16e318b 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1455,7 +1455,7 @@ static HRESULT init_stream(struct wm_reader *reader, QWORD file_size)
     HRESULT hr;
     WORD i;

-    if (!(wg_parser = wg_parser_create(WG_PARSER_DECODEBIN, false)))
+    if (!(wg_parser = wg_parser_create(WG_PARSER_DECODEBIN, true)))
         return E_OUTOFMEMORY;

     reader->wg_parser = wg_parser;
From fbf46aeef3db5b3a9a58441ab6fd62501c183afb Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 28 Oct 2021 17:47:48 -0500
Subject: [PATCH] HACK: winegstreamer: Report streams in reverse order for
 wmvcore.

---
 dlls/winegstreamer/wm_reader.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 594b16e318b..905ce7306c8 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1484,7 +1484,7 @@ static HRESULT init_stream(struct wm_reader *reader, QWORD file_size)
     {
         struct wm_stream *stream = &reader->streams[i];

-        stream->wg_stream = wg_parser_get_stream(reader->wg_parser, i);
+        stream->wg_stream = wg_parser_get_stream(reader->wg_parser, reader->stream_count - i - 1);
         stream->reader = reader;
         stream->index = i;
         stream->selection = WMT_ON;
diff --git a/dlls/mfplat/main.c b/dlls/mfplat/main.c
index 0267381a44b..c397c241a57 100644
--- a/dlls/mfplat/main.c
+++ b/dlls/mfplat/main.c
@@ -9094,6 +9095,7 @@ static const IMFDXGIDeviceManagerVtbl dxgi_device_manager_vtbl =
 HRESULT WINAPI MFCreateDXGIDeviceManager(UINT *token, IMFDXGIDeviceManager **manager)
 {
     struct dxgi_device_manager *object;
+    const char *sgi = getenv("SteamGameId");
     const char *do_not_create = getenv("WINE_DO_NOT_CREATE_DXGI_DEVICE_MANAGER");

     TRACE("%p, %p.\n", token, manager);
@@ -9103,7 +9105,18 @@ HRESULT WINAPI MFCreateDXGIDeviceManager(UINT *token, IMFDXGIDeviceManager **man
      * #19126 is solved. Returning a DXGI device manager also breaks
      * Age of Empires Definitive Edition - this gameid should be removed
      * once CW bug #19741 is solved. */
-    if (do_not_create && do_not_create[0] != '\0')
+    if (sgi && (
+                strcmp(sgi, "305620") == 0 || /* The Long Dark */
+                strcmp(sgi, "1110100") == 0 || /* Power Rangers: Battle for the Grid */
+                strcmp(sgi, "1452500") == 0 || /* The Good Life */
+                strcmp(sgi, "1741410") == 0 || /* The Good Life Demo */
+                strcmp(sgi, "983970") == 0 || /* Haven */
+                strcmp(sgi, "585420") == 0 || /* Trailmakers */
+                strcmp(sgi, "684450") == 0 || /* Surviving the Aftermath */
+                strcmp(sgi, "1017900") == 0 || /* Age of Empires: Definitive Edition */
+                strcmp(sgi, "1331440") == 0 || /* FUSER */
+                (do_not_create && do_not_create[0] != '\0')
+               ))
     {
         FIXME("stubbing out\n");
         return E_NOTIMPL;
