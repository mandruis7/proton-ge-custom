From 41953b6d948983ff03741382776ad1687e60e58f Mon Sep 17 00:00:00 2001
From: Philip Rebohle <philip.rebohle@tu-dortmund.de>
Date: Tue, 19 Oct 2021 16:08:00 +0200
Subject: [PATCH 1/6] [dxvk] Enable VK_KHR_timeline_semaphore if supported

---
 src/dxvk/dxvk_adapter.cpp   | 26 +++++++++++++++++++++++---
 src/dxvk/dxvk_device_info.h |  2 ++
 src/dxvk/dxvk_extensions.h  |  1 +
 src/vulkan/vulkan_loader.h  |  6 ++++++
 4 files changed, 32 insertions(+), 3 deletions(-)

diff --git a/src/dxvk/dxvk_adapter.cpp b/src/dxvk/dxvk_adapter.cpp
index 33307e9b29..c068e5467a 100644
--- a/src/dxvk/dxvk_adapter.cpp
+++ b/src/dxvk/dxvk_adapter.cpp
@@ -249,7 +249,9 @@ namespace dxvk {
         && (m_deviceFeatures.extVertexAttributeDivisor.vertexAttributeInstanceRateDivisor
                 || !required.extVertexAttributeDivisor.vertexAttributeInstanceRateDivisor)
         && (m_deviceFeatures.extVertexAttributeDivisor.vertexAttributeInstanceRateZeroDivisor
-                || !required.extVertexAttributeDivisor.vertexAttributeInstanceRateZeroDivisor);
+                || !required.extVertexAttributeDivisor.vertexAttributeInstanceRateZeroDivisor)
+        && (m_deviceFeatures.khrTimelineSemaphore.timelineSemaphore
+                || !required.khrTimelineSemaphore.timelineSemaphore);
   }
   
   
@@ -263,7 +265,7 @@ namespace dxvk {
           DxvkDeviceFeatures  enabledFeatures) {
     DxvkDeviceExtensions devExtensions;
 
-    std::array<DxvkExt*, 30> devExtensionList = {{
+    std::array<DxvkExt*, 31> devExtensionList = {{
       &devExtensions.amdMemoryOverallocationBehaviour,
       &devExtensions.amdShaderFragmentMask,
       &devExtensions.ext4444Formats,
@@ -291,6 +293,7 @@ namespace dxvk {
       &devExtensions.khrSamplerMirrorClampToEdge,
       &devExtensions.khrShaderFloatControls,
       &devExtensions.khrSwapchain,
+      &devExtensions.khrTimelineSemaphore,
       &devExtensions.nvxBinaryImport,
       &devExtensions.nvxImageViewHandle,
     }};
@@ -402,6 +405,11 @@ namespace dxvk {
       enabledFeatures.khrBufferDeviceAddress.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.khrBufferDeviceAddress);
     }
 
+    if (devExtensions.khrTimelineSemaphore) {
+      enabledFeatures.khrTimelineSemaphore.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR;
+      enabledFeatures.khrTimelineSemaphore.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.khrTimelineSemaphore);
+    }
+
     // Report the desired overallocation behaviour to the driver
     VkDeviceMemoryOverallocationCreateInfoAMD overallocInfo;
     overallocInfo.sType = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD;
@@ -621,6 +629,11 @@ namespace dxvk {
       m_deviceInfo.khrShaderFloatControls.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.khrShaderFloatControls);
     }
 
+    if (m_deviceExtensions.supports(VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME)) {
+      m_deviceInfo.khrTimelineSemaphore.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR;
+      m_deviceInfo.khrTimelineSemaphore.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.khrTimelineSemaphore);
+    }
+
     // Query full device properties for all enabled extensions
     m_vki->vkGetPhysicalDeviceProperties2(m_handle, &m_deviceInfo.core);
     
@@ -707,6 +720,11 @@ namespace dxvk {
       m_deviceFeatures.khrBufferDeviceAddress.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.khrBufferDeviceAddress);
     }
 
+    if (m_deviceExtensions.supports(VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME)) {
+      m_deviceFeatures.khrTimelineSemaphore.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR;
+      m_deviceFeatures.khrTimelineSemaphore.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.khrTimelineSemaphore);
+    }
+
     m_vki->vkGetPhysicalDeviceFeatures2(m_handle, &m_deviceFeatures.core);
   }
 
@@ -800,7 +818,9 @@ namespace dxvk {
       "\n  vertexAttributeInstanceRateDivisor     : ", features.extVertexAttributeDivisor.vertexAttributeInstanceRateDivisor ? "1" : "0",
       "\n  vertexAttributeInstanceRateZeroDivisor : ", features.extVertexAttributeDivisor.vertexAttributeInstanceRateZeroDivisor ? "1" : "0",
       "\n", VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME,
-      "\n  bufferDeviceAddress                    : ", features.khrBufferDeviceAddress.bufferDeviceAddress));
+      "\n  bufferDeviceAddress                    : ", features.khrBufferDeviceAddress.bufferDeviceAddress,
+      "\n", VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME,
+      "\n  timelineSemaphore                      : ", features.khrTimelineSemaphore.timelineSemaphore));
   }
 
 
diff --git a/src/dxvk/dxvk_device_info.h b/src/dxvk/dxvk_device_info.h
index d832bec14c..119fb986c4 100644
--- a/src/dxvk/dxvk_device_info.h
+++ b/src/dxvk/dxvk_device_info.h
@@ -24,6 +24,7 @@ namespace dxvk {
     VkPhysicalDeviceDepthStencilResolvePropertiesKHR          khrDepthStencilResolve;
     VkPhysicalDeviceDriverPropertiesKHR                       khrDeviceDriverProperties;
     VkPhysicalDeviceFloatControlsPropertiesKHR                khrShaderFloatControls;
+    VkPhysicalDeviceTimelineSemaphorePropertiesKHR            khrTimelineSemaphore;
   };
 
 
@@ -48,6 +49,7 @@ namespace dxvk {
     VkPhysicalDeviceTransformFeedbackFeaturesEXT              extTransformFeedback;
     VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT         extVertexAttributeDivisor;
     VkPhysicalDeviceBufferDeviceAddressFeaturesKHR            khrBufferDeviceAddress;
+    VkPhysicalDeviceTimelineSemaphoreFeaturesKHR              khrTimelineSemaphore;
   };
 
 }
\ No newline at end of file
diff --git a/src/dxvk/dxvk_extensions.h b/src/dxvk/dxvk_extensions.h
index b2f60d5561..0148e9d2e3 100644
--- a/src/dxvk/dxvk_extensions.h
+++ b/src/dxvk/dxvk_extensions.h
@@ -303,6 +303,7 @@ namespace dxvk {
     DxvkExt khrSamplerMirrorClampToEdge       = { VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME,       DxvkExtMode::Optional };
     DxvkExt khrShaderFloatControls            = { VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME,              DxvkExtMode::Optional };
     DxvkExt khrSwapchain                      = { VK_KHR_SWAPCHAIN_EXTENSION_NAME,                          DxvkExtMode::Required };
+    DxvkExt khrTimelineSemaphore              = { VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME,                 DxvkExtMode::Optional };
     DxvkExt nvxBinaryImport                   = { VK_NVX_BINARY_IMPORT_EXTENSION_NAME,                      DxvkExtMode::Disabled };
     DxvkExt nvxImageViewHandle                = { VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME,                  DxvkExtMode::Disabled };
   };
diff --git a/src/vulkan/vulkan_loader.h b/src/vulkan/vulkan_loader.h
index 9ff7f14522..3421a083bc 100644
--- a/src/vulkan/vulkan_loader.h
+++ b/src/vulkan/vulkan_loader.h
@@ -309,6 +309,12 @@ namespace dxvk::vk {
     VULKAN_FN(vkQueuePresentKHR);
     #endif
 
+    #ifdef VK_KHR_timeline_semaphore
+    VULKAN_FN(vkGetSemaphoreCounterValueKHR);
+    VULKAN_FN(vkSignalSemaphoreKHR);
+    VULKAN_FN(vkWaitSemaphoresKHR);
+    #endif
+
     #ifdef VK_EXT_conditional_rendering
     VULKAN_FN(vkCmdBeginConditionalRenderingEXT);
     VULKAN_FN(vkCmdEndConditionalRenderingEXT);

From 5e48a6fc919d0bf992a577e6e68986d66cdc96ba Mon Sep 17 00:00:00 2001
From: Philip Rebohle <philip.rebohle@tu-dortmund.de>
Date: Fri, 22 Oct 2021 01:04:53 +0200
Subject: [PATCH 2/6] [dxvk] Add DxvkFence

---
 src/dxvk/dxvk_device.cpp |   6 +++
 src/dxvk/dxvk_device.h   |  10 ++++
 src/dxvk/dxvk_fence.cpp  | 104 +++++++++++++++++++++++++++++++++++++++
 src/dxvk/dxvk_fence.h    |  97 ++++++++++++++++++++++++++++++++++++
 src/dxvk/meson.build     |   1 +
 5 files changed, 218 insertions(+)
 create mode 100644 src/dxvk/dxvk_fence.cpp
 create mode 100644 src/dxvk/dxvk_fence.h

diff --git a/src/dxvk/dxvk_device.cpp b/src/dxvk/dxvk_device.cpp
index 711f615a33..763ec9c0a4 100644
--- a/src/dxvk/dxvk_device.cpp
+++ b/src/dxvk/dxvk_device.cpp
@@ -112,6 +112,12 @@ namespace dxvk {
   }
   
   
+  Rc<DxvkFence> DxvkDevice::createFence(
+    const DxvkFenceCreateInfo& fenceInfo) {
+    return new DxvkFence(this, fenceInfo);
+  }
+
+
   Rc<DxvkFramebuffer> DxvkDevice::createFramebuffer(
     const DxvkFramebufferInfo&  info) {
     return new DxvkFramebuffer(m_vkd, info);
diff --git a/src/dxvk/dxvk_device.h b/src/dxvk/dxvk_device.h
index 4cee1888de..fc6dfb8e1b 100644
--- a/src/dxvk/dxvk_device.h
+++ b/src/dxvk/dxvk_device.h
@@ -6,6 +6,7 @@
 #include "dxvk_constant_state.h"
 #include "dxvk_context.h"
 #include "dxvk_extensions.h"
+#include "dxvk_fence.h"
 #include "dxvk_framebuffer.h"
 #include "dxvk_image.h"
 #include "dxvk_instance.h"
@@ -267,6 +268,15 @@ namespace dxvk {
             VkQueryControlFlags   flags,
             uint32_t              index);
     
+    /**
+     * \brief Creates new fence
+     *
+     * \param [in] info Fence create info
+     * \returns The fence
+     */
+    Rc<DxvkFence> createFence(
+      const DxvkFenceCreateInfo& fenceInfo);
+    
     /**
      * \brief Creates framebuffer for a set of render targets
      * 
diff --git a/src/dxvk/dxvk_fence.cpp b/src/dxvk/dxvk_fence.cpp
new file mode 100644
index 0000000000..d14db71e9b
--- /dev/null
+++ b/src/dxvk/dxvk_fence.cpp
@@ -0,0 +1,104 @@
+#include "dxvk_device.h"
+#include "dxvk_fence.h"
+
+namespace dxvk {
+
+  DxvkFence::DxvkFence(
+          DxvkDevice*           device,
+    const DxvkFenceCreateInfo&  info)
+  : m_vkd(device->vkd()), m_info(info) {
+    if (!device->features().khrTimelineSemaphore.timelineSemaphore)
+      throw DxvkError("Timeline semaphores not supported");
+
+    VkSemaphoreTypeCreateInfoKHR typeInfo;
+    typeInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR;
+    typeInfo.pNext = nullptr;
+    typeInfo.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE_KHR;
+    typeInfo.initialValue = info.initialValue;
+    
+    VkSemaphoreCreateInfo semaphoreInfo;
+    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+    semaphoreInfo.pNext = &typeInfo;
+    semaphoreInfo.flags = 0;
+
+    VkResult vr = m_vkd->vkCreateSemaphore(m_vkd->device(),
+      &semaphoreInfo, nullptr, &m_semaphore);
+
+    if (vr != VK_SUCCESS)
+      throw DxvkError("Failed to create timeline semaphore");
+
+    m_thread = dxvk::thread([this] { run(); });
+  }
+
+
+  DxvkFence::~DxvkFence() {
+    m_stop.store(true);
+    m_thread.join();
+
+    m_vkd->vkDestroySemaphore(m_vkd->device(), m_semaphore, nullptr);
+  }
+
+
+  void DxvkFence::enqueueWait(uint64_t value, DxvkFenceEvent&& event) {
+    std::unique_lock<dxvk::mutex> lock(m_mutex);
+
+    if (value > m_lastValue.load())
+      m_queue.emplace(value, std::move(event));
+    else
+      event();
+  }
+  
+
+  void DxvkFence::run() {
+    uint64_t value = 0ull;
+
+    VkSemaphoreWaitInfoKHR waitInfo;
+    waitInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR;
+    waitInfo.pNext = nullptr;
+    waitInfo.flags = 0;
+    waitInfo.semaphoreCount = 1;
+    waitInfo.pSemaphores = &m_semaphore;
+    waitInfo.pValues = &value;
+
+    while (!m_stop.load()) {
+      std::unique_lock<dxvk::mutex> lock(m_mutex);
+
+      // Query actual semaphore value and start from there, so that
+      // we can skip over large increments in the semaphore value
+      VkResult vr = m_vkd->vkGetSemaphoreCounterValueKHR(m_vkd->device(), m_semaphore, &value);
+
+      if (vr != VK_SUCCESS) {
+        Logger::err(str::format("Failed to query semaphore value: ", vr));
+        return;
+      }
+
+      m_lastValue.store(value);
+
+      // Signal all enqueued events whose value is not greater than
+      // the current semaphore value
+      while (!m_queue.empty() && m_queue.top().value <= value) {
+        m_queue.top().event();
+        m_queue.pop();
+      }
+
+      if (m_stop)
+        return;
+
+      lock.unlock();
+
+      // Wait for the semaphore to be singaled again and update
+      // state. The timeout is chosen so that we can free the
+      // fence object without having to 
+      value += 1;
+
+      vr = m_vkd->vkWaitSemaphoresKHR(
+        m_vkd->device(), &waitInfo, 10'000'000ull);
+
+      if (vr != VK_SUCCESS && vr != VK_TIMEOUT) {
+        Logger::err(str::format("Failed to wait for semaphore: ", vr));
+        return;
+      }
+    }
+  }
+
+}
diff --git a/src/dxvk/dxvk_fence.h b/src/dxvk/dxvk_fence.h
new file mode 100644
index 0000000000..b5b0e96867
--- /dev/null
+++ b/src/dxvk/dxvk_fence.h
@@ -0,0 +1,97 @@
+#pragma once
+
+#include <functional>
+#include <queue>
+
+#include "dxvk_resource.h"
+
+#include "../util/thread.h"
+
+namespace dxvk {
+
+  class DxvkDevice;
+
+  using DxvkFenceEvent = std::function<void ()>;
+
+  /**
+   * \brief Fence create info
+   */
+  struct DxvkFenceCreateInfo {
+    uint64_t        initialValue;
+  };
+
+  /**
+   * \brief Fence
+   *
+   * Wrapper around Vulkan timeline semaphores that
+   * can signal an event when the value changes.
+   */
+  class DxvkFence : public DxvkResource {
+
+  public:
+
+    DxvkFence(
+            DxvkDevice*           device,
+      const DxvkFenceCreateInfo&  info);
+
+    ~DxvkFence();
+
+    /**
+     * \brief Semaphore handle
+     */
+    VkSemaphore handle() const {
+      return m_semaphore;
+    }
+
+    /**
+     * \brief Retrieves current semaphore value
+     * \returns Current semaphore value
+     */
+    uint64_t getValue() {
+      return m_lastValue.load();
+    }
+
+    /**
+     * \brief Enqueues semaphore wait
+     *
+     * Signals the given event when the
+     * semaphore reaches the given value.
+     * \param [in] value Enqueue value
+     * \param [in] event Callback
+     */
+    void enqueueWait(uint64_t value, DxvkFenceEvent&& event);
+
+  private:
+
+    struct QueueItem {
+      QueueItem() { }
+      QueueItem(uint32_t v, DxvkFenceEvent&& e)
+      : value(v), event(std::move(e)) { }
+
+      uint64_t        value;
+      DxvkFenceEvent  event;
+
+      bool operator == (const QueueItem& item) const { return value == item.value; }
+      bool operator != (const QueueItem& item) const { return value != item.value; }
+      bool operator <  (const QueueItem& item) const { return value <  item.value; }
+      bool operator <= (const QueueItem& item) const { return value <= item.value; }
+      bool operator >  (const QueueItem& item) const { return value >  item.value; }
+      bool operator >= (const QueueItem& item) const { return value >= item.value; }
+    };
+
+    Rc<vk::DeviceFn>                m_vkd;
+    DxvkFenceCreateInfo             m_info;
+    VkSemaphore                     m_semaphore;
+
+    std::priority_queue<QueueItem>  m_queue;
+    std::atomic<uint64_t>           m_lastValue = { 0ull  };
+    std::atomic<bool>               m_stop      = { false };
+
+    dxvk::mutex                     m_mutex;
+    dxvk::thread                    m_thread;
+
+    void run();
+
+  };
+
+}
\ No newline at end of file
diff --git a/src/dxvk/meson.build b/src/dxvk/meson.build
index 3153c8cfaa..e0e3e8f26d 100644
--- a/src/dxvk/meson.build
+++ b/src/dxvk/meson.build
@@ -71,6 +71,7 @@ dxvk_src = files([
   'dxvk_device.cpp',
   'dxvk_device_filter.cpp',
   'dxvk_extensions.cpp',
+  'dxvk_fence.cpp',
   'dxvk_format.cpp',
   'dxvk_framebuffer.cpp',
   'dxvk_gpu_event.cpp',

From 93f0b857162916099322bb7b372565020b4fb724 Mon Sep 17 00:00:00 2001
From: Philip Rebohle <philip.rebohle@tu-dortmund.de>
Date: Fri, 22 Oct 2021 16:25:53 +0200
Subject: [PATCH 3/6] [dxvk] Refactor queue submission info

---
 src/dxvk/dxvk_cmdlist.cpp | 54 ++++++++++++++++++++++-----------------
 src/dxvk/dxvk_cmdlist.h   | 38 ++++++++++++++++++++++-----
 2 files changed, 61 insertions(+), 31 deletions(-)

diff --git a/src/dxvk/dxvk_cmdlist.cpp b/src/dxvk/dxvk_cmdlist.cpp
index 09a851befb..1ea91ac935 100644
--- a/src/dxvk/dxvk_cmdlist.cpp
+++ b/src/dxvk/dxvk_cmdlist.cpp
@@ -85,40 +85,35 @@ namespace dxvk {
     const auto& graphics = m_device->queues().graphics;
     const auto& transfer = m_device->queues().transfer;
 
-    DxvkQueueSubmission info = DxvkQueueSubmission();
+    m_submission.reset();
 
     if (m_cmdBuffersUsed.test(DxvkCmdBuffer::SdmaBuffer)) {
-      info.cmdBuffers[info.cmdBufferCount++] = m_sdmaBuffer;
+      m_submission.addCmdBuffer(m_sdmaBuffer);
 
       if (m_device->hasDedicatedTransferQueue()) {
-        info.wakeSync[info.wakeCount++] = m_sdmaSemaphore;
-        VkResult status = submitToQueue(transfer.queueHandle, VK_NULL_HANDLE, info);
+        m_submission.addSignalSemaphore(m_sdmaSemaphore, 0);
+        VkResult status = submitToQueue(transfer.queueHandle, VK_NULL_HANDLE, m_submission);
 
         if (status != VK_SUCCESS)
           return status;
 
-        info = DxvkQueueSubmission();
-        info.waitSync[info.waitCount] = m_sdmaSemaphore;
-        info.waitMask[info.waitCount] = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
-        info.waitCount += 1;
+        m_submission.reset();
+        m_submission.addWaitSemaphore(m_sdmaSemaphore, 0, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT);
       }
     }
 
     if (m_cmdBuffersUsed.test(DxvkCmdBuffer::InitBuffer))
-      info.cmdBuffers[info.cmdBufferCount++] = m_initBuffer;
+      m_submission.addCmdBuffer(m_initBuffer);
     if (m_cmdBuffersUsed.test(DxvkCmdBuffer::ExecBuffer))
-      info.cmdBuffers[info.cmdBufferCount++] = m_execBuffer;
+      m_submission.addCmdBuffer(m_execBuffer);
     
-    if (waitSemaphore) {
-      info.waitSync[info.waitCount] = waitSemaphore;
-      info.waitMask[info.waitCount] = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
-      info.waitCount += 1;
-    }
+    if (waitSemaphore)
+      m_submission.addWaitSemaphore(waitSemaphore, 0, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT);
 
     if (wakeSemaphore)
-      info.wakeSync[info.wakeCount++] = wakeSemaphore;
+      m_submission.addSignalSemaphore(wakeSemaphore, 0);
     
-    return submitToQueue(graphics.queueHandle, m_fence, info);
+    return submitToQueue(graphics.queueHandle, m_fence, m_submission);
   }
   
   
@@ -193,16 +188,27 @@ namespace dxvk {
           VkQueue               queue,
           VkFence               fence,
     const DxvkQueueSubmission&  info) {
+    VkTimelineSemaphoreSubmitInfoKHR timelineInfo;
+    timelineInfo.sType                      = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR;
+    timelineInfo.pNext                      = nullptr;
+    timelineInfo.waitSemaphoreValueCount    = info.waitValues.size();
+    timelineInfo.pWaitSemaphoreValues       = info.waitValues.data();
+    timelineInfo.signalSemaphoreValueCount  = info.signalValues.size();
+    timelineInfo.pSignalSemaphoreValues     = info.signalValues.data();
+
     VkSubmitInfo submitInfo;
     submitInfo.sType                = VK_STRUCTURE_TYPE_SUBMIT_INFO;
     submitInfo.pNext                = nullptr;
-    submitInfo.waitSemaphoreCount   = info.waitCount;
-    submitInfo.pWaitSemaphores      = info.waitSync;
-    submitInfo.pWaitDstStageMask    = info.waitMask;
-    submitInfo.commandBufferCount   = info.cmdBufferCount;
-    submitInfo.pCommandBuffers      = info.cmdBuffers;
-    submitInfo.signalSemaphoreCount = info.wakeCount;
-    submitInfo.pSignalSemaphores    = info.wakeSync;
+    submitInfo.waitSemaphoreCount   = info.waitSync.size();
+    submitInfo.pWaitSemaphores      = info.waitSync.data();
+    submitInfo.pWaitDstStageMask    = info.waitMask.data();
+    submitInfo.commandBufferCount   = info.cmdBuffers.size();
+    submitInfo.pCommandBuffers      = info.cmdBuffers.data();
+    submitInfo.signalSemaphoreCount = info.signalSync.size();
+    submitInfo.pSignalSemaphores    = info.signalSync.data();
+
+    if (m_device->features().khrTimelineSemaphore.timelineSemaphore)
+      submitInfo.pNext = &timelineInfo;
     
     return m_vkd->vkQueueSubmit(queue, 1, &submitInfo, fence);
   }
diff --git a/src/dxvk/dxvk_cmdlist.h b/src/dxvk/dxvk_cmdlist.h
index b6c4c5ae80..c232554d47 100644
--- a/src/dxvk/dxvk_cmdlist.h
+++ b/src/dxvk/dxvk_cmdlist.h
@@ -38,13 +38,36 @@ namespace dxvk {
    * only, array sizes are based on need.
    */
   struct DxvkQueueSubmission {
-    uint32_t              waitCount;
-    VkSemaphore           waitSync[2];
-    VkPipelineStageFlags  waitMask[2];
-    uint32_t              wakeCount;
-    VkSemaphore           wakeSync[2];
-    uint32_t              cmdBufferCount;
-    VkCommandBuffer       cmdBuffers[4];
+    std::vector<VkSemaphore>          waitSync;
+    std::vector<VkPipelineStageFlags> waitMask;
+    std::vector<uint64_t>             waitValues;
+    std::vector<VkSemaphore>          signalSync;
+    std::vector<uint64_t>             signalValues;
+    std::vector<VkCommandBuffer>      cmdBuffers;
+
+    void addWaitSemaphore(VkSemaphore semaphore, uint64_t value, VkPipelineStageFlags stageMask) {
+      waitSync.push_back(semaphore);
+      waitMask.push_back(stageMask);
+      waitValues.push_back(value);
+    }
+
+    void addSignalSemaphore(VkSemaphore semaphore, uint64_t value) {
+      signalSync.push_back(semaphore);
+      signalValues.push_back(value);
+    }
+
+    void addCmdBuffer(VkCommandBuffer cmdBuffer) {
+      cmdBuffers.push_back(cmdBuffer);
+    }
+
+    void reset() {
+      waitSync.clear();
+      waitMask.clear();
+      waitValues.clear();
+      signalSync.clear();
+      signalValues.clear();
+      cmdBuffers.clear();
+    }
   };
 
   /**
@@ -774,6 +797,7 @@ namespace dxvk {
     DxvkGpuQueryTracker m_gpuQueryTracker;
     DxvkBufferTracker   m_bufferTracker;
     DxvkStatCounters    m_statCounters;
+    DxvkQueueSubmission m_submission;
 
     VkCommandBuffer getCmdBuffer(DxvkCmdBuffer cmdBuffer) const {
       if (cmdBuffer == DxvkCmdBuffer::ExecBuffer) return m_execBuffer;

From 48b261ec76e240a0f44bba54dadf116a669072d3 Mon Sep 17 00:00:00 2001
From: Philip Rebohle <philip.rebohle@tu-dortmund.de>
Date: Fri, 22 Oct 2021 16:49:22 +0200
Subject: [PATCH 4/6] [dxvk] Add fence support to command list

---
 src/dxvk/dxvk_cmdlist.cpp | 13 +++++++++++++
 src/dxvk/dxvk_cmdlist.h   | 24 ++++++++++++++++++++++++
 src/dxvk/dxvk_context.cpp | 10 ++++++++++
 src/dxvk/dxvk_context.h   | 22 +++++++++++++++++++++-
 src/dxvk/dxvk_fence.cpp   | 20 ++++++++++++++++++++
 src/dxvk/dxvk_fence.h     | 34 +++++++++++++++++++++++++++++++++-
 6 files changed, 121 insertions(+), 2 deletions(-)

diff --git a/src/dxvk/dxvk_cmdlist.cpp b/src/dxvk/dxvk_cmdlist.cpp
index 1ea91ac935..cd63612c31 100644
--- a/src/dxvk/dxvk_cmdlist.cpp
+++ b/src/dxvk/dxvk_cmdlist.cpp
@@ -113,6 +113,16 @@ namespace dxvk {
     if (wakeSemaphore)
       m_submission.addSignalSemaphore(wakeSemaphore, 0);
     
+    for (size_t i = 0; i < m_waitSemaphores.count(); i++) {
+      auto entry = m_waitSemaphores.get(i);
+      m_submission.addWaitSemaphore(entry.first, entry.second, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT);
+    }
+
+    for (size_t i = 0; i < m_signalSemaphores.count(); i++) {
+      auto entry = m_signalSemaphores.get(i);
+      m_submission.addSignalSemaphore(entry.first, entry.second);
+    }
+
     return submitToQueue(graphics.queueHandle, m_fence, m_submission);
   }
   
@@ -181,6 +191,9 @@ namespace dxvk {
     // Less important stuff
     m_signalTracker.reset();
     m_statCounters.reset();
+
+    m_waitSemaphores.reset();
+    m_signalSemaphores.reset();
   }
 
 
diff --git a/src/dxvk/dxvk_cmdlist.h b/src/dxvk/dxvk_cmdlist.h
index c232554d47..fdbf974cb5 100644
--- a/src/dxvk/dxvk_cmdlist.h
+++ b/src/dxvk/dxvk_cmdlist.h
@@ -5,6 +5,7 @@
 #include "dxvk_bind_mask.h"
 #include "dxvk_buffer.h"
 #include "dxvk_descriptor.h"
+#include "dxvk_fence.h"
 #include "dxvk_gpu_event.h"
 #include "dxvk_gpu_query.h"
 #include "dxvk_lifetime.h"
@@ -223,6 +224,26 @@ namespace dxvk {
       m_resources.notify();
       m_signalTracker.notify();
     }
+
+    /**
+     * \brief Waits for fence
+     *
+     * \param [in] fence Fence to wait on
+     * \param [in] value Value to wait for
+     */
+    void waitFence(Rc<DxvkFence> fence, uint64_t value) {
+      m_waitSemaphores.add(std::move(fence), value);
+    }
+    
+    /**
+     * \brief Signals fence
+     *
+     * \param [in] fence Fence to signal
+     * \param [in] value Value to signal to
+     */
+    void signalFence(Rc<DxvkFence> fence, uint64_t value) {
+      m_signalSemaphores.add(std::move(fence), value);
+    }
     
     /**
      * \brief Resets the command list
@@ -788,6 +809,9 @@ namespace dxvk {
     VkCommandBuffer     m_sdmaBuffer = VK_NULL_HANDLE;
 
     VkSemaphore         m_sdmaSemaphore = VK_NULL_HANDLE;
+
+    DxvkFenceList       m_waitSemaphores;
+    DxvkFenceList       m_signalSemaphores;
     
     DxvkCmdBufferFlags  m_cmdBuffersUsed;
     DxvkLifetimeTracker m_resources;
diff --git a/src/dxvk/dxvk_context.cpp b/src/dxvk/dxvk_context.cpp
index a51c9d1c46..d0e5da4a58 100644
--- a/src/dxvk/dxvk_context.cpp
+++ b/src/dxvk/dxvk_context.cpp
@@ -2574,6 +2574,16 @@ namespace dxvk {
   }
 
 
+  void DxvkContext::waitFence(const Rc<DxvkFence>& fence, uint64_t value) {
+    m_cmd->waitFence(fence, value);
+  }
+
+
+  void DxvkContext::signalFence(const Rc<DxvkFence>& fence, uint64_t value) {
+    m_cmd->signalFence(fence, value);
+  }
+
+
   void DxvkContext::beginDebugLabel(VkDebugUtilsLabelEXT *label) {
     if (!m_device->instance()->extensions().extDebugUtils)
       return;
diff --git a/src/dxvk/dxvk_context.h b/src/dxvk/dxvk_context.h
index 39c5b989db..c5547c1d82 100644
--- a/src/dxvk/dxvk_context.h
+++ b/src/dxvk/dxvk_context.h
@@ -989,7 +989,27 @@ namespace dxvk {
     void signal(
       const Rc<sync::Signal>&   signal,
             uint64_t            value);
-    
+
+    /**
+     * \brief Waits for fence
+     *
+     * Stalls current command list execution until
+     * the fence reaches the given value or higher.
+     * \param [in] fence Fence to wait on
+     * \param [in] value Value to wait on
+     */
+    void waitFence(const Rc<DxvkFence>& fence, uint64_t value);
+
+    /**
+     * \brief Signals fence
+     *
+     * Signals fence to the given value once the current
+     * command list execution completes on the GPU.
+     * \param [in] fence Fence to signal
+     * \param [in] value Value to signal
+     */
+    void signalFence(const Rc<DxvkFence>& fence, uint64_t value);
+
     /**
      * \brief Begins a debug label region
      * \param [in] label The debug label
diff --git a/src/dxvk/dxvk_fence.cpp b/src/dxvk/dxvk_fence.cpp
index d14db71e9b..9ab75ce0ea 100644
--- a/src/dxvk/dxvk_fence.cpp
+++ b/src/dxvk/dxvk_fence.cpp
@@ -101,4 +101,24 @@ namespace dxvk {
     }
   }
 
+
+  DxvkFenceList::DxvkFenceList() {
+
+  }
+
+
+  DxvkFenceList::~DxvkFenceList() {
+
+  }
+
+
+  void DxvkFenceList::add(Rc<DxvkFence> fence, uint64_t value) {
+    m_fences.emplace_back(std::move(fence), value);
+  }
+
+
+  void DxvkFenceList::reset() {
+    m_fences.clear();
+  }
+
 }
diff --git a/src/dxvk/dxvk_fence.h b/src/dxvk/dxvk_fence.h
index b5b0e96867..d3c9698368 100644
--- a/src/dxvk/dxvk_fence.h
+++ b/src/dxvk/dxvk_fence.h
@@ -2,6 +2,8 @@
 
 #include <functional>
 #include <queue>
+#include <utility>
+#include <vector>
 
 #include "dxvk_resource.h"
 
@@ -26,7 +28,7 @@ namespace dxvk {
    * Wrapper around Vulkan timeline semaphores that
    * can signal an event when the value changes.
    */
-  class DxvkFence : public DxvkResource {
+  class DxvkFence : public RcObject {
 
   public:
 
@@ -94,4 +96,34 @@ namespace dxvk {
 
   };
 
+
+  /**
+   * \brief Fence list
+   */
+  class DxvkFenceList {
+
+  public:
+
+    DxvkFenceList();
+    ~DxvkFenceList();
+
+    size_t count() const {
+      return m_fences.size();
+    }
+
+    std::pair<VkSemaphore, uint64_t> get(size_t idx) {
+      const auto& e = m_fences[idx];
+      return std::make_pair(e.first->handle(), e.second);
+    }
+
+    void add(Rc<DxvkFence> fence, uint64_t value);
+
+    void reset();
+
+  private:
+
+    std::vector<std::pair<Rc<DxvkFence>, uint64_t>> m_fences;
+
+  };
+
 }
\ No newline at end of file

From 2a5b435343cd34d6682b5c7136c8f3e6c0709891 Mon Sep 17 00:00:00 2001
From: Philip Rebohle <philip.rebohle@tu-dortmund.de>
Date: Fri, 22 Oct 2021 17:22:41 +0200
Subject: [PATCH 5/6] [d3d11] Implement ID3D11Fence

No interop support just yet.
---
 src/d3d11/d3d11_context_imm.cpp | 34 ++++++++++++++--
 src/d3d11/d3d11_device.cpp      | 18 +++++----
 src/d3d11/d3d11_device.h        |  2 +-
 src/d3d11/d3d11_fence.cpp       | 72 +++++++++++++++++++++++++++++++++
 src/d3d11/d3d11_fence.h         | 47 +++++++++++++++++++++
 src/d3d11/meson.build           |  1 +
 6 files changed, 162 insertions(+), 12 deletions(-)
 create mode 100644 src/d3d11/d3d11_fence.cpp
 create mode 100644 src/d3d11/d3d11_fence.h

diff --git a/src/d3d11/d3d11_context_imm.cpp b/src/d3d11/d3d11_context_imm.cpp
index 0ff64e25e7..adde00aeef 100644
--- a/src/d3d11/d3d11_context_imm.cpp
+++ b/src/d3d11/d3d11_context_imm.cpp
@@ -1,6 +1,7 @@
 #include "d3d11_cmdlist.h"
 #include "d3d11_context_imm.h"
 #include "d3d11_device.h"
+#include "d3d11_fence.h"
 #include "d3d11_texture.h"
 
 constexpr static uint32_t MinFlushIntervalUs = 750;
@@ -185,16 +186,41 @@ namespace dxvk {
   HRESULT STDMETHODCALLTYPE D3D11ImmediateContext::Signal(
           ID3D11Fence*                pFence,
           UINT64                      Value) {
-    Logger::err("D3D11ImmediateContext::Signal: Not implemented");
-    return E_NOTIMPL;
+    auto fence = static_cast<D3D11Fence*>(pFence);
+
+    if (!fence)
+      return E_INVALIDARG;
+
+    EmitCs([
+      cFence = fence->GetFence(),
+      cValue = Value
+    ] (DxvkContext* ctx) {
+      ctx->signalFence(cFence, cValue);
+    });
+
+    Flush();
+    return S_OK;
   }
 
 
   HRESULT STDMETHODCALLTYPE D3D11ImmediateContext::Wait(
           ID3D11Fence*                pFence,
           UINT64                      Value) {
-    Logger::err("D3D11ImmediateContext::Wait: Not implemented");
-    return E_NOTIMPL;
+    auto fence = static_cast<D3D11Fence*>(pFence);
+
+    if (!fence)
+      return E_INVALIDARG;
+
+    Flush();
+
+    EmitCs([
+      cFence = fence->GetFence(),
+      cValue = Value
+    ] (DxvkContext* ctx) {
+      ctx->waitFence(cFence, cValue);
+    });
+
+    return S_OK;
   }
 
 
diff --git a/src/d3d11/d3d11_device.cpp b/src/d3d11/d3d11_device.cpp
index 09f3559ab7..3e7abd9eaf 100644
--- a/src/d3d11/d3d11_device.cpp
+++ b/src/d3d11/d3d11_device.cpp
@@ -12,6 +12,7 @@
 #include "d3d11_context_def.h"
 #include "d3d11_context_imm.h"
 #include "d3d11_device.h"
+#include "d3d11_fence.h"
 #include "d3d11_input_layout.h"
 #include "d3d11_interop.h"
 #include "d3d11_query.h"
@@ -1347,16 +1348,17 @@ namespace dxvk {
   HRESULT STDMETHODCALLTYPE D3D11Device::CreateFence(
           UINT64                      InitialValue,
           D3D11_FENCE_FLAG            Flags,
-          REFIID                      ReturnedInterface,
+          REFIID                      riid,
           void**                      ppFence) {
     InitReturnPtr(ppFence);
 
-    static bool s_errorShown = false;
-
-    if (!std::exchange(s_errorShown, true))
-      Logger::err("D3D11Device::CreateFence: Not implemented");
-    
-    return E_NOTIMPL;
+    try {
+      Com<D3D11Fence> fence = new D3D11Fence(this, InitialValue, Flags);
+      return fence->QueryInterface(riid, ppFence);
+    } catch (const DxvkError& e) {
+      Logger::err(e.message());
+      return E_FAIL;
+    }
   }
 
 
@@ -1938,6 +1940,8 @@ namespace dxvk {
     enabled.extVertexAttributeDivisor.vertexAttributeInstanceRateDivisor      = supported.extVertexAttributeDivisor.vertexAttributeInstanceRateDivisor;
     enabled.extVertexAttributeDivisor.vertexAttributeInstanceRateZeroDivisor  = supported.extVertexAttributeDivisor.vertexAttributeInstanceRateZeroDivisor;
     
+    enabled.khrTimelineSemaphore.timelineSemaphore                = supported.khrTimelineSemaphore.timelineSemaphore;
+
     if (supported.extCustomBorderColor.customBorderColorWithoutFormat) {
       enabled.extCustomBorderColor.customBorderColors             = VK_TRUE;
       enabled.extCustomBorderColor.customBorderColorWithoutFormat = VK_TRUE;
diff --git a/src/d3d11/d3d11_device.h b/src/d3d11/d3d11_device.h
index 7643f8f4be..5a99bd62a1 100644
--- a/src/d3d11/d3d11_device.h
+++ b/src/d3d11/d3d11_device.h
@@ -260,7 +260,7 @@ namespace dxvk {
     HRESULT STDMETHODCALLTYPE CreateFence(
             UINT64                      InitialValue,
             D3D11_FENCE_FLAG            Flags,
-            REFIID                      ReturnedInterface,
+            REFIID                      riid,
             void**                      ppFence);
 
     void STDMETHODCALLTYPE ReadFromSubresource(
diff --git a/src/d3d11/d3d11_fence.cpp b/src/d3d11/d3d11_fence.cpp
new file mode 100644
index 0000000000..3c802f8981
--- /dev/null
+++ b/src/d3d11/d3d11_fence.cpp
@@ -0,0 +1,72 @@
+#include "d3d11_fence.h"
+#include "d3d11_device.h"
+
+namespace dxvk {
+  
+  D3D11Fence::D3D11Fence(
+          D3D11Device*        pDevice,
+          UINT64              InitialValue,
+          D3D11_FENCE_FLAG    Flags)
+  : D3D11DeviceChild<ID3D11Fence>(pDevice) {
+    DxvkFenceCreateInfo fenceInfo;
+    fenceInfo.initialValue = InitialValue;
+
+    if (Flags)
+      Logger::err(str::format("Fence flags 0x", std::hex, Flags, " not supported"));
+
+    m_fence = pDevice->GetDXVKDevice()->createFence(fenceInfo);
+  }
+
+
+  D3D11Fence::~D3D11Fence() {
+
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11Fence::QueryInterface(
+          REFIID              riid,
+          void**              ppvObject) {
+    if (ppvObject == nullptr)
+      return E_POINTER;
+
+    *ppvObject = nullptr;
+    
+    if (riid == __uuidof(IUnknown)
+     || riid == __uuidof(ID3D11DeviceChild)
+     || riid == __uuidof(ID3D11Fence)) {
+      *ppvObject = ref(this);
+      return S_OK;
+    }
+
+    Logger::warn("D3D11Fence: Unknown interface query");
+    Logger::warn(str::format(riid));
+    return E_NOINTERFACE;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11Fence::CreateSharedHandle(
+    const SECURITY_ATTRIBUTES* pAttributes,
+          DWORD               dwAccess,
+          LPCWSTR             lpName,
+          HANDLE*             pHandle) {
+    Logger::err("D3D11Fence::CreateSharedHandle: Not implemented");
+    return E_NOTIMPL;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11Fence::SetEventOnCompletion(
+          UINT64              Value,
+          HANDLE              hEvent) {
+    m_fence->enqueueWait(Value, [hEvent] {
+      SetEvent(hEvent);
+    });
+
+    return S_OK;
+  }
+
+
+  UINT64 STDMETHODCALLTYPE D3D11Fence::GetCompletedValue() {
+    return m_fence->getValue();
+  }
+  
+}
diff --git a/src/d3d11/d3d11_fence.h b/src/d3d11/d3d11_fence.h
new file mode 100644
index 0000000000..b29c0c999e
--- /dev/null
+++ b/src/d3d11/d3d11_fence.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../dxvk/dxvk_fence.h"
+#include "../dxvk/dxvk_gpu_query.h"
+
+#include "d3d11_device_child.h"
+
+namespace dxvk {
+  
+  class D3D11Fence : public D3D11DeviceChild<ID3D11Fence> {
+
+  public:
+    
+    D3D11Fence(
+            D3D11Device*        pDevice,
+            UINT64              InitialValue,
+            D3D11_FENCE_FLAG    Flags);
+
+    ~D3D11Fence();
+    
+    HRESULT STDMETHODCALLTYPE QueryInterface(
+            REFIID              riid,
+            void**              ppvObject);
+
+    HRESULT STDMETHODCALLTYPE CreateSharedHandle(
+      const SECURITY_ATTRIBUTES* pAttributes,
+            DWORD               dwAccess,
+            LPCWSTR             lpName,
+            HANDLE*             pHandle);
+
+    HRESULT STDMETHODCALLTYPE SetEventOnCompletion(
+            UINT64              Value,
+            HANDLE              hEvent);
+
+    UINT64 STDMETHODCALLTYPE GetCompletedValue();
+
+    Rc<DxvkFence> GetFence() const {
+      return m_fence;
+    }
+    
+  private:
+    
+    Rc<DxvkFence> m_fence;
+
+  };
+  
+}
diff --git a/src/d3d11/meson.build b/src/d3d11/meson.build
index ad35acd8e3..85fe780748 100644
--- a/src/d3d11/meson.build
+++ b/src/d3d11/meson.build
@@ -37,6 +37,7 @@ d3d11_src = [
   'd3d11_depth_stencil.cpp',
   'd3d11_device.cpp',
   'd3d11_enums.cpp',
+  'd3d11_fence.cpp',
   'd3d11_gdi.cpp',
   'd3d11_initializer.cpp',
   'd3d11_input_layout.cpp',

From 52bae6952c4b5ef03c5d2b9245e7fe4ce3c41067 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 25 Mar 2022 11:00:08 -0400
Subject: [PATCH 6/6] [d3d11] Implement ID3D11Fence sharing.

---
 src/d3d11/d3d11_context_imm.cpp |  54 ++++++++----
 src/d3d11/d3d11_device.cpp      |  21 ++++-
 src/d3d11/d3d11_fence.cpp       |  99 ++++++++++++++++++++-
 src/d3d11/d3d11_fence.h         |  51 ++++++++++-
 src/d3d11/meson.build           |   1 +
 src/d3d11/shared_fence.c        | 149 ++++++++++++++++++++++++++++++++
 src/d3d11/shared_fence.h        |  19 ++++
 7 files changed, 372 insertions(+), 22 deletions(-)
 create mode 100644 src/d3d11/shared_fence.c
 create mode 100644 src/d3d11/shared_fence.h

diff --git a/src/d3d11/d3d11_context_imm.cpp b/src/d3d11/d3d11_context_imm.cpp
index adde00aeef..7162c9e665 100644
--- a/src/d3d11/d3d11_context_imm.cpp
+++ b/src/d3d11/d3d11_context_imm.cpp
@@ -186,17 +186,29 @@ namespace dxvk {
   HRESULT STDMETHODCALLTYPE D3D11ImmediateContext::Signal(
           ID3D11Fence*                pFence,
           UINT64                      Value) {
-    auto fence = static_cast<D3D11Fence*>(pFence);
+    auto fence = dynamic_cast<D3D11Fence*>(pFence);
+    auto sharedFence = dynamic_cast<D3D11SharedFence*>(pFence);
 
-    if (!fence)
+    if (!fence && !sharedFence)
       return E_INVALIDARG;
 
-    EmitCs([
-      cFence = fence->GetFence(),
-      cValue = Value
-    ] (DxvkContext* ctx) {
-      ctx->signalFence(cFence, cValue);
-    });
+    if (fence) {
+      EmitCs([
+        cFence = fence->GetFence(),
+        cValue = Value
+      ] (DxvkContext* ctx) {
+        ctx->signalFence(cFence, cValue);
+      });
+    } else if (sharedFence) {
+      sharedFence->AddRef();
+      EmitCs([
+        sharedFence,
+        cValue = Value
+      ] (DxvkContext *ctx) {
+        sharedFence->SignalVirtualValue(ctx, cValue);
+        sharedFence->Release();
+      });
+    }
 
     Flush();
     return S_OK;
@@ -206,19 +218,29 @@ namespace dxvk {
   HRESULT STDMETHODCALLTYPE D3D11ImmediateContext::Wait(
           ID3D11Fence*                pFence,
           UINT64                      Value) {
-    auto fence = static_cast<D3D11Fence*>(pFence);
+    auto fence = dynamic_cast<D3D11Fence*>(pFence);
+    auto sharedFence = dynamic_cast<D3D11SharedFence*>(pFence);
 
-    if (!fence)
+    if (!fence && !sharedFence)
       return E_INVALIDARG;
 
     Flush();
 
-    EmitCs([
-      cFence = fence->GetFence(),
-      cValue = Value
-    ] (DxvkContext* ctx) {
-      ctx->waitFence(cFence, cValue);
-    });
+    if (fence) {
+      EmitCs([
+        cFence = fence->GetFence(),
+        cValue = Value
+      ] (DxvkContext* ctx) {
+        ctx->waitFence(cFence, cValue);
+      });
+    } else if (sharedFence) {
+      EmitCs([
+        cFence = sharedFence->GetFence(),
+        cValue = Value
+      ] (DxvkContext *ctx) {
+        ::shared_fence_wait(cFence, nullptr, cValue);
+      });
+    }
 
     return S_OK;
   }
diff --git a/src/d3d11/d3d11_device.cpp b/src/d3d11/d3d11_device.cpp
index 3e7abd9eaf..ced3dc45b3 100644
--- a/src/d3d11/d3d11_device.cpp
+++ b/src/d3d11/d3d11_device.cpp
@@ -1353,8 +1353,13 @@ namespace dxvk {
     InitReturnPtr(ppFence);
 
     try {
-      Com<D3D11Fence> fence = new D3D11Fence(this, InitialValue, Flags);
-      return fence->QueryInterface(riid, ppFence);
+      if (Flags & D3D11_FENCE_FLAG_SHARED) {
+        Com<D3D11SharedFence> fence = new D3D11SharedFence(this, InitialValue, Flags);
+        return fence->QueryInterface(riid, ppFence);
+      } else {
+        Com<D3D11Fence> fence = new D3D11Fence(this, InitialValue, Flags);
+        return fence->QueryInterface(riid, ppFence);
+      }
     } catch (const DxvkError& e) {
       Logger::err(e.message());
       return E_FAIL;
@@ -1424,8 +1429,16 @@ namespace dxvk {
           void**      ppFence) {
     InitReturnPtr(ppFence);
 
-    Logger::err("D3D11Device::OpenSharedFence: Not implemented");
-    return E_NOTIMPL;
+    if (ppFence == nullptr)
+      return S_FALSE;
+
+    try {
+      Com<D3D11SharedFence> fence = new D3D11SharedFence(this, hFence);
+      return fence->QueryInterface(ReturnedInterface, ppFence);
+    } catch (const DxvkError& e) {
+      Logger::err(e.message());
+      return E_FAIL;
+    }
   }
 
 
diff --git a/src/d3d11/d3d11_fence.cpp b/src/d3d11/d3d11_fence.cpp
index 3c802f8981..d1995c0709 100644
--- a/src/d3d11/d3d11_fence.cpp
+++ b/src/d3d11/d3d11_fence.cpp
@@ -68,5 +68,102 @@ namespace dxvk {
   UINT64 STDMETHODCALLTYPE D3D11Fence::GetCompletedValue() {
     return m_fence->getValue();
   }
-  
+
+
+  D3D11SharedFence::D3D11SharedFence(
+          D3D11Device*        pDevice,
+          UINT64              InitialValue,
+          D3D11_FENCE_FLAG    Flags)
+  : D3D11DeviceChild<ID3D11Fence>(pDevice) {
+    m_fenceHandle = ::create_shared_fence(InitialValue);
+    m_fence = ::open_shared_fence(m_fenceHandle);
+
+    DxvkFenceCreateInfo fenceInfo;
+    m_physicalValue = fenceInfo.initialValue = 0;
+    m_physicalFence = pDevice->GetDXVKDevice()->createFence(fenceInfo);
+  }
+
+
+  D3D11SharedFence::D3D11SharedFence(
+          D3D11Device*        pDevice,
+          HANDLE              handle)
+  : D3D11DeviceChild<ID3D11Fence>(pDevice) {
+    if (!::DuplicateHandle(GetCurrentProcess(), handle, GetCurrentProcess(), &m_fenceHandle, 0, FALSE, DUPLICATE_SAME_ACCESS))
+      throw DxvkError(str::format("D3D11: Invalid shared fence handle: ", handle));
+    m_fence = ::open_shared_fence(m_fenceHandle);
+    if (!m_fence) {
+      ::CloseHandle(m_fenceHandle);
+      throw DxvkError(str::format("D3D11: Invalid shared fence handle: ", handle));
+    }
+
+    DxvkFenceCreateInfo fenceInfo;
+    m_physicalValue = fenceInfo.initialValue = 0;
+    m_physicalFence = pDevice->GetDXVKDevice()->createFence(fenceInfo);
+  }
+
+
+  D3D11SharedFence::~D3D11SharedFence() {
+
+  }
+
+  HRESULT STDMETHODCALLTYPE D3D11SharedFence::QueryInterface(
+          REFIID              riid,
+          void**              ppvObject) {
+    if (ppvObject == nullptr)
+      return E_POINTER;
+
+    *ppvObject = nullptr;
+
+    if (riid == __uuidof(IUnknown)
+     || riid == __uuidof(ID3D11DeviceChild)
+     || riid == __uuidof(ID3D11Fence)) {
+      *ppvObject = ref(this);
+      return S_OK;
+    }
+
+    Logger::warn("D3D11SharedFence: Unknown interface query");
+    Logger::warn(str::format(riid));
+    return E_NOINTERFACE;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SharedFence::CreateSharedHandle(
+    const SECURITY_ATTRIBUTES* pAttributes,
+          DWORD               dwAccess,
+          LPCWSTR             lpName,
+          HANDLE*             pHandle) {
+    if (pAttributes)
+      Logger::warn(str::format("CreateSharedHandle: attributes ", pAttributes, " not handled"));
+    if (dwAccess)
+      Logger::warn(str::format("CreateSharedHandle: access ", dwAccess, " not handled"));
+    if (lpName)
+      Logger::warn(str::format("CreateSharedHandle: name ", dxvk::str::fromws(lpName), " not handled"));
+
+    return ::DuplicateHandle(GetCurrentProcess(), m_fenceHandle, GetCurrentProcess(), pHandle, 0, FALSE, DUPLICATE_SAME_ACCESS) ? S_OK : E_FAIL;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SharedFence::SetEventOnCompletion(
+          UINT64              Value,
+          HANDLE              hEvent) {
+    return ::shared_fence_wait(m_fence, hEvent, Value) ? S_OK : E_FAIL;
+  }
+
+
+  UINT64 STDMETHODCALLTYPE D3D11SharedFence::GetCompletedValue() {
+    return ::shared_fence_get_value(m_fence);
+  }
+
+
+  void D3D11SharedFence::SignalVirtualValue(DxvkContext* ctx, uint64_t virtualValue)
+  {
+    uint64_t physValue = ++m_physicalValue;
+
+    m_physicalFence->enqueueWait(physValue, [this, virtualValue] {
+      ::shared_fence_signal(this->m_fence, virtualValue);
+    });
+
+    ctx->signalFence(m_physicalFence, physValue);
+  }
+
 }
diff --git a/src/d3d11/d3d11_fence.h b/src/d3d11/d3d11_fence.h
index b29c0c999e..5e9eeb8647 100644
--- a/src/d3d11/d3d11_fence.h
+++ b/src/d3d11/d3d11_fence.h
@@ -2,9 +2,12 @@
 
 #include "../dxvk/dxvk_fence.h"
 #include "../dxvk/dxvk_gpu_query.h"
+#include "../dxvk/dxvk_context.h"
 
 #include "d3d11_device_child.h"
 
+#include "shared_fence.h"
+
 namespace dxvk {
   
   class D3D11Fence : public D3D11DeviceChild<ID3D11Fence> {
@@ -43,5 +46,51 @@ namespace dxvk {
     Rc<DxvkFence> m_fence;
 
   };
-  
+
+  class D3D11SharedFence : public D3D11DeviceChild<ID3D11Fence> {
+
+  public:
+
+    D3D11SharedFence(
+            D3D11Device*     pDevice,
+            UINT64           InitialValue,
+            D3D11_FENCE_FLAG Flags);
+
+    D3D11SharedFence(
+            D3D11Device*     pDevice,
+            HANDLE           handle);
+
+    ~D3D11SharedFence();
+
+    HRESULT STDMETHODCALLTYPE QueryInterface(
+            REFIID              riid,
+            void**              ppvObject);
+
+    HRESULT STDMETHODCALLTYPE CreateSharedHandle(
+      const SECURITY_ATTRIBUTES* pAttributes,
+            DWORD               dwAccess,
+            LPCWSTR             lpName,
+            HANDLE*             pHandle);
+
+    HRESULT STDMETHODCALLTYPE SetEventOnCompletion(
+            UINT64              Value,
+            HANDLE              hEvent);
+
+    UINT64 STDMETHODCALLTYPE GetCompletedValue();
+
+    struct shared_fence* GetFence() const {
+      return m_fence;
+    }
+
+    void SignalVirtualValue(DxvkContext* ctx, uint64_t virtualValue);
+
+  private:
+
+    struct shared_fence* m_fence;
+    HANDLE m_fenceHandle;
+
+    Rc<DxvkFence> m_physicalFence;
+    std::atomic<uint64_t> m_physicalValue;
+  };
+
 }
diff --git a/src/d3d11/meson.build b/src/d3d11/meson.build
index 85fe780748..4efedc4ed8 100644
--- a/src/d3d11/meson.build
+++ b/src/d3d11/meson.build
@@ -59,6 +59,7 @@ d3d11_src = [
   'd3d11_view_rtv.cpp',
   'd3d11_view_srv.cpp',
   'd3d11_view_uav.cpp',
+  'shared_fence.c'
 ]
 
 d3d11_shaders = files([
diff --git a/src/d3d11/shared_fence.c b/src/d3d11/shared_fence.c
new file mode 100644
index 0000000000..a6167d4059
--- /dev/null
+++ b/src/d3d11/shared_fence.c
@@ -0,0 +1,149 @@
+#include "shared_fence.h"
+
+/* For now the implementation isn't cross-process.
+ * When fixing this, we just need to reimplement the blocking wait with an event handle,
+ * removing the need for the conditional variable, and use a win32 mutex instead of a critical section */
+
+#define MAX_WAIT_COUNT 100
+
+struct waiter_thread
+{
+    bool waiting, signaled;
+    HANDLE handle;
+    UINT64 value;
+};
+
+struct shared_fence
+{
+    DWORD pid;
+    UINT64 value;
+    CRITICAL_SECTION *cs;
+    CONDITION_VARIABLE *cv;
+    struct waiter_thread waiters[MAX_WAIT_COUNT];
+};
+
+HANDLE create_shared_fence(UINT64 initial_value)
+{
+    HANDLE mapping = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE | SEC_COMMIT, 0, sizeof(struct shared_fence), NULL);
+    struct shared_fence *fence = open_shared_fence(mapping);
+
+    fence->pid = GetCurrentProcessId();
+    fence->value = initial_value;
+    fence->cs = malloc(sizeof(*fence->cs));
+    fence->cv = malloc(sizeof(*fence->cv));
+    InitializeCriticalSection(fence->cs);
+    InitializeConditionVariable(fence->cv);
+
+    shared_fence_close(fence);
+
+    return mapping;
+}
+
+struct shared_fence *open_shared_fence(HANDLE handle)
+{
+    return MapViewOfFile(handle, FILE_MAP_WRITE, 0, 0, sizeof(struct shared_fence));
+}
+
+void shared_fence_close(struct shared_fence *fence)
+{
+    UnmapViewOfFile(fence);
+}
+
+UINT64 shared_fence_get_value(struct shared_fence *fence)
+{
+    UINT64 value;
+    EnterCriticalSection(fence->cs);
+    value = fence->value;
+    LeaveCriticalSection(fence->cs);
+    return value;
+}
+
+/* Equivalent of SetEventOnCompletion*/
+bool shared_fence_wait(struct shared_fence *fence, HANDLE handle, UINT64 value)
+{
+    struct waiter_thread *waiter;
+    unsigned int i;
+
+    if (fence->pid != GetCurrentProcessId())
+        return false;
+
+    EnterCriticalSection(fence->cs);
+
+    if (fence->value >= value)
+    {
+        LeaveCriticalSection(fence->cs);
+
+        if (handle != NULL && handle != INVALID_HANDLE_VALUE)
+            SetEvent(handle);
+
+        return true;
+    }
+
+    for (i = 0; i < MAX_WAIT_COUNT; i++)
+    {
+        waiter = &fence->waiters[i];
+
+        if (!waiter->waiting)
+        {
+            waiter->waiting = true;
+            waiter->signaled = false;
+            waiter->handle = handle;
+            waiter->value = value;
+            break;
+        }
+    }
+
+    if (i == MAX_WAIT_COUNT)
+    {
+        LeaveCriticalSection(fence->cs);
+        return false;
+    }
+
+    if (handle != NULL && handle != INVALID_HANDLE_VALUE)
+    {
+        LeaveCriticalSection(fence->cs);
+        return true;
+    }
+
+    while (!waiter->signaled)
+        SleepConditionVariableCS(fence->cv, fence->cs, INFINITE);
+
+    waiter->waiting = false;
+
+    LeaveCriticalSection(fence->cs);
+    return true;
+}
+
+bool shared_fence_signal(struct shared_fence *fence, UINT64 value)
+{
+    unsigned int i;
+
+    if (fence->pid != GetCurrentProcessId())
+        return false;
+
+    EnterCriticalSection(fence->cs);
+
+    fence->value = value;
+    for (i = 0; i < MAX_WAIT_COUNT; i++)
+    {
+        struct waiter_thread *waiter = &fence->waiters[i];
+
+        if (waiter->value <= value)
+        {
+            if (waiter->handle != NULL && waiter->handle != INVALID_HANDLE_VALUE)
+            {
+                SetEvent(waiter->handle);
+                waiter->waiting = false;
+            }
+            else
+            {
+                waiter->signaled = true;
+            }
+        }
+    }
+
+    WakeAllConditionVariable(fence->cv);
+    LeaveCriticalSection(fence->cs);
+
+    return true;
+}
diff --git a/src/d3d11/shared_fence.h b/src/d3d11/shared_fence.h
new file mode 100644
index 0000000000..ab34e0cb1a
--- /dev/null
+++ b/src/d3d11/shared_fence.h
@@ -0,0 +1,19 @@
+/* simple polytonic cross-process semaphore implementation */
+
+#include <windows.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+HANDLE create_shared_fence(UINT64 initial_value);
+struct shared_fence *open_shared_fence(HANDLE handle);
+void shared_fence_close(struct shared_fence *fence);
+UINT64 shared_fence_get_value(struct shared_fence *fence);
+bool shared_fence_wait(struct shared_fence *fence, HANDLE handle, UINT64 value);
+bool shared_fence_signal(struct shared_fence *fence, UINT64 value);
+
+#ifdef __cplusplus
+}
+#endif
