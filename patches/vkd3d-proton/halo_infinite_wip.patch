From 102e2dac3adcc028751df9fcc99cb21b55357a36 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Mon, 22 Nov 2021 15:00:26 +0100
Subject: [PATCH 01/42] vkd3d: Add more stringent validation for
 CreateCommandSignature.

The runtime is specified to validate certain things.
Also, be more robust against unsupported command signatures, since we
might need to draw/dispatch at an offset. Avoids hard GPU crashes.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c       | 115 +++++++++++++++++++++++++++++++++++--
 libs/vkd3d/device.c        |   5 +-
 libs/vkd3d/vkd3d_private.h |   4 +-
 3 files changed, 115 insertions(+), 9 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index cd63835c..44ec8c6f 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -9406,6 +9406,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
         return;
     }
 
+    /* Temporary workaround, since we cannot parse non-draw arguments yet. Point directly
+     * to the first argument. Should avoid hard crashes for now. */
+    arg_buffer_offset += sig_impl->argument_buffer_offset;
+
     for (i = 0; i < signature_desc->NumArgumentDescs; ++i)
     {
         const D3D12_INDIRECT_ARGUMENT_DESC *arg_desc = &signature_desc->pArgumentDescs[i];
@@ -12237,37 +12241,136 @@ CONST_VTBL struct ID3D12CommandSignatureVtbl d3d12_command_signature_vtbl =
     d3d12_command_signature_GetDevice,
 };
 
-HRESULT d3d12_command_signature_create(struct d3d12_device *device, const D3D12_COMMAND_SIGNATURE_DESC *desc,
+HRESULT d3d12_command_signature_create(struct d3d12_device *device, struct d3d12_root_signature *root_signature,
+        const D3D12_COMMAND_SIGNATURE_DESC *desc,
         struct d3d12_command_signature **signature)
 {
     struct d3d12_command_signature *object;
+    bool requires_root_signature = false;
+    uint32_t argument_buffer_offset = 0;
+    uint32_t signature_size = 0;
+    bool has_action = false;
     unsigned int i;
+    bool is_action;
     HRESULT hr;
 
     for (i = 0; i < desc->NumArgumentDescs; ++i)
     {
         const D3D12_INDIRECT_ARGUMENT_DESC *argument_desc = &desc->pArgumentDescs[i];
+        is_action = false;
+
         switch (argument_desc->Type)
         {
             case D3D12_INDIRECT_ARGUMENT_TYPE_DRAW:
+                argument_buffer_offset = signature_size;
+                signature_size += sizeof(D3D12_DRAW_ARGUMENTS);
+                is_action = true;
+                break;
+
             case D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED:
+                argument_buffer_offset = signature_size;
+                signature_size += sizeof(D3D12_DRAW_INDEXED_ARGUMENTS);
+                is_action = true;
+                break;
+
             case D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH:
+                argument_buffer_offset = signature_size;
+                signature_size += sizeof(D3D12_DISPATCH_ARGUMENTS);
+                is_action = true;
+                break;
+
             case D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH_RAYS:
-                if (i != desc->NumArgumentDescs - 1)
-                {
-                    WARN("Draw/dispatch must be the last element of a command signature.\n");
-                    return E_INVALIDARG;
-                }
+                argument_buffer_offset = signature_size;
+                signature_size += sizeof(D3D12_DISPATCH_RAYS_DESC);
+                is_action = true;
+                break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH_MESH:
+                argument_buffer_offset = signature_size;
+                signature_size += sizeof(D3D12_DISPATCH_MESH_ARGUMENTS);
+                is_action = true;
+                FIXME("Unsupported indirect dispatch mesh.\n");
                 break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT:
+                requires_root_signature = true;
+                signature_size += argument_desc->Constant.Num32BitValuesToSet * sizeof(uint32_t);
+                FIXME("Unsupported indirect argument type CONSTANT.\n");
+                break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW:
+            case D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW:
+            case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW:
+                requires_root_signature = true;
+                /* The command signature payload is *not* aligned. */
+                signature_size += sizeof(D3D12_GPU_VIRTUAL_ADDRESS);
+                FIXME("Unsupported indirect root descriptor type: %u.\n", argument_desc->Type);
+                break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW:
+                /* The command signature payload is *not* aligned. */
+                signature_size += sizeof(D3D12_VERTEX_BUFFER_VIEW);
+                FIXME("Unsupported indirect VBV.\n");
+                break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW:
+                /* The command signature payload is *not* aligned. */
+                signature_size += sizeof(D3D12_INDEX_BUFFER_VIEW);
+                FIXME("Unsupported indirect IBV.\n");
+                break;
+
             default:
+                FIXME("Unsupported indirect argument type: %u.\n", argument_desc->Type);
                 break;
         }
+
+        if (is_action)
+        {
+            if (has_action)
+            {
+                ERR("Using multiple action commands per command signature is invalid.\n");
+                return E_INVALIDARG;
+            }
+
+            if (i != desc->NumArgumentDescs - 1)
+            {
+                WARN("Action command must be the last element of a command signature.\n");
+                return E_INVALIDARG;
+            }
+
+            has_action = true;
+        }
+    }
+
+    if (!has_action)
+    {
+        ERR("Command signature must have exactly one action command.\n");
+        return E_INVALIDARG;
+    }
+
+    if (desc->ByteStride < signature_size)
+    {
+        ERR("Command signature stride %u must be at least %u bytes.\n",
+                desc->ByteStride, signature_size);
+        return E_INVALIDARG;
+    }
+
+    if (requires_root_signature && !root_signature)
+    {
+        ERR("Command signature requires root signature, but is not provided.\n");
+        return E_INVALIDARG;
+    }
+    else if (!requires_root_signature && root_signature)
+    {
+        ERR("Command signature requires root signature, root signature must be NULL.\n");
+        return E_INVALIDARG;
     }
 
     if (!(object = vkd3d_malloc(sizeof(*object))))
         return E_OUTOFMEMORY;
 
     object->ID3D12CommandSignature_iface.lpVtbl = &d3d12_command_signature_vtbl;
+    object->argument_buffer_offset = argument_buffer_offset;
     object->refcount = 1;
 
     object->desc = *desc;
diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index 6e70a806..e6135471 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -4467,9 +4467,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_SetStablePowerState(d3d12_device_i
 }
 
 static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandSignature(d3d12_device_iface *iface,
-        const D3D12_COMMAND_SIGNATURE_DESC *desc, ID3D12RootSignature *root_signature,
+        const D3D12_COMMAND_SIGNATURE_DESC *desc, ID3D12RootSignature *root_signature_iface,
         REFIID iid, void **command_signature)
 {
+    struct d3d12_root_signature *root_signature = impl_from_ID3D12RootSignature(root_signature_iface);
     struct d3d12_device *device = impl_from_ID3D12Device(iface);
     struct d3d12_command_signature *object;
     HRESULT hr;
@@ -4477,7 +4478,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandSignature(d3d12_devic
     TRACE("iface %p, desc %p, root_signature %p, iid %s, command_signature %p.\n",
             iface, desc, root_signature, debugstr_guid(iid), command_signature);
 
-    if (FAILED(hr = d3d12_command_signature_create(device, desc, &object)))
+    if (FAILED(hr = d3d12_command_signature_create(device, root_signature, desc, &object)))
         return hr;
 
     return return_interface(&object->ID3D12CommandSignature_iface,
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index f9981ce5..21629b59 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -2366,13 +2366,15 @@ struct d3d12_command_signature
     LONG refcount;
 
     D3D12_COMMAND_SIGNATURE_DESC desc;
+    uint32_t argument_buffer_offset;
 
     struct d3d12_device *device;
 
     struct vkd3d_private_store private_store;
 };
 
-HRESULT d3d12_command_signature_create(struct d3d12_device *device, const D3D12_COMMAND_SIGNATURE_DESC *desc,
+HRESULT d3d12_command_signature_create(struct d3d12_device *device, struct d3d12_root_signature *root_signature,
+        const D3D12_COMMAND_SIGNATURE_DESC *desc,
         struct d3d12_command_signature **signature);
 
 static inline struct d3d12_command_signature *impl_from_ID3D12CommandSignature(ID3D12CommandSignature *iface)
-- 
2.36.1

From 33bad640abe5b584d4ca136637382700aa3756b6 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 19 Nov 2021 15:43:33 +0100
Subject: [PATCH 02/42] tests: Add test for advanced ExecuteIndirect features.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 tests/d3d12_command.c | 588 ++++++++++++++++++++++++++++++++++++++++++
 tests/d3d12_tests.h   |   1 +
 2 files changed, 589 insertions(+)

diff --git a/tests/d3d12_command.c b/tests/d3d12_command.c
index 32f3f511..00618940 100644
--- a/tests/d3d12_command.c
+++ b/tests/d3d12_command.c
@@ -1449,6 +1449,594 @@ void test_vbv_stride_edge_cases(void)
     destroy_test_context(&context);
 }
 
+void test_execute_indirect_state(void)
+{
+    static const struct vec4 values = { 1000.0f, 2000.0f, 3000.0f, 4000.0f };
+    D3D12_INDIRECT_ARGUMENT_DESC indirect_argument_descs[2];
+    D3D12_COMMAND_SIGNATURE_DESC command_signature_desc;
+    D3D12_ROOT_SIGNATURE_DESC root_signature_desc;
+    D3D12_GRAPHICS_PIPELINE_STATE_DESC pso_desc;
+    ID3D12CommandSignature *command_signature;
+    D3D12_SO_DECLARATION_ENTRY so_entries[1];
+    ID3D12GraphicsCommandList *command_list;
+    D3D12_ROOT_PARAMETER root_parameters[4];
+    D3D12_STREAM_OUTPUT_BUFFER_VIEW sov;
+    ID3D12Resource *streamout_buffer;
+    D3D12_VERTEX_BUFFER_VIEW vbvs[2];
+    ID3D12Resource *argument_buffer;
+    struct test_context_desc desc;
+    ID3D12Resource *count_buffer;
+    struct test_context context;
+    struct resource_readback rb;
+    D3D12_INDEX_BUFFER_VIEW ibv;
+    ID3D12CommandQueue *queue;
+    const UINT so_stride = 16;
+    ID3D12PipelineState *pso;
+    ID3D12Resource *vbo[3];
+    ID3D12Resource *ibo[2];
+    unsigned int i, j, k;
+    ID3D12Resource *cbv;
+    ID3D12Resource *srv;
+    ID3D12Resource *uav;
+    HRESULT hr;
+
+    static const D3D12_INPUT_ELEMENT_DESC layout_desc[] =
+    {
+        {"COLOR", 0, DXGI_FORMAT_R32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0},
+        {"COLOR", 1, DXGI_FORMAT_R32_FLOAT, 1, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0},
+    };
+
+    struct test
+    {
+        const D3D12_INDIRECT_ARGUMENT_DESC *indirect_arguments;
+        uint32_t indirect_argument_count;
+        const void *argument_buffer_data;
+        size_t argument_buffer_size;
+        uint32_t api_max_count;
+        const struct vec4 *expected_output;
+        uint32_t expected_output_count;
+        uint32_t stride;
+        bool needs_root_sig;
+    };
+
+    /* Modify root parameters. */
+    struct root_constant_data
+    {
+        float constants[2];
+        D3D12_DRAW_INDEXED_ARGUMENTS indexed;
+    };
+
+    static const D3D12_INDIRECT_ARGUMENT_DESC root_constant_sig[2] =
+    {
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT, .Constant = {
+            .RootParameterIndex = 0, .DestOffsetIn32BitValues = 1, .Num32BitValuesToSet = 2 }},
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED }
+    };
+
+    static const struct root_constant_data root_constant_data[] =
+    {
+        {
+            .constants = { 100.0f, 500.0f },
+            .indexed = { .IndexCountPerInstance = 2, .InstanceCount = 1 }
+        },
+        {
+            .constants = { 200.0f, 800.0f },
+            .indexed = { .IndexCountPerInstance = 1, .InstanceCount = 2,
+                         .StartIndexLocation = 1, .StartInstanceLocation = 100, }
+        },
+    };
+
+    static const struct vec4 root_constant_expected[] =
+    {
+        { 1000.0f, 64.0f + 100.0f, 500.0f, 4000.0f },
+        { 1001.0f, 65.0f + 100.0f, 500.0f, 4000.0f },
+        { 1001.0f, 65.0f + 200.0f, 800.0f, 4000.0f },
+        { 1001.0f, 65.0f + 200.0f, 800.0f, 4001.0f },
+    };
+
+    /* Modify VBOs. */
+    struct indirect_vbo_data
+    {
+        D3D12_VERTEX_BUFFER_VIEW view[2];
+        D3D12_DRAW_INDEXED_ARGUMENTS indexed;
+    };
+
+    static const D3D12_INDIRECT_ARGUMENT_DESC indirect_vbo_sig[3] =
+    {
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW, .VertexBuffer = { .Slot = 0 }},
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW, .VertexBuffer = { .Slot = 1 }},
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED },
+    };
+
+    /* Fill buffer locations later. */
+    struct indirect_vbo_data indirect_vbo_data[] =
+    {
+        {
+            .view = { { 0, 64, 8 }, { 0, 64, 16 } },
+            .indexed = { .IndexCountPerInstance = 2, .InstanceCount = 2 }
+        },
+        {
+            /* Test indirectly binding NULL descriptor and 0 stride. */
+            .view = { { 0, 0, 0 }, { 0, 64, 0 } },
+            .indexed = { .IndexCountPerInstance = 2, .InstanceCount = 1 }
+        }
+    };
+
+    static const struct vec4 indirect_vbo_expected[] =
+    {
+        { 1064.0f, 2128.0f, 3000.0f, 4000.0f },
+        { 1066.0f, 2132.0f, 3000.0f, 4000.0f },
+        { 1064.0f, 2128.0f, 3000.0f, 4001.0f },
+        { 1066.0f, 2132.0f, 3000.0f, 4001.0f },
+        { 1000.0f, 2016.0f, 3000.0f, 4000.0f }, /* This is buggy on WARP and AMD. We seem to get null descriptor instead. */
+        { 1000.0f, 2016.0f, 3000.0f, 4000.0f }, /* This is buggy on WARP and AMD. */
+    };
+
+    /* Modify just one VBO. */
+    struct indirect_vbo_one_data
+    {
+        D3D12_VERTEX_BUFFER_VIEW view;
+        D3D12_DRAW_INDEXED_ARGUMENTS indexed;
+    };
+
+    static const D3D12_INDIRECT_ARGUMENT_DESC indirect_vbo_one_sig[2] =
+    {
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW, .VertexBuffer = { .Slot = 0 }},
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED },
+    };
+
+    /* Fill buffer locations later. */
+    struct indirect_vbo_one_data indirect_vbo_one_data[] =
+    {
+        {
+            .view = { 0, 64, 8 },
+            .indexed = { .IndexCountPerInstance = 2, .InstanceCount = 1 }
+        },
+        {
+            .indexed = { .IndexCountPerInstance = 1, .InstanceCount = 1 }
+        }
+    };
+
+    static const struct vec4 indirect_vbo_one_expected[] =
+    {
+        { 1128.0f, 2064.0f, 3000.0f, 4000.0f },
+        { 1130.0f, 2065.0f, 3000.0f, 4000.0f },
+        { 1000.0f, 2064.0f, 3000.0f, 4000.0f },
+    };
+
+    /* Indirect IBO */
+    struct indirect_ibo_data
+    {
+        D3D12_INDEX_BUFFER_VIEW view;
+        D3D12_DRAW_INDEXED_ARGUMENTS indexed;
+    };
+
+    static const D3D12_INDIRECT_ARGUMENT_DESC indirect_ibo_sig[2] =
+    {
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW },
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED },
+    };
+
+    struct indirect_ibo_data indirect_ibo_data[] =
+    {
+        {
+            .view = { 0, 0, DXGI_FORMAT_R32_UINT },
+            .indexed = { .IndexCountPerInstance = 2, .InstanceCount = 1 }
+        },
+        {
+            .view = { 0, 64, DXGI_FORMAT_R16_UINT },
+            .indexed = { .IndexCountPerInstance = 4, .InstanceCount = 1 }
+        },
+    };
+
+    static const struct vec4 indirect_ibo_expected[] =
+    {
+        { 1000.0f, 2064.0f, 3000.0f, 4000.0f },
+        { 1000.0f, 2064.0f, 3000.0f, 4000.0f },
+        { 1016.0f, 2080.0f, 3000.0f, 4000.0f },
+        { 1000.0f, 2064.0f, 3000.0f, 4000.0f },
+        { 1017.0f, 2081.0f, 3000.0f, 4000.0f },
+        { 1000.0f, 2064.0f, 3000.0f, 4000.0f },
+    };
+
+    /* Indirect root arguments */
+    struct indirect_root_descriptor_data
+    {
+        D3D12_GPU_VIRTUAL_ADDRESS cbv;
+        D3D12_GPU_VIRTUAL_ADDRESS srv;
+        D3D12_GPU_VIRTUAL_ADDRESS uav;
+        D3D12_DRAW_ARGUMENTS array;
+    };
+
+    static const D3D12_INDIRECT_ARGUMENT_DESC indirect_root_descriptor_sig[4] =
+    {
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW, .ConstantBufferView = { .RootParameterIndex = 1 } },
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW, .ShaderResourceView = { .RootParameterIndex = 2 } },
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW, .UnorderedAccessView = { .RootParameterIndex = 3 } },
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW },
+    };
+
+    struct indirect_root_descriptor_data indirect_root_descriptor_data[] =
+    {
+        { .array = { .VertexCountPerInstance = 1, .InstanceCount = 1 } },
+        { .array = { .VertexCountPerInstance = 1, .InstanceCount = 1 } },
+    };
+
+    static const struct vec4 indirect_root_descriptor_expected[] =
+    {
+        { 1000.0f, 2064.0f, 3000.0f + 64.0f, 4000.0f + 2.0f },
+        { 1000.0f, 2064.0f, 3000.0f + 128.0f, 4000.0f + 3.0f },
+    };
+
+    /* Test packing rules.
+     * 64-bit aligned values are tightly packed with 32-bit alignment when they are in indirect command buffers. */
+    struct indirect_alignment_data
+    {
+        float value;
+        uint32_t cbv_va[2];
+        D3D12_DRAW_ARGUMENTS arrays;
+    };
+    static const D3D12_INDIRECT_ARGUMENT_DESC indirect_alignment_sig[3] =
+    {
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT, .Constant = {
+                .RootParameterIndex = 0, .DestOffsetIn32BitValues = 1, .Num32BitValuesToSet = 1 }},
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW, .ConstantBufferView = { .RootParameterIndex = 1 }},
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW },
+    };
+
+    struct indirect_alignment_data indirect_alignment_data[] =
+    {
+        {
+            .value = 5.0f,
+            .arrays = { .VertexCountPerInstance = 1, .InstanceCount = 1 }
+        },
+        {
+            .value = 6.0f,
+            .arrays = { .VertexCountPerInstance = 1, .InstanceCount = 1 }
+        },
+    };
+
+    static const struct vec4 indirect_alignment_expected[] =
+    {
+        { 1000.0f, 69.0f, 3064.0f, 4000.0f },
+        { 1000.0f, 70.0f, 3128.0f, 4000.0f },
+    };
+
+#define DECL_TEST(t, needs_root_sig) { t##_sig, ARRAY_SIZE(t##_sig), t##_data, sizeof(t##_data), ARRAY_SIZE(t##_data), \
+        t##_expected, ARRAY_SIZE(t##_expected), sizeof(*(t##_data)), needs_root_sig }
+    const struct test tests[] =
+    {
+        DECL_TEST(root_constant, true),
+        DECL_TEST(indirect_vbo, false),
+        DECL_TEST(indirect_vbo_one, false),
+        DECL_TEST(indirect_ibo, false),
+        DECL_TEST(indirect_root_descriptor, true),
+        DECL_TEST(indirect_alignment, true),
+    };
+#undef DECL_TEST
+
+    uint32_t ibo_data[ARRAY_SIZE(ibo)][64];
+    float vbo_data[ARRAY_SIZE(vbo)][64];
+    float generic_data[4096];
+
+    static const DWORD vs_code[] =
+    {
+#if 0
+    cbuffer RootCBV : register(b0)
+    {
+            float a;
+    };
+
+    StructuredBuffer<float> RootSRV : register(t0);
+
+    cbuffer RootConstants : register(b0, space1)
+    {
+            float4 root;
+    };
+
+    float4 main(float c0 : COLOR0, float c1 : COLOR1, uint iid : SV_InstanceID) : SV_Position
+    {
+            return float4(c0, c1, a, RootSRV[0] + float(iid)) + root;
+    }
+#endif
+        0x43425844, 0x33b7b302, 0x34259b9b, 0x3e8568d9, 0x5a5e0c3e, 0x00000001, 0x00000268, 0x00000003,
+        0x0000002c, 0x00000098, 0x000000cc, 0x4e475349, 0x00000064, 0x00000003, 0x00000008, 0x00000050,
+        0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000101, 0x00000050, 0x00000001, 0x00000000,
+        0x00000003, 0x00000001, 0x00000101, 0x00000056, 0x00000000, 0x00000008, 0x00000001, 0x00000002,
+        0x00000101, 0x4f4c4f43, 0x56530052, 0x736e495f, 0x636e6174, 0x00444965, 0x4e47534f, 0x0000002c,
+        0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000001, 0x00000003, 0x00000000, 0x0000000f,
+        0x505f5653, 0x7469736f, 0x006e6f69, 0x58454853, 0x00000194, 0x00010051, 0x00000065, 0x0100086a,
+        0x07000059, 0x00308e46, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x07000059,
+        0x00308e46, 0x00000001, 0x00000000, 0x00000000, 0x00000001, 0x00000001, 0x070000a2, 0x00307e46,
+        0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0x0300005f, 0x00101012, 0x00000000,
+        0x0300005f, 0x00101012, 0x00000001, 0x04000060, 0x00101012, 0x00000002, 0x00000008, 0x04000067,
+        0x001020f2, 0x00000000, 0x00000001, 0x02000068, 0x00000001, 0x0a0000a7, 0x00100012, 0x00000000,
+        0x00004001, 0x00000000, 0x00004001, 0x00000000, 0x00207006, 0x00000000, 0x00000000, 0x05000056,
+        0x00100022, 0x00000000, 0x0010100a, 0x00000002, 0x07000000, 0x00100012, 0x00000000, 0x0010001a,
+        0x00000000, 0x0010000a, 0x00000000, 0x09000000, 0x00102012, 0x00000000, 0x0010100a, 0x00000000,
+        0x0030800a, 0x00000001, 0x00000000, 0x00000000, 0x09000000, 0x00102022, 0x00000000, 0x0010100a,
+        0x00000001, 0x0030801a, 0x00000001, 0x00000000, 0x00000000, 0x0b000000, 0x00102042, 0x00000000,
+        0x0030800a, 0x00000000, 0x00000000, 0x00000000, 0x0030802a, 0x00000001, 0x00000000, 0x00000000,
+        0x09000000, 0x00102082, 0x00000000, 0x0010000a, 0x00000000, 0x0030803a, 0x00000001, 0x00000000,
+        0x00000000, 0x0100003e,
+    };
+
+    memset(&desc, 0, sizeof(desc));
+    desc.no_root_signature = true;
+    desc.no_pipeline = true;
+    if (!init_test_context(&context, &desc))
+        return;
+    command_list = context.list;
+    queue = context.queue;
+
+    for (j = 0; j < ARRAY_SIZE(ibo); j++)
+        for (i = 0; i < ARRAY_SIZE(ibo_data[j]); i++)
+            ibo_data[j][i] = j * 16 + i;
+
+    for (j = 0; j < ARRAY_SIZE(vbo); j++)
+        for (i = 0; i < ARRAY_SIZE(vbo_data[j]); i++)
+            vbo_data[j][i] = (float)(j * ARRAY_SIZE(vbo_data[j]) + i);
+
+    for (i = 0; i < ARRAY_SIZE(generic_data); i++)
+        generic_data[i] = (float)i;
+
+    for (i = 0; i < ARRAY_SIZE(ibo); i++)
+        ibo[i] = create_upload_buffer(context.device, sizeof(ibo_data[i]), ibo_data[i]);
+    for (i = 0; i < ARRAY_SIZE(vbo); i++)
+        vbo[i] = create_upload_buffer(context.device, sizeof(vbo_data[i]), vbo_data[i]);
+    cbv = create_upload_buffer(context.device, sizeof(generic_data), generic_data);
+    srv = create_upload_buffer(context.device, sizeof(generic_data), generic_data);
+    uav = create_default_buffer(context.device, sizeof(generic_data),
+            D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS,
+            D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
+
+    indirect_vbo_data[0].view[0].BufferLocation = ID3D12Resource_GetGPUVirtualAddress(vbo[1]);
+    indirect_vbo_data[0].view[1].BufferLocation = ID3D12Resource_GetGPUVirtualAddress(vbo[2]);
+    indirect_vbo_data[1].view[0].BufferLocation = 0;
+    indirect_vbo_data[1].view[1].BufferLocation = ID3D12Resource_GetGPUVirtualAddress(vbo[0]) + 64;
+
+    indirect_vbo_one_data[0].view.BufferLocation = ID3D12Resource_GetGPUVirtualAddress(vbo[2]);
+    indirect_vbo_one_data[1].view.BufferLocation = 0;
+
+    indirect_ibo_data[1].view.BufferLocation = ID3D12Resource_GetGPUVirtualAddress(ibo[1]);
+
+    indirect_root_descriptor_data[0].cbv = ID3D12Resource_GetGPUVirtualAddress(cbv) + 256;
+    indirect_root_descriptor_data[0].srv = ID3D12Resource_GetGPUVirtualAddress(srv) + 8;
+    indirect_root_descriptor_data[0].uav = ID3D12Resource_GetGPUVirtualAddress(uav) + 4;
+    indirect_root_descriptor_data[1].cbv = ID3D12Resource_GetGPUVirtualAddress(cbv) + 512;
+    indirect_root_descriptor_data[1].srv = ID3D12Resource_GetGPUVirtualAddress(srv) + 12;
+    indirect_root_descriptor_data[1].uav = ID3D12Resource_GetGPUVirtualAddress(uav) + 8;
+
+    memcpy(indirect_alignment_data[0].cbv_va, &indirect_root_descriptor_data[0].cbv, sizeof(D3D12_GPU_VIRTUAL_ADDRESS));
+    memcpy(indirect_alignment_data[1].cbv_va, &indirect_root_descriptor_data[1].cbv, sizeof(D3D12_GPU_VIRTUAL_ADDRESS));
+
+    memset(&root_signature_desc, 0, sizeof(root_signature_desc));
+    root_signature_desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |
+            D3D12_ROOT_SIGNATURE_FLAG_ALLOW_STREAM_OUTPUT;
+
+    memset(root_parameters, 0, sizeof(root_parameters));
+    root_signature_desc.pParameters = root_parameters;
+    root_signature_desc.NumParameters = ARRAY_SIZE(root_parameters);
+    root_parameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
+    root_parameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS;
+    root_parameters[0].Constants.RegisterSpace = 1;
+    root_parameters[0].Constants.Num32BitValues = 4;
+    root_parameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
+    root_parameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
+    root_parameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
+    root_parameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_SRV;
+    root_parameters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
+    root_parameters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_UAV;
+    hr = create_root_signature(context.device, &root_signature_desc, &context.root_signature);
+    ok(SUCCEEDED(hr), "Failed to create root signature, hr #%x.\n", hr);
+
+    memset(so_entries, 0, sizeof(so_entries));
+    so_entries[0].ComponentCount = 4;
+    so_entries[0].SemanticName = "SV_Position";
+
+    memset(&pso_desc, 0, sizeof(pso_desc));
+    pso_desc.VS.pShaderBytecode = vs_code;
+    pso_desc.VS.BytecodeLength = sizeof(vs_code);
+    pso_desc.StreamOutput.NumStrides = 1;
+    pso_desc.StreamOutput.pBufferStrides = &so_stride;
+    pso_desc.StreamOutput.pSODeclaration = so_entries;
+    pso_desc.StreamOutput.NumEntries = ARRAY_SIZE(so_entries);
+    pso_desc.StreamOutput.RasterizedStream = D3D12_SO_NO_RASTERIZED_STREAM;
+    pso_desc.pRootSignature = context.root_signature;
+    pso_desc.SampleDesc.Count = 1;
+    pso_desc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT;
+    pso_desc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID;
+    pso_desc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
+    pso_desc.InputLayout.NumElements = ARRAY_SIZE(layout_desc);
+    pso_desc.InputLayout.pInputElementDescs = layout_desc;
+    hr = ID3D12Device_CreateGraphicsPipelineState(context.device, &pso_desc, &IID_ID3D12PipelineState, (void**)&pso);
+    ok(SUCCEEDED(hr), "Failed to create PSO, hr #%x.\n", hr);
+
+    /* Verify sanity checks.
+     * As per validation layers, there must be exactly one command in the signature.
+     * It must come last. Verify that we check for this. */
+    memset(&command_signature_desc, 0, sizeof(command_signature_desc));
+    command_signature_desc.NumArgumentDescs = 1;
+    command_signature_desc.pArgumentDescs = indirect_argument_descs;
+    command_signature_desc.ByteStride = sizeof(D3D12_VERTEX_BUFFER_VIEW);
+    indirect_argument_descs[0].Type = D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW;
+    hr = ID3D12Device_CreateCommandSignature(context.device, &command_signature_desc, NULL,
+            &IID_ID3D12CommandSignature, (void**)&command_signature);
+    ok(hr == E_INVALIDARG, "Unexpected hr #%x.\n", hr);
+
+    command_signature_desc.NumArgumentDescs = 2;
+    command_signature_desc.pArgumentDescs = indirect_argument_descs;
+    command_signature_desc.ByteStride = sizeof(D3D12_DRAW_INDEXED_ARGUMENTS) + sizeof(D3D12_VERTEX_BUFFER_VIEW);
+    indirect_argument_descs[0].Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED;
+    indirect_argument_descs[1].Type = D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW;
+    hr = ID3D12Device_CreateCommandSignature(context.device, &command_signature_desc, NULL,
+            &IID_ID3D12CommandSignature, (void**)&command_signature);
+    ok(hr == E_INVALIDARG, "Unexpected hr #%x.\n", hr);
+
+    command_signature_desc.ByteStride = sizeof(D3D12_DRAW_INDEXED_ARGUMENTS) + sizeof(D3D12_DRAW_INDEXED_ARGUMENTS);
+    indirect_argument_descs[0].Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED;
+    indirect_argument_descs[1].Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED;
+    hr = ID3D12Device_CreateCommandSignature(context.device, &command_signature_desc, NULL,
+            &IID_ID3D12CommandSignature, (void**)&command_signature);
+    ok(hr == E_INVALIDARG, "Unexpected hr #%x.\n", hr);
+
+    for (i = 0; i < ARRAY_SIZE(tests); i++)
+    {
+        struct vec4 expect_reset_state[2];
+        const struct vec4 *expect, *v;
+        uint32_t expected_output_size;
+        uint32_t clear_vbo_mask;
+        bool clear_ibo;
+        uint32_t size;
+
+        vkd3d_test_set_context("Test %u", i);
+
+        command_signature_desc.ByteStride = tests[i].stride;
+        command_signature_desc.pArgumentDescs = tests[i].indirect_arguments;
+        command_signature_desc.NumArgumentDescs = tests[i].indirect_argument_count;
+        command_signature_desc.NodeMask = 0;
+        hr = ID3D12Device_CreateCommandSignature(context.device, &command_signature_desc,
+                tests[i].needs_root_sig ? context.root_signature : NULL,
+                &IID_ID3D12CommandSignature, (void**)&command_signature);
+        ok(SUCCEEDED(hr), "Failed to create command signature, hr #%x.\n", hr);
+
+        argument_buffer = create_upload_buffer(context.device, 256 * 1024, NULL);
+        {
+            void *ptr;
+            ID3D12Resource_Map(argument_buffer, 0, NULL, &ptr);
+            memcpy(ptr, tests[i].argument_buffer_data, tests[i].argument_buffer_size);
+            ID3D12Resource_Unmap(argument_buffer, 0, NULL);
+        }
+
+        count_buffer = create_upload_buffer(context.device, sizeof(tests[i].api_max_count), &tests[i].api_max_count);
+        streamout_buffer = create_default_buffer(context.device, 64 * 1024,
+                D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_STREAM_OUT);
+
+        ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, context.root_signature);
+        ID3D12GraphicsCommandList_SetPipelineState(command_list, pso);
+        sov.SizeInBytes = 64 * 1024 - sizeof(struct vec4);
+        sov.BufferLocation = ID3D12Resource_GetGPUVirtualAddress(streamout_buffer) + sizeof(struct vec4);
+        sov.BufferFilledSizeLocation = ID3D12Resource_GetGPUVirtualAddress(streamout_buffer);
+        ID3D12GraphicsCommandList_SOSetTargets(command_list, 0, 1, &sov);
+
+        /* Set up default rendering state. */
+        ibv.BufferLocation = ID3D12Resource_GetGPUVirtualAddress(ibo[0]);
+        ibv.SizeInBytes = sizeof(ibo_data[0]);
+        ibv.Format = DXGI_FORMAT_R32_UINT;
+        vbvs[0].BufferLocation = ID3D12Resource_GetGPUVirtualAddress(vbo[0]);
+        vbvs[0].SizeInBytes = sizeof(vbo_data[0]);
+        vbvs[0].StrideInBytes = 4;
+        vbvs[1].BufferLocation = ID3D12Resource_GetGPUVirtualAddress(vbo[1]);
+        vbvs[1].SizeInBytes = sizeof(vbo_data[1]);
+        vbvs[1].StrideInBytes = 4;
+
+        ID3D12GraphicsCommandList_IASetIndexBuffer(command_list, &ibv);
+        ID3D12GraphicsCommandList_IASetPrimitiveTopology(command_list, D3D_PRIMITIVE_TOPOLOGY_POINTLIST);
+        ID3D12GraphicsCommandList_IASetVertexBuffers(command_list, 0, 2, vbvs);
+        ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstants(command_list, 0, 4, &values, 0);
+        ID3D12GraphicsCommandList_SetGraphicsRootConstantBufferView(command_list, 1,
+                ID3D12Resource_GetGPUVirtualAddress(cbv));
+        ID3D12GraphicsCommandList_SetGraphicsRootShaderResourceView(command_list, 2,
+                ID3D12Resource_GetGPUVirtualAddress(srv));
+        ID3D12GraphicsCommandList_SetGraphicsRootUnorderedAccessView(command_list, 3,
+                ID3D12Resource_GetGPUVirtualAddress(uav));
+        ID3D12GraphicsCommandList_ExecuteIndirect(command_list, command_signature, tests[i].api_max_count,
+                argument_buffer, 0, NULL, 0);
+        /* Test equivalent call with indirect count. */
+        ID3D12GraphicsCommandList_ExecuteIndirect(command_list, command_signature, 1024,
+                argument_buffer, 0, count_buffer, 0);
+
+        /* Root descriptors which are part of the state block are cleared to NULL. Recover them here
+         * since attempting to draw next test will crash GPU. */
+        ID3D12GraphicsCommandList_SetGraphicsRootConstantBufferView(command_list, 1,
+                ID3D12Resource_GetGPUVirtualAddress(cbv));
+        ID3D12GraphicsCommandList_SetGraphicsRootShaderResourceView(command_list, 2,
+                ID3D12Resource_GetGPUVirtualAddress(srv));
+        ID3D12GraphicsCommandList_SetGraphicsRootUnorderedAccessView(command_list, 3,
+                ID3D12Resource_GetGPUVirtualAddress(uav));
+
+        /* Other state is cleared to 0. */
+        ID3D12GraphicsCommandList_DrawIndexedInstanced(command_list, 2, 1, 0, 0, 0);
+        transition_resource_state(command_list, streamout_buffer, D3D12_RESOURCE_STATE_STREAM_OUT, D3D12_RESOURCE_STATE_COPY_SOURCE);
+
+        get_buffer_readback_with_command_list(streamout_buffer, DXGI_FORMAT_R32G32B32A32_FLOAT, &rb, queue, command_list);
+        reset_command_list(command_list, context.allocator);
+
+        expected_output_size = (tests[i].expected_output_count * 2 + 2) * sizeof(struct vec4);
+        size = get_readback_uint(&rb, 0, 0, 0);
+        ok(size == expected_output_size, "Expected size %u, got %u.\n", expected_output_size, size);
+
+        for (j = 0; j < tests[i].expected_output_count; j++)
+        {
+            expect = &tests[i].expected_output[j];
+            v = get_readback_vec4(&rb, j + 1, 0);
+            todo ok(compare_vec4(v, expect, 0), "Element (direct count) %u failed: (%f, %f, %f, %f) != (%f, %f, %f, %f)\n",
+                    j, v->x, v->y, v->z, v->w, expect->x, expect->y, expect->z, expect->w);
+
+            v = get_readback_vec4(&rb, j + tests[i].expected_output_count + 1, 0);
+            todo ok(compare_vec4(v, expect, 0), "Element (indirect count) %u failed: (%f, %f, %f, %f) != (%f, %f, %f, %f)\n",
+                    j, v->x, v->y, v->z, v->w, expect->x, expect->y, expect->z, expect->w);
+        }
+
+        clear_vbo_mask = 0;
+        clear_ibo = false;
+        expect_reset_state[0] = values;
+
+        /* Root constant state is cleared to zero if it's part of the signature. */
+        for (j = 0; j < tests[i].indirect_argument_count; j++)
+        {
+            if (tests[i].indirect_arguments[j].Type == D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT)
+            {
+                for (k = 0; k < tests[i].indirect_arguments[j].Constant.Num32BitValuesToSet; k++)
+                    (&expect_reset_state[0].x)[tests[i].indirect_arguments[j].Constant.DestOffsetIn32BitValues + k] = 0.0f;
+            }
+            else if (tests[i].indirect_arguments[j].Type == D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW)
+                clear_vbo_mask |= 1u << tests[i].indirect_arguments[j].VertexBuffer.Slot;
+            else if (tests[i].indirect_arguments[j].Type == D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW)
+                clear_ibo = true;
+        }
+
+        expect_reset_state[1] = expect_reset_state[0];
+
+        /* VBO/IBO state is cleared to zero if it's part of the signature.
+         * A NULL IBO should be seen as a IBO which only reads 0 index. */
+        if (!clear_ibo && !(clear_vbo_mask & (1u << 0)))
+            expect_reset_state[1].x += 1.0f;
+
+        if (!(clear_vbo_mask & (1u << 1)))
+        {
+            expect_reset_state[0].y += 64.0f;
+            expect_reset_state[1].y += clear_ibo ? 64.0f : 65.0f;
+        }
+
+        for (j = 0; j < 2; j++)
+        {
+            v = get_readback_vec4(&rb, j + 1 + 2 * tests[i].expected_output_count, 0);
+            expect = &expect_reset_state[j];
+            todo ok(compare_vec4(v, expect, 0), "Post-reset element %u failed: (%f, %f, %f, %f) != (%f, %f, %f, %f)\n",
+                    j, v->x, v->y, v->z, v->w, expect->x, expect->y, expect->z, expect->w);
+        }
+
+        ID3D12CommandSignature_Release(command_signature);
+        ID3D12Resource_Release(argument_buffer);
+        ID3D12Resource_Release(count_buffer);
+        ID3D12Resource_Release(streamout_buffer);
+        release_resource_readback(&rb);
+    }
+    vkd3d_test_set_context(NULL);
+
+    ID3D12PipelineState_Release(pso);
+    for (i = 0; i < ARRAY_SIZE(vbo); i++)
+        ID3D12Resource_Release(vbo[i]);
+    for (i = 0; i < ARRAY_SIZE(ibo); i++)
+        ID3D12Resource_Release(ibo[i]);
+    ID3D12Resource_Release(cbv);
+    ID3D12Resource_Release(srv);
+    ID3D12Resource_Release(uav);
+
+    destroy_test_context(&context);
+}
+
 void test_execute_indirect(void)
 {
     ID3D12Resource *argument_buffer, *count_buffer, *uav;
diff --git a/tests/d3d12_tests.h b/tests/d3d12_tests.h
index f86a3a55..626e7093 100644
--- a/tests/d3d12_tests.h
+++ b/tests/d3d12_tests.h
@@ -135,6 +135,7 @@ decl_test(test_resolve_non_issued_query_data);
 decl_test(test_resolve_query_data_in_different_command_list);
 decl_test(test_resolve_query_data_in_reordered_command_list);
 decl_test(test_execute_indirect);
+decl_test(test_execute_indirect_state);
 decl_test(test_dispatch_zero_thread_groups);
 decl_test(test_unaligned_vertex_stride);
 decl_test(test_zero_vertex_stride);
-- 
2.36.1

From f46d17593573b86049a0b3620a1febd6e04527d7 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Thu, 25 Nov 2021 17:37:07 +0100
Subject: [PATCH 03/42] vkd3d: Refactor index buffer state to be flushed late.

With ExecuteIndirect state we'll need to modify or refresh index buffer
state.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c       | 73 +++++++++++++++++++++++---------------
 libs/vkd3d/vkd3d_private.h | 14 ++++++--
 2 files changed, 55 insertions(+), 32 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 44ec8c6f..e6001d27 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -4296,7 +4296,7 @@ static void d3d12_command_list_reset_api_state(struct d3d12_command_list *list,
 {
     d3d12_command_list_iface *iface = &list->ID3D12GraphicsCommandList_iface;
 
-    list->index_buffer_format = DXGI_FORMAT_UNKNOWN;
+    list->index_buffer.dxgi_format = DXGI_FORMAT_UNKNOWN;
 
     memset(list->rtvs, 0, sizeof(list->rtvs));
     memset(&list->dsv, 0, sizeof(list->dsv));
@@ -4311,7 +4311,7 @@ static void d3d12_command_list_reset_api_state(struct d3d12_command_list *list,
     list->predicate_enabled = false;
     list->predicate_va = 0;
 
-    list->has_valid_index_buffer = false;
+    list->index_buffer.is_non_null = false;
 
     list->current_pipeline = VK_NULL_HANDLE;
     list->command_buffer_pipeline = VK_NULL_HANDLE;
@@ -5353,18 +5353,18 @@ static void d3d12_command_list_check_index_buffer_strip_cut_value(struct d3d12_c
         switch (graphics->index_buffer_strip_cut_value)
         {
         case D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFF:
-            if (list->index_buffer_format != DXGI_FORMAT_R16_UINT)
+            if (list->index_buffer.dxgi_format != DXGI_FORMAT_R16_UINT)
             {
                 TRACE("Strip cut value 0xffff is not supported with index buffer format %#x.\n",
-                      list->index_buffer_format);
+                      list->index_buffer.dxgi_format);
             }
             break;
 
         case D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFFFFFF:
-            if (list->index_buffer_format != DXGI_FORMAT_R32_UINT)
+            if (list->index_buffer.dxgi_format != DXGI_FORMAT_R32_UINT)
             {
                 TRACE("Strip cut value 0xffffffff is not supported with index buffer format %#x.\n",
-                      list->index_buffer_format);
+                      list->index_buffer.dxgi_format);
             }
             break;
 
@@ -5462,6 +5462,33 @@ static void STDMETHODCALLTYPE d3d12_command_list_DrawInstanced(d3d12_command_lis
     VKD3D_BREADCRUMB_COMMAND(DRAW);
 }
 
+static bool d3d12_command_list_update_index_buffer(struct d3d12_command_list *list)
+{
+    const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
+
+    if (!list->index_buffer.is_non_null)
+    {
+        FIXME_ONCE("Application attempts to perform an indexed draw call without index buffer bound.\n");
+        /* We are supposed to render all 0 indices here. However, there are several problems with emulating this approach.
+         * There is no robustness support for index buffers, and if we render all 0 indices,
+         * it is extremely unlikely that this would create a meaningful side effect.
+         * For any line or triangle primitive, we would end up creating degenerates for every primitive.
+         * The only reasonable scenarios where we will observe anything is stream-out with all duplicate values, or
+         * geometry shaders where the application makes use of PrimitiveID to construct primitives.
+         * Until proven to be required otherwise, we just ignore the draw call. */
+        return false;
+    }
+
+    if (list->index_buffer.is_dirty)
+    {
+        VK_CALL(vkCmdBindIndexBuffer(list->vk_command_buffer, list->index_buffer.buffer,
+                list->index_buffer.offset, list->index_buffer.vk_type));
+        list->index_buffer.is_dirty = false;
+    }
+
+    return true;
+}
+
 static void STDMETHODCALLTYPE d3d12_command_list_DrawIndexedInstanced(d3d12_command_list_iface *iface,
         UINT index_count_per_instance, UINT instance_count, UINT start_vertex_location,
         INT base_vertex_location, UINT start_instance_location)
@@ -5475,18 +5502,8 @@ static void STDMETHODCALLTYPE d3d12_command_list_DrawIndexedInstanced(d3d12_comm
             iface, index_count_per_instance, instance_count, start_vertex_location,
             base_vertex_location, start_instance_location);
 
-    if (!list->has_valid_index_buffer)
-    {
-        FIXME_ONCE("Application attempts to perform an indexed draw call without index buffer bound.\n");
-        /* We are supposed to render all 0 indices here. However, there are several problems with emulating this approach.
-         * There is no robustness support for index buffers, and if we render all 0 indices,
-         * it is extremely unlikely that this would create a meaningful side effect.
-         * For any line or triangle primitive, we would end up creating degenerates for every primitive.
-         * The only reasonable scenarios where we will observe anything is stream-out with all duplicate values, or
-         * geometry shaders where the application makes use of PrimitiveID to construct primitives.
-         * Until proven to be required otherwise, we just ignore the draw call. */
+    if (!d3d12_command_list_update_index_buffer(list))
         return;
-    }
 
     if (list->predicate_va)
     {
@@ -7693,7 +7710,6 @@ static void STDMETHODCALLTYPE d3d12_command_list_IASetIndexBuffer(d3d12_command_
         const D3D12_INDEX_BUFFER_VIEW *view)
 {
     struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList(iface);
-    const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
     const struct vkd3d_unique_resource *resource;
     enum VkIndexType index_type;
 
@@ -7701,7 +7717,7 @@ static void STDMETHODCALLTYPE d3d12_command_list_IASetIndexBuffer(d3d12_command_
 
     if (!view)
     {
-        list->has_valid_index_buffer = false;
+        list->index_buffer.is_non_null = false;
         VKD3D_BREADCRUMB_AUX32(0);
         VKD3D_BREADCRUMB_COMMAND_STATE(IBO);
         return;
@@ -7722,13 +7738,15 @@ static void STDMETHODCALLTYPE d3d12_command_list_IASetIndexBuffer(d3d12_command_
             break;
     }
 
-    list->index_buffer_format = view->Format;
-    list->has_valid_index_buffer = view->BufferLocation != 0;
-    if (list->has_valid_index_buffer)
+    list->index_buffer.dxgi_format = view->Format;
+    list->index_buffer.vk_type = index_type;
+    list->index_buffer.is_non_null = view->BufferLocation != 0;
+    if (list->index_buffer.is_non_null)
     {
         resource = vkd3d_va_map_deref(&list->device->memory_allocator.va_map, view->BufferLocation);
-        VK_CALL(vkCmdBindIndexBuffer(list->vk_command_buffer, resource->vk_buffer,
-                view->BufferLocation - resource->va, index_type));
+        list->index_buffer.buffer = resource->vk_buffer;
+        list->index_buffer.offset = view->BufferLocation - resource->va;
+        list->index_buffer.is_dirty = true;
     }
 
     VKD3D_BREADCRUMB_AUX32(index_type == VK_INDEX_TYPE_UINT32 ? 32 : 16);
@@ -9486,11 +9504,8 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED:
-                if (!list->has_valid_index_buffer)
-                {
-                    FIXME_ONCE("Application attempts to perform an indexed draw call without index buffer bound.\n");
-                    break;
-                }
+                if (!d3d12_command_list_update_index_buffer(list))
+                    return;
 
                 if (!d3d12_command_list_begin_render_pass(list))
                 {
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 21629b59..0b422f86 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -2065,12 +2065,20 @@ struct d3d12_command_list
     bool is_valid;
     bool debug_capture;
     bool has_replaced_shaders;
-    bool has_valid_index_buffer;
+
+    struct
+    {
+        VkBuffer buffer;
+        VkDeviceSize offset;
+        DXGI_FORMAT dxgi_format;
+        VkIndexType vk_type;
+        bool is_non_null;
+        bool is_dirty;
+    } index_buffer;
+
     VkCommandBuffer vk_command_buffer;
     VkCommandBuffer vk_init_commands;
 
-    DXGI_FORMAT index_buffer_format;
-
     struct d3d12_rtv_desc rtvs[D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT];
     struct d3d12_rtv_desc dsv;
     uint32_t dsv_plane_optimal_mask;
-- 
2.36.1

From 1f1b6c0093b17bce4d06743041499e0390f843c5 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 26 Nov 2021 13:32:20 +0100
Subject: [PATCH 04/42] vkd3d: Add helper to invalidate all state.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index e6001d27..93964b76 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -4375,6 +4375,14 @@ static void d3d12_command_list_reset_state(struct d3d12_command_list *list,
     d3d12_command_list_reset_internal_state(list);
 }
 
+static void d3d12_command_list_invalidate_all_state(struct d3d12_command_list *list)
+{
+    d3d12_command_list_invalidate_current_pipeline(list, true);
+    d3d12_command_list_invalidate_root_parameters(list, VK_PIPELINE_BIND_POINT_GRAPHICS, true);
+    d3d12_command_list_invalidate_root_parameters(list, VK_PIPELINE_BIND_POINT_COMPUTE, true);
+    list->index_buffer.is_dirty = true;
+}
+
 static HRESULT STDMETHODCALLTYPE d3d12_command_list_Reset(d3d12_command_list_iface *iface,
         ID3D12CommandAllocator *allocator, ID3D12PipelineState *initial_pipeline_state)
 {
-- 
2.36.1

From 4ade0d37b80e1ecab259a9f6ceed907cf61b4bcd Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 24 Nov 2021 17:37:07 +0100
Subject: [PATCH 05/42] meta: Add ExecuteIndirect patch meta shader.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/meson.build                        |   1 +
 libs/vkd3d/meta.c                             | 106 ++++++++++++++++++
 .../shaders/cs_execute_indirect_patch.comp    |  76 +++++++++++++
 libs/vkd3d/vkd3d_private.h                    |  41 +++++++
 libs/vkd3d/vkd3d_shaders.h                    |   1 +
 5 files changed, 225 insertions(+)
 create mode 100644 libs/vkd3d/shaders/cs_execute_indirect_patch.comp

diff --git a/libs/vkd3d/meson.build b/libs/vkd3d/meson.build
index 5ab39d79..7a7e6749 100644
--- a/libs/vkd3d/meson.build
+++ b/libs/vkd3d/meson.build
@@ -27,6 +27,7 @@ vkd3d_shaders =[
 
   'shaders/vs_swapchain_fullscreen.vert',
   'shaders/fs_swapchain_fullscreen.frag',
+  'shaders/cs_execute_indirect_patch.comp',
 ]
 
 vkd3d_src = [
diff --git a/libs/vkd3d/meta.c b/libs/vkd3d/meta.c
index e7f29a5b..b49f3d71 100644
--- a/libs/vkd3d/meta.c
+++ b/libs/vkd3d/meta.c
@@ -1217,6 +1217,106 @@ void vkd3d_meta_get_predicate_pipeline(struct vkd3d_meta_ops *meta_ops,
     info->data_size = predicate_ops->data_sizes[command_type];
 }
 
+HRESULT vkd3d_execute_indirect_ops_init(struct vkd3d_execute_indirect_ops *meta_indirect_ops,
+        struct d3d12_device *device)
+{
+    VkPushConstantRange push_constant_range;
+    VkResult vr;
+    int rc;
+
+    if ((rc = pthread_mutex_init(&meta_indirect_ops->mutex, NULL)))
+        return hresult_from_errno(rc);
+
+    push_constant_range.offset = 0;
+    push_constant_range.size = sizeof(struct vkd3d_execute_indirect_args);
+    push_constant_range.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
+
+    if ((vr = vkd3d_meta_create_pipeline_layout(device, 0, NULL, 1,
+            &push_constant_range, &meta_indirect_ops->vk_pipeline_layout)) < 0)
+    {
+        pthread_mutex_destroy(&meta_indirect_ops->mutex);
+        return hresult_from_vk_result(vr);
+    }
+
+    meta_indirect_ops->pipelines_count = 0;
+    meta_indirect_ops->pipelines_size = 0;
+    meta_indirect_ops->pipelines = NULL;
+    return S_OK;
+}
+
+HRESULT vkd3d_meta_get_execute_indirect_pipeline(struct vkd3d_meta_ops *meta_ops,
+        uint32_t patch_command_count, struct vkd3d_execute_indirect_info *info)
+{
+    struct vkd3d_execute_indirect_ops *meta_indirect_ops = &meta_ops->execute_indirect;
+    VkSpecializationMapEntry map_entry;
+    VkSpecializationInfo spec;
+    HRESULT hr = S_OK;
+    VkResult vr;
+    size_t i;
+    int rc;
+
+    if ((rc = pthread_mutex_lock(&meta_indirect_ops->mutex)))
+    {
+        ERR("Failed to lock mutex, error %d.\n", rc);
+        return hresult_from_errno(rc);
+    }
+
+    for (i = 0; i < meta_indirect_ops->pipelines_count; i++)
+    {
+        if (meta_indirect_ops->pipelines[i].workgroup_size_x == patch_command_count)
+        {
+            info->vk_pipeline_layout = meta_indirect_ops->vk_pipeline_layout;
+            info->vk_pipeline = meta_indirect_ops->pipelines[i].vk_pipeline;
+            goto out;
+        }
+    }
+
+    map_entry.constantID = 0;
+    map_entry.offset = 0;
+    map_entry.size = sizeof(patch_command_count);
+
+    spec.pMapEntries = &map_entry;
+    spec.pData = &patch_command_count;
+    spec.mapEntryCount = 1;
+    spec.dataSize = sizeof(patch_command_count);
+
+    vkd3d_array_reserve((void**)&meta_indirect_ops->pipelines, &meta_indirect_ops->pipelines_size,
+            meta_indirect_ops->pipelines_count + 1, sizeof(*meta_indirect_ops->pipelines));
+
+    meta_indirect_ops->pipelines[meta_indirect_ops->pipelines_count].workgroup_size_x = patch_command_count;
+
+    vr = vkd3d_meta_create_compute_pipeline(meta_ops->device,
+            sizeof(cs_execute_indirect_patch), cs_execute_indirect_patch,
+            meta_indirect_ops->vk_pipeline_layout, &spec,
+            &meta_indirect_ops->pipelines[meta_indirect_ops->pipelines_count].vk_pipeline);
+
+    if (vr)
+    {
+        hr = hresult_from_vk_result(vr);
+        goto out;
+    }
+
+    info->vk_pipeline_layout = meta_indirect_ops->vk_pipeline_layout;
+    info->vk_pipeline = meta_indirect_ops->pipelines[meta_indirect_ops->pipelines_count].vk_pipeline;
+    meta_indirect_ops->pipelines_count++;
+
+out:
+    pthread_mutex_unlock(&meta_indirect_ops->mutex);
+    return hr;
+}
+
+void vkd3d_execute_indirect_ops_cleanup(struct vkd3d_execute_indirect_ops *meta_indirect_ops,
+        struct d3d12_device *device)
+{
+    const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
+    size_t i;
+
+    for (i = 0; i < meta_indirect_ops->pipelines_count; i++)
+        VK_CALL(vkDestroyPipeline(device->vk_device, meta_indirect_ops->pipelines[i].vk_pipeline, NULL));
+    VK_CALL(vkDestroyPipelineLayout(device->vk_device, meta_indirect_ops->vk_pipeline_layout, NULL));
+    pthread_mutex_destroy(&meta_indirect_ops->mutex);
+}
+
 HRESULT vkd3d_meta_ops_init(struct vkd3d_meta_ops *meta_ops, struct d3d12_device *device)
 {
     HRESULT hr;
@@ -1242,8 +1342,13 @@ HRESULT vkd3d_meta_ops_init(struct vkd3d_meta_ops *meta_ops, struct d3d12_device
     if (FAILED(hr = vkd3d_predicate_ops_init(&meta_ops->predicate, device)))
         goto fail_predicate_ops;
 
+    if (FAILED(hr = vkd3d_execute_indirect_ops_init(&meta_ops->execute_indirect, device)))
+        goto fail_execute_indirect_ops;
+
     return S_OK;
 
+fail_execute_indirect_ops:
+    vkd3d_predicate_ops_cleanup(&meta_ops->predicate, device);
 fail_predicate_ops:
     vkd3d_query_ops_cleanup(&meta_ops->query, device);
 fail_query_ops:
@@ -1260,6 +1365,7 @@ fail_common:
 
 HRESULT vkd3d_meta_ops_cleanup(struct vkd3d_meta_ops *meta_ops, struct d3d12_device *device)
 {
+    vkd3d_execute_indirect_ops_cleanup(&meta_ops->execute_indirect, device);
     vkd3d_predicate_ops_cleanup(&meta_ops->predicate, device);
     vkd3d_query_ops_cleanup(&meta_ops->query, device);
     vkd3d_swapchain_ops_cleanup(&meta_ops->swapchain, device);
diff --git a/libs/vkd3d/shaders/cs_execute_indirect_patch.comp b/libs/vkd3d/shaders/cs_execute_indirect_patch.comp
new file mode 100644
index 00000000..43e96204
--- /dev/null
+++ b/libs/vkd3d/shaders/cs_execute_indirect_patch.comp
@@ -0,0 +1,76 @@
+#version 450
+#extension GL_EXT_buffer_reference : require
+#extension GL_EXT_buffer_reference_uvec2 : require
+
+layout(local_size_x_id = 0) in;
+
+struct Command
+{
+	uint type;
+	uint src_offset;
+	uint dst_offset;
+};
+
+const int COMMAND_TYPE_COPY_U32 = 0;
+const int COMMAND_TYPE_COPY_INDEX_TYPE = 1;
+const int DXGI_FORMAT_R32_UINT = 0x2a;
+const int VK_INDEX_TYPE_UINT16 = 0;
+const int VK_INDEX_TYPE_UINT32 = 1;
+
+layout(buffer_reference, std430, buffer_reference_align = 4) readonly buffer Commands
+{
+	Command commands[];
+};
+
+layout(buffer_reference, std430, buffer_reference_align = 4) readonly buffer SrcBuffer {
+	uint values[];
+};
+
+layout(buffer_reference, std430, buffer_reference_align = 4) writeonly buffer DstBuffer {
+	uint values[];
+};
+
+layout(buffer_reference, std430, buffer_reference_align = 4) readonly buffer IndirectCount {
+	uint count;
+};
+
+layout(buffer_reference, std430, buffer_reference_align = 4) writeonly buffer IndirectCountWrite {
+	uint count;
+};
+
+layout(push_constant) uniform Registers
+{
+	Commands commands_va;
+	SrcBuffer src_buffer_va;
+	DstBuffer dst_buffer_va;
+	uvec2 indirect_count_va;
+	IndirectCountWrite dst_indirect_count_va;
+	uint src_stride;
+	uint dst_stride;
+};
+
+void main()
+{
+	Command cmd = commands_va.commands[gl_LocalInvocationIndex];
+
+	uint draw_id = gl_WorkGroupID.x;
+	uint max_draws = ~0u;
+	if (any(notEqual(indirect_count_va, uvec2(0))))
+	{
+		max_draws = IndirectCount(indirect_count_va).count;
+		if (gl_WorkGroupID.x == 0u)
+			dst_indirect_count_va.count = max_draws;
+	}
+
+	if (draw_id < max_draws)
+	{
+		uint src_offset = src_stride * draw_id + cmd.src_offset;
+		uint dst_offset = dst_stride * draw_id + cmd.dst_offset;
+
+		uint src_value = src_buffer_va.values[src_offset];
+		if (cmd.type == COMMAND_TYPE_COPY_INDEX_TYPE)
+			src_value = src_value == DXGI_FORMAT_R32_UINT ? VK_INDEX_TYPE_UINT32 : VK_INDEX_TYPE_UINT16;
+
+		dst_buffer_va.values[dst_offset] = src_value;
+	}
+}
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 0b422f86..10399784 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -2367,6 +2367,12 @@ HRESULT d3d12_command_queue_create(struct d3d12_device *device,
         const D3D12_COMMAND_QUEUE_DESC *desc, struct d3d12_command_queue **queue);
 void d3d12_command_queue_submit_stop(struct d3d12_command_queue *queue);
 
+struct vkd3d_execute_indirect_info
+{
+    VkPipelineLayout vk_pipeline_layout;
+    VkPipeline vk_pipeline;
+};
+
 /* ID3D12CommandSignature */
 struct d3d12_command_signature
 {
@@ -2955,6 +2961,37 @@ HRESULT vkd3d_predicate_ops_init(struct vkd3d_predicate_ops *meta_predicate_ops,
 void vkd3d_predicate_ops_cleanup(struct vkd3d_predicate_ops *meta_predicate_ops,
         struct d3d12_device *device);
 
+struct vkd3d_execute_indirect_args
+{
+    VkDeviceAddress template_va;
+    VkDeviceAddress api_buffer_va;
+    VkDeviceAddress device_generated_commands_va;
+    VkDeviceAddress indirect_count_va;
+    VkDeviceAddress dst_indirect_count_va;
+    uint32_t api_buffer_word_stride;
+    uint32_t device_generated_commands_word_stride;
+};
+
+struct vkd3d_execute_indirect_pipeline
+{
+    VkPipeline vk_pipeline;
+    uint32_t workgroup_size_x;
+};
+
+struct vkd3d_execute_indirect_ops
+{
+    VkPipelineLayout vk_pipeline_layout;
+    struct vkd3d_execute_indirect_pipeline *pipelines;
+    size_t pipelines_count;
+    size_t pipelines_size;
+    pthread_mutex_t mutex;
+};
+
+HRESULT vkd3d_execute_indirect_ops_init(struct vkd3d_execute_indirect_ops *meta_indirect_ops,
+        struct d3d12_device *device);
+void vkd3d_execute_indirect_ops_cleanup(struct vkd3d_execute_indirect_ops *meta_indirect_ops,
+        struct d3d12_device *device);
+
 struct vkd3d_meta_ops_common
 {
     VkShaderModule vk_module_fullscreen_vs;
@@ -2970,6 +3007,7 @@ struct vkd3d_meta_ops
     struct vkd3d_swapchain_ops swapchain;
     struct vkd3d_query_ops query;
     struct vkd3d_predicate_ops predicate;
+    struct vkd3d_execute_indirect_ops execute_indirect;
 };
 
 HRESULT vkd3d_meta_ops_init(struct vkd3d_meta_ops *meta_ops, struct d3d12_device *device);
@@ -3002,6 +3040,9 @@ bool vkd3d_meta_get_query_gather_pipeline(struct vkd3d_meta_ops *meta_ops,
 void vkd3d_meta_get_predicate_pipeline(struct vkd3d_meta_ops *meta_ops,
         enum vkd3d_predicate_command_type command_type, struct vkd3d_predicate_command_info *info);
 
+HRESULT vkd3d_meta_get_execute_indirect_pipeline(struct vkd3d_meta_ops *meta_ops,
+        uint32_t patch_command_count, struct vkd3d_execute_indirect_info *info);
+
 enum vkd3d_time_domain_flag
 {
     VKD3D_TIME_DOMAIN_DEVICE = 0x00000001u,
diff --git a/libs/vkd3d/vkd3d_shaders.h b/libs/vkd3d/vkd3d_shaders.h
index 9f96323c..9e5698d6 100644
--- a/libs/vkd3d/vkd3d_shaders.h
+++ b/libs/vkd3d/vkd3d_shaders.h
@@ -45,6 +45,7 @@ enum vkd3d_meta_copy_mode
 #include <cs_resolve_binary_queries.h>
 #include <cs_resolve_predicate.h>
 #include <cs_resolve_query.h>
+#include <cs_execute_indirect_patch.h>
 #include <vs_fullscreen_layer.h>
 #include <vs_fullscreen.h>
 #include <gs_fullscreen.h>
-- 
2.36.1

From e3f8889b246f7062307ee8d24ea6e22d290c93b0 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 24 Nov 2021 16:50:27 +0100
Subject: [PATCH 06/42] vkd3d: Store the raw VA index in root signature for
 root descriptors.

Needed when building device generated commands later.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 include/vkd3d_shader.h | 1 +
 libs/vkd3d/state.c     | 6 +++++-
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/include/vkd3d_shader.h b/include/vkd3d_shader.h
index eb8d66a8..7f7e893c 100644
--- a/include/vkd3d_shader.h
+++ b/include/vkd3d_shader.h
@@ -241,6 +241,7 @@ struct vkd3d_shader_root_constant
 struct vkd3d_shader_root_descriptor
 {
     struct vkd3d_shader_resource_binding *binding;
+    uint32_t raw_va_root_descriptor_index;
 };
 
 struct vkd3d_shader_root_parameter
diff --git a/libs/vkd3d/state.c b/libs/vkd3d/state.c
index 90688cd2..1c58c8dc 100644
--- a/libs/vkd3d/state.c
+++ b/libs/vkd3d/state.c
@@ -945,6 +945,7 @@ static HRESULT d3d12_root_signature_init_root_descriptors(struct d3d12_root_sign
     struct vkd3d_shader_resource_binding *binding;
     VkDescriptorSetLayoutCreateFlags vk_flags;
     struct vkd3d_shader_root_parameter *param;
+    uint32_t raw_va_root_descriptor_count = 0;
     unsigned int hoisted_parameter_index;
     const D3D12_DESCRIPTOR_RANGE1 *range;
     unsigned int i, j, k;
@@ -1061,10 +1062,13 @@ static HRESULT d3d12_root_signature_init_root_descriptors(struct d3d12_root_sign
         param = &root_signature->parameters[i];
         param->parameter_type = p->ParameterType;
         param->descriptor.binding = binding;
+        param->descriptor.raw_va_root_descriptor_index = raw_va_root_descriptor_count;
 
         context->binding_index += 1;
 
-        if (!raw_va)
+        if (raw_va)
+            raw_va_root_descriptor_count += 1;
+        else
             context->vk_binding += 1;
     }
 
-- 
2.36.1

From e72fd1414f9a4b63b32611a4358a2806778adce2 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Tue, 23 Nov 2021 13:32:51 +0100
Subject: [PATCH 07/42] vkd3d: Enable NV_device_generated_commands extension.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/device.c        | 11 +++++++++++
 libs/vkd3d/vkd3d_private.h |  3 +++
 libs/vkd3d/vulkan_procs.h  |  6 ++++++
 3 files changed, 20 insertions(+)

diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index e6135471..74ea9231 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -125,6 +125,7 @@ static const struct vkd3d_optional_extension_info optional_device_extensions[] =
     VK_EXTENSION(NV_FRAGMENT_SHADER_BARYCENTRIC, NV_fragment_shader_barycentric),
     VK_EXTENSION(NV_COMPUTE_SHADER_DERIVATIVES, NV_compute_shader_derivatives),
     VK_EXTENSION_COND(NV_DEVICE_DIAGNOSTIC_CHECKPOINTS, NV_device_diagnostic_checkpoints, VKD3D_CONFIG_FLAG_BREADCRUMBS),
+    VK_EXTENSION(NV_DEVICE_GENERATED_COMMANDS, NV_device_generated_commands),
     /* VALVE extensions */
     VK_EXTENSION(VALVE_MUTABLE_DESCRIPTOR_TYPE, VALVE_mutable_descriptor_type),
     VK_EXTENSION(VALVE_DESCRIPTOR_SET_HOST_MAPPING, VALVE_descriptor_set_host_mapping),
@@ -1412,6 +1413,16 @@ static void vkd3d_physical_device_info_init(struct vkd3d_physical_device_info *i
         vk_prepend_struct(&info->features2, &info->compute_shader_derivatives_features_nv);
     }
 
+    if (vulkan_info->NV_device_generated_commands)
+    {
+        info->device_generated_commands_features_nv.sType =
+                VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
+        info->device_generated_commands_properties_nv.sType =
+                VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV;
+        vk_prepend_struct(&info->features2, &info->device_generated_commands_features_nv);
+        vk_prepend_struct(&info->properties2, &info->device_generated_commands_properties_nv);
+    }
+
     if (vulkan_info->KHR_shader_atomic_int64)
     {
         info->shader_atomic_int64_features.sType =
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 10399784..8a6c2b49 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -171,6 +171,7 @@ struct vkd3d_vulkan_info
     bool NV_fragment_shader_barycentric;
     bool NV_compute_shader_derivatives;
     bool NV_device_diagnostic_checkpoints;
+    bool NV_device_generated_commands;
     /* VALVE extensions */
     bool VALVE_mutable_descriptor_type;
     bool VALVE_descriptor_set_host_mapping;
@@ -3077,6 +3078,7 @@ struct vkd3d_physical_device_info
     VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR shader_integer_dot_product_properties;
     VkPhysicalDeviceDriverPropertiesKHR driver_properties;
     VkPhysicalDeviceMaintenance4PropertiesKHR maintenance4_properties;
+    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV device_generated_commands_properties_nv;
 
     VkPhysicalDeviceProperties2KHR properties2;
 
@@ -3121,6 +3123,7 @@ struct vkd3d_physical_device_info
     VkPhysicalDeviceCoherentMemoryFeaturesAMD device_coherent_memory_features_amd;
     VkPhysicalDeviceMaintenance4FeaturesKHR maintenance4_features;
     VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR ray_tracing_maintenance1_features;
+    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV device_generated_commands_features_nv;
 
     VkPhysicalDeviceFeatures2 features2;
 
diff --git a/libs/vkd3d/vulkan_procs.h b/libs/vkd3d/vulkan_procs.h
index e65bb8be..e7a1b2e4 100644
--- a/libs/vkd3d/vulkan_procs.h
+++ b/libs/vkd3d/vulkan_procs.h
@@ -305,6 +305,12 @@ VK_DEVICE_EXT_PFN(vkGetImageViewAddressNVX)
 VK_DEVICE_EXT_PFN(vkGetDescriptorSetLayoutHostMappingInfoVALVE)
 VK_DEVICE_EXT_PFN(vkGetDescriptorSetHostMappingVALVE)
 
+/* VK_NV_device_generated_commands */
+VK_DEVICE_EXT_PFN(vkCreateIndirectCommandsLayoutNV)
+VK_DEVICE_EXT_PFN(vkDestroyIndirectCommandsLayoutNV)
+VK_DEVICE_EXT_PFN(vkGetGeneratedCommandsMemoryRequirementsNV)
+VK_DEVICE_EXT_PFN(vkCmdExecuteGeneratedCommandsNV)
+
 #undef VK_INSTANCE_PFN
 #undef VK_INSTANCE_EXT_PFN
 #undef VK_DEVICE_PFN
-- 
2.36.1

From 59b75b5b1d60ad2686ee97bca02781ef6a4f0e85 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Tue, 23 Nov 2021 14:45:16 +0100
Subject: [PATCH 08/42] vkd3d: Implement some advanced use cases of
 ExecuteIndirect.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c       | 603 ++++++++++++++++++++++++++++++++++++-
 libs/vkd3d/vkd3d_private.h |  12 +
 2 files changed, 602 insertions(+), 13 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 93964b76..fc4ce2dd 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -9408,6 +9408,218 @@ STATIC_ASSERT(sizeof(VkDrawIndexedIndirectCommand) == sizeof(D3D12_DRAW_INDEXED_
 STATIC_ASSERT(sizeof(VkDrawIndirectCommand) == sizeof(D3D12_DRAW_ARGUMENTS));
 STATIC_ASSERT(offsetof(VkTraceRaysIndirectCommand2KHR, depth) == offsetof(D3D12_DISPATCH_RAYS_DESC, Depth));
 
+static HRESULT d3d12_command_signature_allocate_stream_memory_for_list(
+        struct d3d12_command_list *list,
+        struct d3d12_command_signature *signature,
+        uint32_t max_command_count,
+        struct vkd3d_scratch_allocation *allocation);
+
+static HRESULT d3d12_command_signature_allocate_preprocess_memory_for_list(
+        struct d3d12_command_list *list,
+        struct d3d12_command_signature *signature, VkPipeline render_pipeline,
+        uint32_t max_command_count,
+        struct vkd3d_scratch_allocation *allocation, VkDeviceSize *size);
+
+static void d3d12_command_list_execute_indirect_state_template(
+        struct d3d12_command_list *list, struct d3d12_command_signature *signature,
+        uint32_t max_command_count,
+        struct d3d12_resource *arg_buffer, UINT64 arg_buffer_offset,
+        struct d3d12_resource *count_buffer, UINT64 count_buffer_offset)
+{
+    const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
+    struct vkd3d_scratch_allocation preprocess_allocation;
+    struct vkd3d_scratch_allocation stream_allocation;
+    struct vkd3d_scratch_allocation count_allocation;
+    struct vkd3d_execute_indirect_args patch_args;
+    VkGeneratedCommandsInfoNV generated;
+    VkIndirectCommandsStreamNV stream;
+    VkDeviceSize preprocess_size;
+    VkPipeline current_pipeline;
+    VkMemoryBarrier barrier;
+    unsigned int i;
+    HRESULT hr;
+
+    /* To build device generated commands, we need to know the pipeline we're going to render with. */
+    if (!d3d12_command_list_update_graphics_pipeline(list))
+        return;
+    current_pipeline = list->current_pipeline;
+
+    /* FIXME: If we're forced to emit non-dynamic vertex strides, and the indirect state
+     * wants to emit dynamic VBOs (dynamic stride), can that possibly work? Extremely unlikely to
+     * actually happen in practice, but something to consider for later ... */
+
+    /* TODO: If we can prove that there have been no transitions to INDIRECT state,
+     * we can hoist all patch jobs to the beginning of the command buffer and build a fixup
+     * command buffer that batches everything. For now, take the slow path always. */
+    d3d12_command_list_end_current_render_pass(list, true);
+    d3d12_command_list_invalidate_current_pipeline(list, true);
+
+    memset(&patch_args, 0, sizeof(patch_args));
+    if (FAILED(hr = d3d12_command_signature_allocate_preprocess_memory_for_list(
+            list, signature, current_pipeline,
+            max_command_count, &preprocess_allocation, &preprocess_size)))
+    {
+        WARN("Failed to allocate preprocess memory.\n");
+        return;
+    }
+
+    if (FAILED(hr = d3d12_command_signature_allocate_stream_memory_for_list(
+            list, signature, max_command_count, &stream_allocation)))
+    {
+        WARN("Failed to allocate stream memory.\n");
+        return;
+    }
+
+    if (count_buffer)
+    {
+        if (FAILED(hr = d3d12_command_allocator_allocate_scratch_memory(list->allocator,
+                sizeof(uint32_t),
+                list->device->device_info.device_generated_commands_properties_nv.minSequencesCountBufferOffsetAlignment,
+                &count_allocation)))
+        {
+            WARN("Failed to allocate count memory.\n");
+            return;
+        }
+    }
+
+    patch_args.template_va = signature->state_template.buffer_va;
+    patch_args.api_buffer_va = d3d12_resource_get_va(arg_buffer, arg_buffer_offset);
+    patch_args.device_generated_commands_va = stream_allocation.va;
+    patch_args.indirect_count_va = count_buffer ? d3d12_resource_get_va(count_buffer, count_buffer_offset) : 0;
+    patch_args.dst_indirect_count_va = count_buffer ? count_allocation.va : 0;
+    patch_args.api_buffer_word_stride = signature->desc.ByteStride / sizeof(uint32_t);
+    patch_args.device_generated_commands_word_stride = signature->state_template.stride / sizeof(uint32_t);
+
+    VK_CALL(vkCmdPushConstants(list->vk_command_buffer, signature->state_template.pipeline.vk_pipeline_layout,
+            VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(patch_args), &patch_args));
+    VK_CALL(vkCmdBindPipeline(list->vk_command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
+            signature->state_template.pipeline.vk_pipeline));
+
+    /* TODO: We can batch the {prologue barrier} { work } { work } ... {epilogue barrier} later. */
+    /* The argument buffer and indirect count buffers are in indirect state, but we'll need to read it. */
+    barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
+    barrier.pNext = NULL;
+
+    barrier.srcAccessMask = 0;
+    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
+    VK_CALL(vkCmdPipelineBarrier(list->vk_command_buffer, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 1, &barrier, 0, NULL, 0, NULL));
+
+    /* One workgroup processes the patching for one draw. We could potentially use indirect dispatch
+     * to restrict the patching work to just the indirect count, but meh, just more barriers.
+     * We'll nop out the workgroup early based on direct count, and the number of threads should be trivial either way. */
+    VK_CALL(vkCmdDispatch(list->vk_command_buffer, max_command_count, 1, 1));
+
+    barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+    barrier.dstAccessMask = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV | VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
+    VK_CALL(vkCmdPipelineBarrier(list->vk_command_buffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+            VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV,
+            0, 1, &barrier, 0, NULL, 0, NULL));
+
+    if (!d3d12_command_list_begin_render_pass(list))
+    {
+        WARN("Failed to begin render pass, ignoring draw.\n");
+        return;
+    }
+
+    /* Bind IBO. If we always update the IBO indirectly, do not validate the index buffer here.
+     * We can render fine even with a NULL IBO bound. */
+    for (i = 0; i < signature->desc.NumArgumentDescs; i++)
+        if (signature->desc.pArgumentDescs[i].Type == D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW)
+            break;
+
+    if (i == signature->desc.NumArgumentDescs &&
+            signature->desc.pArgumentDescs[signature->desc.NumArgumentDescs - 1].Type ==
+                    D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED &&
+            !d3d12_command_list_update_index_buffer(list))
+    {
+        return;
+    }
+
+    generated.sType = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV;
+    generated.pNext = NULL;
+    generated.pipeline = list->current_pipeline;
+    generated.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
+    generated.indirectCommandsLayout = signature->state_template.layout;
+    generated.streamCount = 1;
+    generated.pStreams = &stream;
+    generated.preprocessBuffer = preprocess_allocation.buffer;
+    generated.preprocessOffset = preprocess_allocation.offset;
+    generated.preprocessSize = preprocess_size;
+    generated.sequencesCount = max_command_count;
+    generated.sequencesIndexBuffer = VK_NULL_HANDLE;
+    generated.sequencesIndexOffset = 0;
+
+    if (count_buffer)
+    {
+        generated.sequencesCountBuffer = count_allocation.buffer;
+        generated.sequencesCountOffset = count_allocation.offset;
+    }
+    else
+    {
+        generated.sequencesCountBuffer = VK_NULL_HANDLE;
+        generated.sequencesCountOffset = 0;
+    }
+
+    stream.buffer = stream_allocation.buffer;
+    stream.offset = stream_allocation.offset;
+
+    VK_CALL(vkCmdExecuteGeneratedCommandsNV(list->vk_command_buffer, VK_FALSE, &generated));
+
+    /* Need to clear state to zero if it was part of a command signature. */
+    for (i = 0; i < signature->desc.NumArgumentDescs; i++)
+    {
+        const D3D12_INDIRECT_ARGUMENT_DESC *arg = &signature->desc.pArgumentDescs[i];
+        switch (arg->Type)
+        {
+            case D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW:
+                /* Null IBO */
+                list->index_buffer.is_non_null = false;
+                break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW:
+            {
+                /* Null VBO */
+                uint32_t slot = arg->VertexBuffer.Slot;
+                list->dynamic_state.vertex_buffers[slot] = VK_NULL_HANDLE;
+                list->dynamic_state.vertex_strides[slot] = 0;
+                list->dynamic_state.vertex_offsets[slot] = 0;
+                list->dynamic_state.vertex_sizes[slot] = 0;
+                break;
+            }
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW:
+            case D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW:
+            case D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW:
+            {
+                uint32_t index = arg->ConstantBufferView.RootParameterIndex;
+                d3d12_command_list_set_root_descriptor(list,
+                        VK_PIPELINE_BIND_POINT_GRAPHICS, index, 0);
+                break;
+            }
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT:
+            {
+                uint32_t zeroes[D3D12_MAX_ROOT_COST];
+                memset(zeroes, 0, sizeof(uint32_t) * arg->Constant.Num32BitValuesToSet);
+                d3d12_command_list_set_root_constants(list,
+                        VK_PIPELINE_BIND_POINT_GRAPHICS, arg->Constant.RootParameterIndex,
+                        arg->Constant.DestOffsetIn32BitValues,
+                        arg->Constant.Num32BitValuesToSet, zeroes);
+                break;
+            }
+
+            default:
+                break;
+        }
+    }
+
+    /* Spec mentions that all state related to the bind point is undefined after this, so
+     * invalidate all state. Unclear exactly which state is invalidated though ...
+     * Treat it as a meta shader. We need to nuke all state after running execute generated commands. */
+    d3d12_command_list_invalidate_all_state(list);
+}
+
 static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_list_iface *iface,
         ID3D12CommandSignature *command_signature, UINT max_command_count, ID3D12Resource *arg_buffer,
         UINT64 arg_buffer_offset, ID3D12Resource *count_buffer, UINT64 count_buffer_offset)
@@ -9426,12 +9638,27 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
             iface, command_signature, max_command_count, arg_buffer, arg_buffer_offset,
             count_buffer, count_buffer_offset);
 
+    if (!max_command_count)
+        return;
+
     if ((count_buffer || list->predicate_va) && !list->device->vk_info.KHR_draw_indirect_count)
     {
         FIXME("Count buffers not supported by Vulkan implementation.\n");
         return;
     }
 
+    if (sig_impl->requires_state_template)
+    {
+        /* Complex execute indirect path. */
+        if (list->predicate_va)
+            FIXME("Predicated ExecuteIndirect with state template not supported yet. Ignoring predicate.\n");
+        d3d12_command_list_execute_indirect_state_template(list, sig_impl,
+                max_command_count,
+                arg_impl, arg_buffer_offset,
+                count_impl, count_buffer_offset);
+        return;
+    }
+
     /* Temporary workaround, since we cannot parse non-draw arguments yet. Point directly
      * to the first argument. Should avoid hard crashes for now. */
     arg_buffer_offset += sig_impl->argument_buffer_offset;
@@ -12186,6 +12413,22 @@ static ULONG STDMETHODCALLTYPE d3d12_command_signature_AddRef(ID3D12CommandSigna
     return refcount;
 }
 
+static void d3d12_command_signature_cleanup(struct d3d12_command_signature *signature)
+{
+    const struct vkd3d_vk_device_procs *vk_procs = &signature->device->vk_procs;
+
+    if (signature->device->device_info.device_generated_commands_features_nv.deviceGeneratedCommands)
+    {
+        VK_CALL(vkDestroyBuffer(signature->device->vk_device, signature->state_template.buffer, NULL));
+        vkd3d_free_device_memory(signature->device, &signature->state_template.memory);
+        VK_CALL(vkDestroyIndirectCommandsLayoutNV(signature->device->vk_device, signature->state_template.layout, NULL));
+    }
+
+    vkd3d_private_store_destroy(&signature->private_store);
+    vkd3d_free((void *)signature->desc.pArgumentDescs);
+    vkd3d_free(signature);
+}
+
 static ULONG STDMETHODCALLTYPE d3d12_command_signature_Release(ID3D12CommandSignature *iface)
 {
     struct d3d12_command_signature *signature = impl_from_ID3D12CommandSignature(iface);
@@ -12196,12 +12439,7 @@ static ULONG STDMETHODCALLTYPE d3d12_command_signature_Release(ID3D12CommandSign
     if (!refcount)
     {
         struct d3d12_device *device = signature->device;
-
-        vkd3d_private_store_destroy(&signature->private_store);
-
-        vkd3d_free((void *)signature->desc.pArgumentDescs);
-        vkd3d_free(signature);
-
+        d3d12_command_signature_cleanup(signature);
         d3d12_device_release(device);
     }
 
@@ -12264,12 +12502,341 @@ CONST_VTBL struct ID3D12CommandSignatureVtbl d3d12_command_signature_vtbl =
     d3d12_command_signature_GetDevice,
 };
 
+enum vkd3d_patch_command_token
+{
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_U32 = 0,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_INDEX_FORMAT = 1,
+    VKD3D_PATCH_COMMAND_INT_MAX = 0x7fffffff
+};
+
+struct vkd3d_patch_command
+{
+    enum vkd3d_patch_command_token token;
+    uint32_t src_offset;
+    uint32_t dst_offset;
+};
+
+static HRESULT d3d12_command_signature_init_patch_commands_buffer(struct d3d12_command_signature *signature,
+        struct d3d12_device *device,
+        const struct vkd3d_patch_command *commands, size_t command_count)
+{
+    const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
+    D3D12_RESOURCE_DESC1 buffer_desc;
+    D3D12_HEAP_PROPERTIES heap_info;
+    HRESULT hr = S_OK;
+    VkResult vr;
+    void *ptr;
+
+    memset(&heap_info, 0, sizeof(heap_info));
+    heap_info.Type = D3D12_HEAP_TYPE_UPLOAD;
+    memset(&buffer_desc, 0, sizeof(buffer_desc));
+    buffer_desc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
+    buffer_desc.Width = command_count * sizeof(struct vkd3d_patch_command);
+    buffer_desc.Height = 1;
+    buffer_desc.DepthOrArraySize = 1;
+    buffer_desc.SampleDesc.Count = 1;
+    buffer_desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
+    buffer_desc.Flags = D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
+
+    if (FAILED(hr = vkd3d_create_buffer(device, &heap_info, D3D12_HEAP_FLAG_NONE,
+            &buffer_desc, &signature->state_template.buffer)))
+        return hr;
+
+    if (FAILED(hr = vkd3d_allocate_buffer_memory(device, signature->state_template.buffer,
+            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
+            &signature->state_template.memory)))
+        return hr;
+
+    signature->state_template.buffer_va = vkd3d_get_buffer_device_address(device,
+            signature->state_template.buffer);
+
+    if ((vr = VK_CALL(vkMapMemory(device->vk_device, signature->state_template.memory.vk_memory,
+            0, VK_WHOLE_SIZE, 0, (void**)&ptr))))
+        return hr;
+
+    memcpy(ptr, commands, command_count * sizeof(struct vkd3d_patch_command));
+    VK_CALL(vkUnmapMemory(device->vk_device, signature->state_template.memory.vk_memory));
+
+    return hr;
+}
+
+static HRESULT d3d12_command_signature_init_indirect_commands_layout(
+        struct d3d12_command_signature *signature, struct d3d12_device *device,
+        const VkIndirectCommandsLayoutTokenNV *tokens, uint32_t token_count,
+        uint32_t stream_stride)
+{
+    const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
+    VkIndirectCommandsLayoutCreateInfoNV create_info;
+    VkResult vr;
+
+    create_info.sType = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV;
+    create_info.pNext = NULL;
+    create_info.flags = 0;
+    create_info.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
+    create_info.streamCount = 1;
+    create_info.pStreamStrides = &stream_stride;
+    create_info.tokenCount = token_count;
+    create_info.pTokens = tokens;
+
+    signature->state_template.stride = stream_stride;
+
+    if (token_count > device->device_info.device_generated_commands_properties_nv.maxIndirectCommandsTokenCount)
+    {
+        FIXME("Token count %u is too large (max %u).\n",
+                token_count, device->device_info.device_generated_commands_properties_nv.maxIndirectCommandsTokenCount);
+        return E_NOTIMPL;
+    }
+
+    vr = VK_CALL(vkCreateIndirectCommandsLayoutNV(device->vk_device, &create_info, NULL, &signature->state_template.layout));
+    return hresult_from_vk_result(vr);
+}
+
+static HRESULT d3d12_command_signature_allocate_stream_memory_for_list(
+        struct d3d12_command_list *list,
+        struct d3d12_command_signature *signature,
+        uint32_t max_command_count,
+        struct vkd3d_scratch_allocation *allocation)
+{
+    if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
+            max_command_count * signature->state_template.stride,
+            list->device->device_info.device_generated_commands_properties_nv.minIndirectCommandsBufferOffsetAlignment,
+            allocation))
+        return E_OUTOFMEMORY;
+
+    return S_OK;
+}
+
+static HRESULT d3d12_command_signature_allocate_preprocess_memory_for_list(
+        struct d3d12_command_list *list,
+        struct d3d12_command_signature *signature, VkPipeline render_pipeline,
+        uint32_t max_command_count,
+        struct vkd3d_scratch_allocation *allocation, VkDeviceSize *size)
+{
+    const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
+    VkGeneratedCommandsMemoryRequirementsInfoNV info;
+    VkMemoryRequirements2 memory_info;
+
+    memory_info.sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
+    memory_info.pNext = NULL;
+
+    info.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
+    info.sType = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV;
+    info.pNext = NULL;
+    info.maxSequencesCount = max_command_count;
+    info.pipeline = render_pipeline;
+    info.indirectCommandsLayout = signature->state_template.layout;
+
+    if (max_command_count > list->device->device_info.device_generated_commands_properties_nv.maxIndirectSequenceCount)
+    {
+        FIXME("max_command_count %u exceeds device limit %u.\n",
+                max_command_count,
+                list->device->device_info.device_generated_commands_properties_nv.maxIndirectSequenceCount);
+        return E_NOTIMPL;
+    }
+
+    VK_CALL(vkGetGeneratedCommandsMemoryRequirementsNV(list->device->vk_device, &info, &memory_info));
+
+    if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator, memory_info.memoryRequirements.size,
+            list->device->device_info.device_generated_commands_properties_nv.minIndirectCommandsBufferOffsetAlignment,
+            allocation))
+        return E_OUTOFMEMORY;
+
+    /* Going to assume the memory type is okay ... It's device local after all. */
+    *size = memory_info.memoryRequirements.size;
+    return S_OK;
+}
+
+static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_signature *signature,
+        const D3D12_COMMAND_SIGNATURE_DESC *desc,
+        struct d3d12_root_signature *root_signature,
+        struct d3d12_device *device)
+{
+    const struct vkd3d_shader_root_parameter *root_parameter;
+    const struct vkd3d_shader_root_constant *root_constant;
+    struct vkd3d_patch_command *patch_commands = NULL;
+    VkIndirectCommandsLayoutTokenNV *tokens = NULL;
+    VkIndirectCommandsLayoutTokenNV token;
+    uint32_t generic_u32_copy_count;
+    size_t patch_commands_count = 0;
+    size_t patch_commands_size = 0;
+    uint32_t root_parameter_index;
+    uint32_t src_word_offset = 0;
+    uint32_t stream_stride = 0;
+    uint32_t dst_word_offset;
+    size_t token_count = 0;
+    size_t token_size = 0;
+    HRESULT hr = S_OK;
+    uint32_t i, j;
+
+    if (!device->device_info.device_generated_commands_features_nv.deviceGeneratedCommands)
+    {
+        WARN("Device generated commands not supported, indirect state commands will be ignored.\n");
+        return S_OK;
+    }
+
+    for (i = 0; i < desc->NumArgumentDescs; i++)
+    {
+        const D3D12_INDIRECT_ARGUMENT_DESC *argument_desc = &desc->pArgumentDescs[i];
+        memset(&token, 0, sizeof(token));
+        token.sType = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV;
+        generic_u32_copy_count = 0;
+        dst_word_offset = 0;
+
+        switch (argument_desc->Type)
+        {
+            case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT:
+                root_parameter_index = argument_desc->Constant.RootParameterIndex;
+                root_constant = root_signature_get_32bit_constants(root_signature, root_parameter_index);
+                token.tokenType = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV;
+                token.pushconstantPipelineLayout = root_signature->graphics.vk_pipeline_layout;
+                token.pushconstantShaderStageFlags = root_signature->graphics.vk_push_stages;
+                token.pushconstantOffset = root_constant->constant_index + argument_desc->Constant.DestOffsetIn32BitValues;
+                token.pushconstantSize = argument_desc->Constant.Num32BitValuesToSet;
+                token.pushconstantOffset *= sizeof(uint32_t);
+                token.pushconstantSize *= sizeof(uint32_t);
+
+                stream_stride = align(stream_stride, sizeof(uint32_t));
+                token.offset = stream_stride;
+                stream_stride += token.pushconstantSize;
+                dst_word_offset = token.offset / sizeof(uint32_t);
+
+                generic_u32_copy_count = argument_desc->Constant.Num32BitValuesToSet;
+                break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW:
+            case D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW:
+            case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW:
+                root_parameter_index = argument_desc->ShaderResourceView.RootParameterIndex;
+                root_parameter = root_signature_get_parameter(root_signature, root_parameter_index);
+                if (!(root_signature->root_descriptor_raw_va_mask & (1ull << root_parameter_index)))
+                {
+                    ERR("Root parameter %u is not a raw VA. Cannot implement command signature which updates root descriptor.\n",
+                            root_parameter_index);
+                    hr = E_NOTIMPL;
+                    goto end;
+                }
+
+                token.tokenType = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV;
+                token.pushconstantPipelineLayout = root_signature->graphics.vk_pipeline_layout;
+                token.pushconstantShaderStageFlags = root_signature->graphics.vk_push_stages;
+                token.pushconstantOffset = root_parameter->descriptor.raw_va_root_descriptor_index * sizeof(VkDeviceAddress);
+                token.pushconstantSize = sizeof(VkDeviceAddress);
+
+                stream_stride = align(stream_stride, sizeof(uint32_t));
+                token.offset = stream_stride;
+                stream_stride += token.pushconstantSize;
+                dst_word_offset = token.offset / sizeof(uint32_t);
+
+                /* Simply patch by copying U32s. Need to handle unaligned U32s since everything is tightly packed. */
+                generic_u32_copy_count = sizeof(VkDeviceAddress) / sizeof(uint32_t);
+                break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW:
+                token.tokenType = VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV;
+                token.vertexBindingUnit = argument_desc->VertexBuffer.Slot;
+                token.vertexDynamicStride = VK_TRUE;
+
+                stream_stride = align(stream_stride, sizeof(VkDeviceAddress));
+                token.offset = stream_stride;
+                stream_stride += sizeof(VkBindVertexBufferIndirectCommandNV);
+                dst_word_offset = token.offset / sizeof(uint32_t);
+
+                /* The VBV indirect layout is the same as DX, so just copy the U32s. */
+                generic_u32_copy_count = sizeof(D3D12_VERTEX_BUFFER_VIEW) / sizeof(uint32_t);
+                break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW:
+                token.tokenType = VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV;
+                stream_stride = align(stream_stride, sizeof(VkDeviceAddress));
+                token.offset = stream_stride;
+                stream_stride += sizeof(VkBindVertexBufferIndirectCommandNV);
+                dst_word_offset = token.offset / sizeof(uint32_t);
+
+                /* Need to convert the index buffer type. Could maybe use the pIndexTypes LUT feature,
+                 * but we'd need a pretty chonkers LUT to make that work ... */
+                vkd3d_array_reserve((void**)&patch_commands, &patch_commands_size,
+                        patch_commands_count + sizeof(D3D12_INDEX_BUFFER_VIEW) / sizeof(uint32_t),
+                        sizeof(*patch_commands));
+
+                for (j = 0; j < 3; j++)
+                {
+                    patch_commands[patch_commands_count].token = VKD3D_PATCH_COMMAND_TOKEN_COPY_U32;
+                    patch_commands[patch_commands_count].src_offset = src_word_offset++;
+                    patch_commands[patch_commands_count].dst_offset = dst_word_offset++;
+                    patch_commands_count++;
+                }
+
+                patch_commands[patch_commands_count].token = VKD3D_PATCH_COMMAND_TOKEN_COPY_INDEX_FORMAT;
+                patch_commands[patch_commands_count].src_offset = src_word_offset++;
+                patch_commands[patch_commands_count].dst_offset = dst_word_offset++;
+                patch_commands_count++;
+                break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_DRAW:
+                token.tokenType = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV;
+                stream_stride = align(stream_stride, sizeof(uint32_t));
+                token.offset = stream_stride;
+                stream_stride += sizeof(VkDrawIndirectCommand);
+                dst_word_offset = token.offset / sizeof(uint32_t);
+                generic_u32_copy_count = sizeof(VkDrawIndirectCommand) / sizeof(uint32_t);
+                break;
+
+            case D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED:
+                token.tokenType = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV;
+                stream_stride = align(stream_stride, sizeof(uint32_t));
+                token.offset = stream_stride;
+                stream_stride += sizeof(VkDrawIndexedIndirectCommand);
+                dst_word_offset = token.offset / sizeof(uint32_t);
+                generic_u32_copy_count = sizeof(VkDrawIndexedIndirectCommand) / sizeof(uint32_t);
+                break;
+
+            default:
+                FIXME("Unsupported token type %u.\n", argument_desc->Type);
+                hr = E_NOTIMPL;
+                goto end;
+        }
+
+        vkd3d_array_reserve((void**)&tokens, &token_size, token_count + 1, sizeof(*tokens));
+        tokens[token_count++] = token;
+
+        if (generic_u32_copy_count)
+        {
+            vkd3d_array_reserve((void**)&patch_commands, &patch_commands_size,
+                    patch_commands_count + generic_u32_copy_count,
+                    sizeof(*patch_commands));
+
+            /* Simply patch by copying U32s. */
+            for (j = 0; j < generic_u32_copy_count; j++, patch_commands_count++)
+            {
+                patch_commands[patch_commands_count].token = VKD3D_PATCH_COMMAND_TOKEN_COPY_U32;
+                patch_commands[patch_commands_count].src_offset = src_word_offset++;
+                patch_commands[patch_commands_count].dst_offset = dst_word_offset++;
+            }
+        }
+    }
+
+    stream_stride = align(stream_stride, sizeof(VkDeviceAddress));
+
+    if (FAILED(hr = d3d12_command_signature_init_patch_commands_buffer(signature, device, patch_commands, patch_commands_count)))
+        goto end;
+    if (FAILED(hr = d3d12_command_signature_init_indirect_commands_layout(signature, device, tokens, token_count, stream_stride)))
+        goto end;
+    if (FAILED(hr = vkd3d_meta_get_execute_indirect_pipeline(&device->meta_ops, patch_commands_count, &signature->state_template.pipeline)))
+        goto end;
+
+end:
+    vkd3d_free(tokens);
+    vkd3d_free(patch_commands);
+    return hr;
+}
+
 HRESULT d3d12_command_signature_create(struct d3d12_device *device, struct d3d12_root_signature *root_signature,
         const D3D12_COMMAND_SIGNATURE_DESC *desc,
         struct d3d12_command_signature **signature)
 {
     struct d3d12_command_signature *object;
     bool requires_root_signature = false;
+    bool requires_state_template = false;
     uint32_t argument_buffer_offset = 0;
     uint32_t signature_size = 0;
     bool has_action = false;
@@ -12312,34 +12879,33 @@ HRESULT d3d12_command_signature_create(struct d3d12_device *device, struct d3d12
                 argument_buffer_offset = signature_size;
                 signature_size += sizeof(D3D12_DISPATCH_MESH_ARGUMENTS);
                 is_action = true;
-                FIXME("Unsupported indirect dispatch mesh.\n");
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT:
                 requires_root_signature = true;
+                requires_state_template = true;
                 signature_size += argument_desc->Constant.Num32BitValuesToSet * sizeof(uint32_t);
-                FIXME("Unsupported indirect argument type CONSTANT.\n");
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW:
             case D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW:
             case D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW:
                 requires_root_signature = true;
+                requires_state_template = true;
                 /* The command signature payload is *not* aligned. */
                 signature_size += sizeof(D3D12_GPU_VIRTUAL_ADDRESS);
-                FIXME("Unsupported indirect root descriptor type: %u.\n", argument_desc->Type);
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW:
                 /* The command signature payload is *not* aligned. */
                 signature_size += sizeof(D3D12_VERTEX_BUFFER_VIEW);
-                FIXME("Unsupported indirect VBV.\n");
+                requires_state_template = true;
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW:
                 /* The command signature payload is *not* aligned. */
                 signature_size += sizeof(D3D12_INDEX_BUFFER_VIEW);
-                FIXME("Unsupported indirect IBV.\n");
+                requires_state_template = true;
                 break;
 
             default:
@@ -12389,11 +12955,10 @@ HRESULT d3d12_command_signature_create(struct d3d12_device *device, struct d3d12
         return E_INVALIDARG;
     }
 
-    if (!(object = vkd3d_malloc(sizeof(*object))))
+    if (!(object = vkd3d_calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
 
     object->ID3D12CommandSignature_iface.lpVtbl = &d3d12_command_signature_vtbl;
-    object->argument_buffer_offset = argument_buffer_offset;
     object->refcount = 1;
 
     object->desc = *desc;
@@ -12412,6 +12977,18 @@ HRESULT d3d12_command_signature_create(struct d3d12_device *device, struct d3d12
         return hr;
     }
 
+    if ((object->requires_state_template = requires_state_template))
+    {
+        if (FAILED(hr = d3d12_command_signature_init_state_template(object, desc, root_signature, device)))
+        {
+            vkd3d_free((void *)object->desc.pArgumentDescs);
+            vkd3d_free(object);
+            return hr;
+        }
+    }
+    else
+        object->argument_buffer_offset = argument_buffer_offset;
+
     d3d12_device_add_ref(object->device = device);
 
     TRACE("Created command signature %p.\n", object);
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 8a6c2b49..ebb9febd 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -2383,6 +2383,18 @@ struct d3d12_command_signature
     D3D12_COMMAND_SIGNATURE_DESC desc;
     uint32_t argument_buffer_offset;
 
+    /* Complex command signatures require some work to stamp out device generated commands. */
+    struct
+    {
+        VkBuffer buffer;
+        VkDeviceAddress buffer_va;
+        struct vkd3d_device_memory_allocation memory;
+        VkIndirectCommandsLayoutNV layout;
+        uint32_t stride;
+        struct vkd3d_execute_indirect_info pipeline;
+    } state_template;
+    bool requires_state_template;
+
     struct d3d12_device *device;
 
     struct vkd3d_private_store private_store;
-- 
2.36.1

From a8e46bbff1004a8f9f8ab07ccdc8dcf051bc8816 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Thu, 25 Nov 2021 18:15:00 +0100
Subject: [PATCH 09/42] vkd3d: Add VKD3D_CONFIG option to force raw VA CBV
 descriptors.

For certain ExecuteIndirect() uses, we're forced to use this path
since we have no way to update push descriptors indirectly yet.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 include/vkd3d.h     | 1 +
 libs/vkd3d/device.c | 1 +
 libs/vkd3d/state.c  | 3 ++-
 3 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/include/vkd3d.h b/include/vkd3d.h
index a2bcd097..d63a3304 100644
--- a/include/vkd3d.h
+++ b/include/vkd3d.h
@@ -87,6 +87,7 @@ extern "C" {
 #define VKD3D_CONFIG_FLAG_BREADCRUMBS (1ull << 25)
 #define VKD3D_CONFIG_FLAG_PIPELINE_LIBRARY_APP_CACHE_ONLY (1ull << 26)
 #define VKD3D_CONFIG_FLAG_SHADER_CACHE_SYNC (1ull << 27)
+#define VKD3D_CONFIG_FLAG_FORCE_RAW_VA_CBV (1ull << 28)
 
 typedef HRESULT (*PFN_vkd3d_signal_event)(HANDLE event);
 
diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index 74ea9231..56bf9022 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -653,6 +653,7 @@ static const struct vkd3d_debug_option vkd3d_config_options[] =
     {"breadcrumbs", VKD3D_CONFIG_FLAG_BREADCRUMBS},
     {"pipeline_library_app_cache", VKD3D_CONFIG_FLAG_PIPELINE_LIBRARY_APP_CACHE_ONLY},
     {"shader_cache_sync", VKD3D_CONFIG_FLAG_SHADER_CACHE_SYNC},
+    {"force_raw_va_cbv", VKD3D_CONFIG_FLAG_FORCE_RAW_VA_CBV},
 };
 
 static void vkd3d_config_flags_init_once(void)
diff --git a/libs/vkd3d/state.c b/libs/vkd3d/state.c
index 1c58c8dc..2d5b10a4 100644
--- a/libs/vkd3d/state.c
+++ b/libs/vkd3d/state.c
@@ -4688,7 +4688,8 @@ static uint32_t vkd3d_bindless_state_get_bindless_flags(struct d3d12_device *dev
          * The difference in performance is profound (~15% in some cases).
          * On ACO, BDA with NonWritable can be promoted directly to scalar loads,
          * which is great. */
-        if (device_info->properties2.properties.vendorID != VKD3D_VENDOR_ID_NVIDIA)
+        if ((vkd3d_config_flags & VKD3D_CONFIG_FLAG_FORCE_RAW_VA_CBV) ||
+                device_info->properties2.properties.vendorID != VKD3D_VENDOR_ID_NVIDIA)
             flags |= VKD3D_RAW_VA_ROOT_DESCRIPTOR_CBV;
     }
 
-- 
2.36.1

From 4a507c3a2b8f54dac0225c9dabe6a883951be52a Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 12 Jan 2022 14:09:47 +0100
Subject: [PATCH 10/42] vkd3d: Ignore unsupported execute indirect calls.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index fc4ce2dd..3af25d3b 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -9439,6 +9439,12 @@ static void d3d12_command_list_execute_indirect_state_template(
     unsigned int i;
     HRESULT hr;
 
+    if (!list->device->device_info.device_generated_commands_features_nv.deviceGeneratedCommands)
+    {
+        WARN("Ignoring unsupported state template execute indirect.\n");
+        return;
+    }
+
     /* To build device generated commands, we need to know the pipeline we're going to render with. */
     if (!d3d12_command_list_update_graphics_pipeline(list))
         return;
-- 
2.36.1

From dd840e200444786ded037d4d154b04c1fcf78478 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 26 Nov 2021 13:29:04 +0100
Subject: [PATCH 11/42] tests: Remove TODOs from ExecuteIndirect state test.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 tests/d3d12_command.c | 14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

diff --git a/tests/d3d12_command.c b/tests/d3d12_command.c
index 00618940..640c9bf6 100644
--- a/tests/d3d12_command.c
+++ b/tests/d3d12_command.c
@@ -1955,7 +1955,11 @@ void test_execute_indirect_state(void)
         ID3D12GraphicsCommandList_SetGraphicsRootUnorderedAccessView(command_list, 3,
                 ID3D12Resource_GetGPUVirtualAddress(uav));
 
-        /* Other state is cleared to 0. */
+        /* Other state is cleared to 0. For testing sanity, reset the index buffer since we don't support NULL IBO yet. */
+        for (j = 0; j < tests[i].indirect_argument_count; j++)
+            if (tests[i].indirect_arguments[j].Type == D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW)
+                ID3D12GraphicsCommandList_IASetIndexBuffer(command_list, &ibv);
+
         ID3D12GraphicsCommandList_DrawIndexedInstanced(command_list, 2, 1, 0, 0, 0);
         transition_resource_state(command_list, streamout_buffer, D3D12_RESOURCE_STATE_STREAM_OUT, D3D12_RESOURCE_STATE_COPY_SOURCE);
 
@@ -1970,11 +1974,11 @@ void test_execute_indirect_state(void)
         {
             expect = &tests[i].expected_output[j];
             v = get_readback_vec4(&rb, j + 1, 0);
-            todo ok(compare_vec4(v, expect, 0), "Element (direct count) %u failed: (%f, %f, %f, %f) != (%f, %f, %f, %f)\n",
+            ok(compare_vec4(v, expect, 0), "Element (direct count) %u failed: (%f, %f, %f, %f) != (%f, %f, %f, %f)\n",
                     j, v->x, v->y, v->z, v->w, expect->x, expect->y, expect->z, expect->w);
 
             v = get_readback_vec4(&rb, j + tests[i].expected_output_count + 1, 0);
-            todo ok(compare_vec4(v, expect, 0), "Element (indirect count) %u failed: (%f, %f, %f, %f) != (%f, %f, %f, %f)\n",
+            ok(compare_vec4(v, expect, 0), "Element (indirect count) %u failed: (%f, %f, %f, %f) != (%f, %f, %f, %f)\n",
                     j, v->x, v->y, v->z, v->w, expect->x, expect->y, expect->z, expect->w);
         }
 
@@ -1992,8 +1996,10 @@ void test_execute_indirect_state(void)
             }
             else if (tests[i].indirect_arguments[j].Type == D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW)
                 clear_vbo_mask |= 1u << tests[i].indirect_arguments[j].VertexBuffer.Slot;
+#if 0
             else if (tests[i].indirect_arguments[j].Type == D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW)
                 clear_ibo = true;
+#endif
         }
 
         expect_reset_state[1] = expect_reset_state[0];
@@ -2013,7 +2019,7 @@ void test_execute_indirect_state(void)
         {
             v = get_readback_vec4(&rb, j + 1 + 2 * tests[i].expected_output_count, 0);
             expect = &expect_reset_state[j];
-            todo ok(compare_vec4(v, expect, 0), "Post-reset element %u failed: (%f, %f, %f, %f) != (%f, %f, %f, %f)\n",
+            ok(compare_vec4(v, expect, 0), "Post-reset element %u failed: (%f, %f, %f, %f) != (%f, %f, %f, %f)\n",
                     j, v->x, v->y, v->z, v->w, expect->x, expect->y, expect->z, expect->w);
         }
 
-- 
2.36.1

From 1591134b7edf44fe2a88159a777b8d0b1c3169bc Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 26 Nov 2021 14:02:31 +0100
Subject: [PATCH 12/42] tests: Add test for early and late indirect patching.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 tests/d3d12_command.c | 35 ++++++++++++++++++++---------------
 1 file changed, 20 insertions(+), 15 deletions(-)

diff --git a/tests/d3d12_command.c b/tests/d3d12_command.c
index 640c9bf6..075628b8 100644
--- a/tests/d3d12_command.c
+++ b/tests/d3d12_command.c
@@ -1460,6 +1460,7 @@ void test_execute_indirect_state(void)
     D3D12_SO_DECLARATION_ENTRY so_entries[1];
     ID3D12GraphicsCommandList *command_list;
     D3D12_ROOT_PARAMETER root_parameters[4];
+    ID3D12Resource *argument_buffer_late;
     D3D12_STREAM_OUTPUT_BUFFER_VIEW sov;
     ID3D12Resource *streamout_buffer;
     D3D12_VERTEX_BUFFER_VIEW vbvs[2];
@@ -1886,7 +1887,6 @@ void test_execute_indirect_state(void)
         const struct vec4 *expect, *v;
         uint32_t expected_output_size;
         uint32_t clear_vbo_mask;
-        bool clear_ibo;
         uint32_t size;
 
         vkd3d_test_set_context("Test %u", i);
@@ -1901,6 +1901,8 @@ void test_execute_indirect_state(void)
         ok(SUCCEEDED(hr), "Failed to create command signature, hr #%x.\n", hr);
 
         argument_buffer = create_upload_buffer(context.device, 256 * 1024, NULL);
+        argument_buffer_late = create_default_buffer(context.device, 256 * 1024,
+                D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COPY_DEST);
         {
             void *ptr;
             ID3D12Resource_Map(argument_buffer, 0, NULL, &ptr);
@@ -1945,6 +1947,12 @@ void test_execute_indirect_state(void)
         /* Test equivalent call with indirect count. */
         ID3D12GraphicsCommandList_ExecuteIndirect(command_list, command_signature, 1024,
                 argument_buffer, 0, count_buffer, 0);
+        /* Test equivalent, but now with late transition to INDIRECT. */
+        ID3D12GraphicsCommandList_CopyResource(command_list, argument_buffer_late, argument_buffer);
+        transition_resource_state(command_list, argument_buffer_late, D3D12_RESOURCE_STATE_COPY_DEST,
+                D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT);
+        ID3D12GraphicsCommandList_ExecuteIndirect(command_list, command_signature, 1024,
+                argument_buffer_late, 0, count_buffer, 0);
 
         /* Root descriptors which are part of the state block are cleared to NULL. Recover them here
          * since attempting to draw next test will crash GPU. */
@@ -1955,18 +1963,15 @@ void test_execute_indirect_state(void)
         ID3D12GraphicsCommandList_SetGraphicsRootUnorderedAccessView(command_list, 3,
                 ID3D12Resource_GetGPUVirtualAddress(uav));
 
-        /* Other state is cleared to 0. For testing sanity, reset the index buffer since we don't support NULL IBO yet. */
-        for (j = 0; j < tests[i].indirect_argument_count; j++)
-            if (tests[i].indirect_arguments[j].Type == D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW)
-                ID3D12GraphicsCommandList_IASetIndexBuffer(command_list, &ibv);
+        /* Other state is cleared to 0. */
 
-        ID3D12GraphicsCommandList_DrawIndexedInstanced(command_list, 2, 1, 0, 0, 0);
+        ID3D12GraphicsCommandList_DrawInstanced(command_list, 2, 1, 0, 0);
         transition_resource_state(command_list, streamout_buffer, D3D12_RESOURCE_STATE_STREAM_OUT, D3D12_RESOURCE_STATE_COPY_SOURCE);
 
         get_buffer_readback_with_command_list(streamout_buffer, DXGI_FORMAT_R32G32B32A32_FLOAT, &rb, queue, command_list);
         reset_command_list(command_list, context.allocator);
 
-        expected_output_size = (tests[i].expected_output_count * 2 + 2) * sizeof(struct vec4);
+        expected_output_size = (tests[i].expected_output_count * 3 + 2) * sizeof(struct vec4);
         size = get_readback_uint(&rb, 0, 0, 0);
         ok(size == expected_output_size, "Expected size %u, got %u.\n", expected_output_size, size);
 
@@ -1980,10 +1985,13 @@ void test_execute_indirect_state(void)
             v = get_readback_vec4(&rb, j + tests[i].expected_output_count + 1, 0);
             ok(compare_vec4(v, expect, 0), "Element (indirect count) %u failed: (%f, %f, %f, %f) != (%f, %f, %f, %f)\n",
                     j, v->x, v->y, v->z, v->w, expect->x, expect->y, expect->z, expect->w);
+
+            v = get_readback_vec4(&rb, j + 2 * tests[i].expected_output_count + 1, 0);
+            ok(compare_vec4(v, expect, 0), "Element (late latch) %u failed: (%f, %f, %f, %f) != (%f, %f, %f, %f)\n",
+                    j, v->x, v->y, v->z, v->w, expect->x, expect->y, expect->z, expect->w);
         }
 
         clear_vbo_mask = 0;
-        clear_ibo = false;
         expect_reset_state[0] = values;
 
         /* Root constant state is cleared to zero if it's part of the signature. */
@@ -1996,28 +2004,24 @@ void test_execute_indirect_state(void)
             }
             else if (tests[i].indirect_arguments[j].Type == D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW)
                 clear_vbo_mask |= 1u << tests[i].indirect_arguments[j].VertexBuffer.Slot;
-#if 0
-            else if (tests[i].indirect_arguments[j].Type == D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW)
-                clear_ibo = true;
-#endif
         }
 
         expect_reset_state[1] = expect_reset_state[0];
 
         /* VBO/IBO state is cleared to zero if it's part of the signature.
          * A NULL IBO should be seen as a IBO which only reads 0 index. */
-        if (!clear_ibo && !(clear_vbo_mask & (1u << 0)))
+        if (!(clear_vbo_mask & (1u << 0)))
             expect_reset_state[1].x += 1.0f;
 
         if (!(clear_vbo_mask & (1u << 1)))
         {
             expect_reset_state[0].y += 64.0f;
-            expect_reset_state[1].y += clear_ibo ? 64.0f : 65.0f;
+            expect_reset_state[1].y += 65.0f;
         }
 
         for (j = 0; j < 2; j++)
         {
-            v = get_readback_vec4(&rb, j + 1 + 2 * tests[i].expected_output_count, 0);
+            v = get_readback_vec4(&rb, j + 1 + 3 * tests[i].expected_output_count, 0);
             expect = &expect_reset_state[j];
             ok(compare_vec4(v, expect, 0), "Post-reset element %u failed: (%f, %f, %f, %f) != (%f, %f, %f, %f)\n",
                     j, v->x, v->y, v->z, v->w, expect->x, expect->y, expect->z, expect->w);
@@ -2025,6 +2029,7 @@ void test_execute_indirect_state(void)
 
         ID3D12CommandSignature_Release(command_signature);
         ID3D12Resource_Release(argument_buffer);
+        ID3D12Resource_Release(argument_buffer_late);
         ID3D12Resource_Release(count_buffer);
         ID3D12Resource_Release(streamout_buffer);
         release_resource_readback(&rb);
-- 
2.36.1

From a9583f4358fab47f36dda29b6e32fcd431f1fe2c Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 12 Jan 2022 12:58:46 +0100
Subject: [PATCH 13/42] tests: Add large root constant CBV to execute indirect
 advanced.

Tests that we can handle > 128 byte push constant blocks.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 tests/d3d12_command.c | 133 +++++++++++++++++++++++++++++++++++-------
 1 file changed, 112 insertions(+), 21 deletions(-)

diff --git a/tests/d3d12_command.c b/tests/d3d12_command.c
index 075628b8..00c1c9c1 100644
--- a/tests/d3d12_command.c
+++ b/tests/d3d12_command.c
@@ -1460,6 +1460,7 @@ void test_execute_indirect_state(void)
     D3D12_SO_DECLARATION_ENTRY so_entries[1];
     ID3D12GraphicsCommandList *command_list;
     D3D12_ROOT_PARAMETER root_parameters[4];
+    ID3D12RootSignature *root_signatures[2];
     ID3D12Resource *argument_buffer_late;
     D3D12_STREAM_OUTPUT_BUFFER_VIEW sov;
     ID3D12Resource *streamout_buffer;
@@ -1467,12 +1468,12 @@ void test_execute_indirect_state(void)
     ID3D12Resource *argument_buffer;
     struct test_context_desc desc;
     ID3D12Resource *count_buffer;
+    ID3D12PipelineState *psos[2];
     struct test_context context;
     struct resource_readback rb;
     D3D12_INDEX_BUFFER_VIEW ibv;
     ID3D12CommandQueue *queue;
     const UINT so_stride = 16;
-    ID3D12PipelineState *pso;
     ID3D12Resource *vbo[3];
     ID3D12Resource *ibo[2];
     unsigned int i, j, k;
@@ -1497,6 +1498,7 @@ void test_execute_indirect_state(void)
         const struct vec4 *expected_output;
         uint32_t expected_output_count;
         uint32_t stride;
+        uint32_t pso_index;
         bool needs_root_sig;
     };
 
@@ -1535,6 +1537,35 @@ void test_execute_indirect_state(void)
         { 1001.0f, 65.0f + 200.0f, 800.0f, 4001.0f },
     };
 
+    /* Modify root parameters, but very large root signature to test boundary conditions. */
+    static const D3D12_INDIRECT_ARGUMENT_DESC root_constant_spill_sig[2] =
+    {
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT, .Constant = {
+                .RootParameterIndex = 0, .DestOffsetIn32BitValues = 44 + 1, .Num32BitValuesToSet = 2 }},
+        { .Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED }
+    };
+
+    static const struct root_constant_data root_constant_spill_data[] =
+    {
+        {
+            .constants = { 100.0f, 500.0f },
+            .indexed = { .IndexCountPerInstance = 2, .InstanceCount = 1 }
+        },
+        {
+            .constants = { 200.0f, 800.0f },
+            .indexed = { .IndexCountPerInstance = 1, .InstanceCount = 2,
+                    .StartIndexLocation = 1, .StartInstanceLocation = 100, }
+        },
+    };
+
+    static const struct vec4 root_constant_spill_expected[] =
+    {
+        { 1000.0f, 64.0f + 100.0f, 500.0f, 4000.0f },
+        { 1001.0f, 65.0f + 100.0f, 500.0f, 4000.0f },
+        { 1001.0f, 65.0f + 200.0f, 800.0f, 4000.0f },
+        { 1001.0f, 65.0f + 200.0f, 800.0f, 4001.0f },
+    };
+
     /* Modify VBOs. */
     struct indirect_vbo_data
     {
@@ -1703,16 +1734,18 @@ void test_execute_indirect_state(void)
         { 1000.0f, 70.0f, 3128.0f, 4000.0f },
     };
 
-#define DECL_TEST(t, needs_root_sig) { t##_sig, ARRAY_SIZE(t##_sig), t##_data, sizeof(t##_data), ARRAY_SIZE(t##_data), \
-        t##_expected, ARRAY_SIZE(t##_expected), sizeof(*(t##_data)), needs_root_sig }
+#define DECL_TEST(t, pso_index, needs_root_sig) { t##_sig, ARRAY_SIZE(t##_sig), t##_data, sizeof(t##_data), ARRAY_SIZE(t##_data), \
+        t##_expected, ARRAY_SIZE(t##_expected), sizeof(*(t##_data)), pso_index, needs_root_sig }
     const struct test tests[] =
     {
-        DECL_TEST(root_constant, true),
-        DECL_TEST(indirect_vbo, false),
-        DECL_TEST(indirect_vbo_one, false),
-        DECL_TEST(indirect_ibo, false),
-        DECL_TEST(indirect_root_descriptor, true),
-        DECL_TEST(indirect_alignment, true),
+        DECL_TEST(root_constant, 0, true),
+        DECL_TEST(indirect_vbo, 0, false),
+        DECL_TEST(indirect_vbo_one, 0, false),
+        DECL_TEST(indirect_ibo, 0, false),
+        DECL_TEST(indirect_root_descriptor, 0, true),
+        DECL_TEST(indirect_alignment, 0, true),
+        DECL_TEST(root_constant_spill, 1, true),
+        DECL_TEST(indirect_root_descriptor, 1, true),
     };
 #undef DECL_TEST
 
@@ -1720,7 +1753,7 @@ void test_execute_indirect_state(void)
     float vbo_data[ARRAY_SIZE(vbo)][64];
     float generic_data[4096];
 
-    static const DWORD vs_code[] =
+    static const DWORD vs_code_small_cbv[] =
     {
 #if 0
     cbuffer RootCBV : register(b0)
@@ -1762,6 +1795,50 @@ void test_execute_indirect_state(void)
         0x00000000, 0x0100003e,
     };
 
+    static const DWORD vs_code_large_cbv[] =
+    {
+#if 0
+    cbuffer RootCBV : register(b0)
+    {
+        float a;
+    };
+
+    StructuredBuffer<float> RootSRV : register(t0);
+
+    cbuffer RootConstants : register(b0, space1)
+    {
+        // Cannot use arrays for root constants in D3D12.
+        float4 pad0, pad1, pad2, pad3, pad4, pad5, pad6, pad7, pad8, pad9, pad10;
+        float4 root;
+    };
+
+    float4 main(float c0 : COLOR0, float c1 : COLOR1, uint iid : SV_InstanceID) : SV_Position
+    {
+        return float4(c0, c1, a, RootSRV[0] + float(iid)) + root;
+    }
+#endif
+        0x43425844, 0x99a057e8, 0x20344569, 0x434f8a7a, 0xf9171e08, 0x00000001, 0x00000268, 0x00000003,
+        0x0000002c, 0x00000098, 0x000000cc, 0x4e475349, 0x00000064, 0x00000003, 0x00000008, 0x00000050,
+        0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000101, 0x00000050, 0x00000001, 0x00000000,
+        0x00000003, 0x00000001, 0x00000101, 0x00000056, 0x00000000, 0x00000008, 0x00000001, 0x00000002,
+        0x00000101, 0x4f4c4f43, 0x56530052, 0x736e495f, 0x636e6174, 0x00444965, 0x4e47534f, 0x0000002c,
+        0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000001, 0x00000003, 0x00000000, 0x0000000f,
+        0x505f5653, 0x7469736f, 0x006e6f69, 0x58454853, 0x00000194, 0x00010051, 0x00000065, 0x0100086a,
+        0x07000059, 0x00308e46, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x07000059,
+        0x00308e46, 0x00000001, 0x00000000, 0x00000000, 0x0000000c, 0x00000001, 0x070000a2, 0x00307e46,
+        0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0x0300005f, 0x00101012, 0x00000000,
+        0x0300005f, 0x00101012, 0x00000001, 0x04000060, 0x00101012, 0x00000002, 0x00000008, 0x04000067,
+        0x001020f2, 0x00000000, 0x00000001, 0x02000068, 0x00000001, 0x0a0000a7, 0x00100012, 0x00000000,
+        0x00004001, 0x00000000, 0x00004001, 0x00000000, 0x00207006, 0x00000000, 0x00000000, 0x05000056,
+        0x00100022, 0x00000000, 0x0010100a, 0x00000002, 0x07000000, 0x00100012, 0x00000000, 0x0010001a,
+        0x00000000, 0x0010000a, 0x00000000, 0x09000000, 0x00102012, 0x00000000, 0x0010100a, 0x00000000,
+        0x0030800a, 0x00000001, 0x00000000, 0x0000000b, 0x09000000, 0x00102022, 0x00000000, 0x0010100a,
+        0x00000001, 0x0030801a, 0x00000001, 0x00000000, 0x0000000b, 0x0b000000, 0x00102042, 0x00000000,
+        0x0030800a, 0x00000000, 0x00000000, 0x00000000, 0x0030802a, 0x00000001, 0x00000000, 0x0000000b,
+        0x09000000, 0x00102082, 0x00000000, 0x0010000a, 0x00000000, 0x0030803a, 0x00000001, 0x00000000,
+        0x0000000b, 0x0100003e,
+    };
+
     memset(&desc, 0, sizeof(desc));
     desc.no_root_signature = true;
     desc.no_pipeline = true;
@@ -1828,7 +1905,10 @@ void test_execute_indirect_state(void)
     root_parameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_SRV;
     root_parameters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
     root_parameters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_UAV;
-    hr = create_root_signature(context.device, &root_signature_desc, &context.root_signature);
+    hr = create_root_signature(context.device, &root_signature_desc, &root_signatures[0]);
+    ok(SUCCEEDED(hr), "Failed to create root signature, hr #%x.\n", hr);
+    root_parameters[0].Constants.Num32BitValues = 48;
+    hr = create_root_signature(context.device, &root_signature_desc, &root_signatures[1]);
     ok(SUCCEEDED(hr), "Failed to create root signature, hr #%x.\n", hr);
 
     memset(so_entries, 0, sizeof(so_entries));
@@ -1836,21 +1916,26 @@ void test_execute_indirect_state(void)
     so_entries[0].SemanticName = "SV_Position";
 
     memset(&pso_desc, 0, sizeof(pso_desc));
-    pso_desc.VS.pShaderBytecode = vs_code;
-    pso_desc.VS.BytecodeLength = sizeof(vs_code);
+    pso_desc.VS.pShaderBytecode = vs_code_small_cbv;
+    pso_desc.VS.BytecodeLength = sizeof(vs_code_small_cbv);
     pso_desc.StreamOutput.NumStrides = 1;
     pso_desc.StreamOutput.pBufferStrides = &so_stride;
     pso_desc.StreamOutput.pSODeclaration = so_entries;
     pso_desc.StreamOutput.NumEntries = ARRAY_SIZE(so_entries);
     pso_desc.StreamOutput.RasterizedStream = D3D12_SO_NO_RASTERIZED_STREAM;
-    pso_desc.pRootSignature = context.root_signature;
+    pso_desc.pRootSignature = root_signatures[0];
     pso_desc.SampleDesc.Count = 1;
     pso_desc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT;
     pso_desc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID;
     pso_desc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
     pso_desc.InputLayout.NumElements = ARRAY_SIZE(layout_desc);
     pso_desc.InputLayout.pInputElementDescs = layout_desc;
-    hr = ID3D12Device_CreateGraphicsPipelineState(context.device, &pso_desc, &IID_ID3D12PipelineState, (void**)&pso);
+    hr = ID3D12Device_CreateGraphicsPipelineState(context.device, &pso_desc, &IID_ID3D12PipelineState, (void**)&psos[0]);
+    ok(SUCCEEDED(hr), "Failed to create PSO, hr #%x.\n", hr);
+    pso_desc.VS.pShaderBytecode = vs_code_large_cbv;
+    pso_desc.VS.BytecodeLength = sizeof(vs_code_large_cbv);
+    pso_desc.pRootSignature = root_signatures[1];
+    hr = ID3D12Device_CreateGraphicsPipelineState(context.device, &pso_desc, &IID_ID3D12PipelineState, (void**)&psos[1]);
     ok(SUCCEEDED(hr), "Failed to create PSO, hr #%x.\n", hr);
 
     /* Verify sanity checks.
@@ -1896,7 +1981,7 @@ void test_execute_indirect_state(void)
         command_signature_desc.NumArgumentDescs = tests[i].indirect_argument_count;
         command_signature_desc.NodeMask = 0;
         hr = ID3D12Device_CreateCommandSignature(context.device, &command_signature_desc,
-                tests[i].needs_root_sig ? context.root_signature : NULL,
+                tests[i].needs_root_sig ? root_signatures[tests[i].pso_index] : NULL,
                 &IID_ID3D12CommandSignature, (void**)&command_signature);
         ok(SUCCEEDED(hr), "Failed to create command signature, hr #%x.\n", hr);
 
@@ -1914,8 +1999,8 @@ void test_execute_indirect_state(void)
         streamout_buffer = create_default_buffer(context.device, 64 * 1024,
                 D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_STREAM_OUT);
 
-        ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, context.root_signature);
-        ID3D12GraphicsCommandList_SetPipelineState(command_list, pso);
+        ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, root_signatures[tests[i].pso_index]);
+        ID3D12GraphicsCommandList_SetPipelineState(command_list, psos[tests[i].pso_index]);
         sov.SizeInBytes = 64 * 1024 - sizeof(struct vec4);
         sov.BufferLocation = ID3D12Resource_GetGPUVirtualAddress(streamout_buffer) + sizeof(struct vec4);
         sov.BufferFilledSizeLocation = ID3D12Resource_GetGPUVirtualAddress(streamout_buffer);
@@ -1935,7 +2020,10 @@ void test_execute_indirect_state(void)
         ID3D12GraphicsCommandList_IASetIndexBuffer(command_list, &ibv);
         ID3D12GraphicsCommandList_IASetPrimitiveTopology(command_list, D3D_PRIMITIVE_TOPOLOGY_POINTLIST);
         ID3D12GraphicsCommandList_IASetVertexBuffers(command_list, 0, 2, vbvs);
-        ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstants(command_list, 0, 4, &values, 0);
+
+        for (j = 0; j < (tests[i].pso_index ? 12 : 1); j++)
+            ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstants(command_list, 0, 4, &values, 4 * j);
+
         ID3D12GraphicsCommandList_SetGraphicsRootConstantBufferView(command_list, 1,
                 ID3D12Resource_GetGPUVirtualAddress(cbv));
         ID3D12GraphicsCommandList_SetGraphicsRootShaderResourceView(command_list, 2,
@@ -2000,7 +2088,7 @@ void test_execute_indirect_state(void)
             if (tests[i].indirect_arguments[j].Type == D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT)
             {
                 for (k = 0; k < tests[i].indirect_arguments[j].Constant.Num32BitValuesToSet; k++)
-                    (&expect_reset_state[0].x)[tests[i].indirect_arguments[j].Constant.DestOffsetIn32BitValues + k] = 0.0f;
+                    (&expect_reset_state[0].x)[(tests[i].indirect_arguments[j].Constant.DestOffsetIn32BitValues + k) % 4] = 0.0f;
             }
             else if (tests[i].indirect_arguments[j].Type == D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW)
                 clear_vbo_mask |= 1u << tests[i].indirect_arguments[j].VertexBuffer.Slot;
@@ -2036,7 +2124,10 @@ void test_execute_indirect_state(void)
     }
     vkd3d_test_set_context(NULL);
 
-    ID3D12PipelineState_Release(pso);
+    for (i = 0; i < ARRAY_SIZE(psos); i++)
+        ID3D12PipelineState_Release(psos[i]);
+    for (i = 0; i < ARRAY_SIZE(root_signatures); i++)
+        ID3D12RootSignature_Release(root_signatures[i]);
     for (i = 0; i < ARRAY_SIZE(vbo); i++)
         ID3D12Resource_Release(vbo[i]);
     for (i = 0; i < ARRAY_SIZE(ibo); i++)
-- 
2.36.1

From 124768c1d6a46715b5087bdd10861784857474b3 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 26 Nov 2021 13:51:51 +0100
Subject: [PATCH 14/42] vkd3d: Optimize ExecuteIndirect() if no INDIRECT
 transitions happened.

The D3D12 docs outline this as an implementation detail explicitly, so
we should do the same thing.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c       | 85 ++++++++++++++++++++++++++------------
 libs/vkd3d/vkd3d_private.h |  6 +++
 2 files changed, 65 insertions(+), 26 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 3af25d3b..6ef41361 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -4055,6 +4055,7 @@ static HRESULT d3d12_command_list_batch_reset_query_pools(struct d3d12_command_l
 static HRESULT d3d12_command_list_build_init_commands(struct d3d12_command_list *list)
 {
     const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
+    VkMemoryBarrier barrier;
     VkResult vr;
     HRESULT hr;
 
@@ -4064,6 +4065,18 @@ static HRESULT d3d12_command_list_build_init_commands(struct d3d12_command_list
     if (!list->vk_init_commands)
         return S_OK;
 
+    if (list->execute_indirect.has_emitted_indirect_to_compute_barrier)
+    {
+        /* We've patched an indirect command stream here, so do the final barrier now. */
+        barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
+        barrier.pNext = NULL;
+        barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+        barrier.dstAccessMask = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV | VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
+        VK_CALL(vkCmdPipelineBarrier(list->vk_init_commands, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV,
+                0, 1, &barrier, 0, NULL, 0, NULL));
+    }
+
     if ((vr = VK_CALL(vkEndCommandBuffer(list->vk_init_commands))) < 0)
     {
         WARN("Failed to end command buffer, vr %d.\n", vr);
@@ -4366,6 +4379,8 @@ static void d3d12_command_list_reset_internal_state(struct d3d12_command_list *l
     list->tracked_copy_buffer_count = 0;
 
     list->rendering_info.state_flags = 0;
+    list->execute_indirect.has_emitted_indirect_to_compute_barrier = false;
+    list->execute_indirect.has_observed_transition_to_indirect = false;
 }
 
 static void d3d12_command_list_reset_state(struct d3d12_command_list *list,
@@ -7145,6 +7160,13 @@ static void STDMETHODCALLTYPE d3d12_command_list_ResourceBarrier(d3d12_command_l
                 VkImageLayout new_layout = VK_IMAGE_LAYOUT_UNDEFINED;
                 uint32_t dsv_decay_mask = 0;
 
+                /* If we have not observed any transition to INDIRECT_ARGUMENT it means
+                 * that in this command buffer there couldn't legally have been writes to an indirect
+                 * command buffer. The docs mention an implementation strategy where we can do this optimization.
+                 * This is very handy when handling back-to-back ExecuteIndirects(). */
+                if (transition->StateAfter == D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT)
+                    list->execute_indirect.has_observed_transition_to_indirect = true;
+
                 if (!is_valid_resource_state(transition->StateBefore))
                 {
                     d3d12_command_list_mark_as_invalid(list,
@@ -9432,6 +9454,7 @@ static void d3d12_command_list_execute_indirect_state_template(
     struct vkd3d_scratch_allocation count_allocation;
     struct vkd3d_execute_indirect_args patch_args;
     VkGeneratedCommandsInfoNV generated;
+    VkCommandBuffer vk_patch_cmd_buffer;
     VkIndirectCommandsStreamNV stream;
     VkDeviceSize preprocess_size;
     VkPipeline current_pipeline;
@@ -9450,16 +9473,6 @@ static void d3d12_command_list_execute_indirect_state_template(
         return;
     current_pipeline = list->current_pipeline;
 
-    /* FIXME: If we're forced to emit non-dynamic vertex strides, and the indirect state
-     * wants to emit dynamic VBOs (dynamic stride), can that possibly work? Extremely unlikely to
-     * actually happen in practice, but something to consider for later ... */
-
-    /* TODO: If we can prove that there have been no transitions to INDIRECT state,
-     * we can hoist all patch jobs to the beginning of the command buffer and build a fixup
-     * command buffer that batches everything. For now, take the slow path always. */
-    d3d12_command_list_end_current_render_pass(list, true);
-    d3d12_command_list_invalidate_current_pipeline(list, true);
-
     memset(&patch_args, 0, sizeof(patch_args));
     if (FAILED(hr = d3d12_command_signature_allocate_preprocess_memory_for_list(
             list, signature, current_pipeline,
@@ -9496,31 +9509,51 @@ static void d3d12_command_list_execute_indirect_state_template(
     patch_args.api_buffer_word_stride = signature->desc.ByteStride / sizeof(uint32_t);
     patch_args.device_generated_commands_word_stride = signature->state_template.stride / sizeof(uint32_t);
 
-    VK_CALL(vkCmdPushConstants(list->vk_command_buffer, signature->state_template.pipeline.vk_pipeline_layout,
-            VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(patch_args), &patch_args));
-    VK_CALL(vkCmdBindPipeline(list->vk_command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
-            signature->state_template.pipeline.vk_pipeline));
-
-    /* TODO: We can batch the {prologue barrier} { work } { work } ... {epilogue barrier} later. */
-    /* The argument buffer and indirect count buffers are in indirect state, but we'll need to read it. */
     barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
     barrier.pNext = NULL;
-
     barrier.srcAccessMask = 0;
     barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
-    VK_CALL(vkCmdPipelineBarrier(list->vk_command_buffer, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
-            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 1, &barrier, 0, NULL, 0, NULL));
+
+    if (!list->execute_indirect.has_observed_transition_to_indirect)
+    {
+        /* Fast path, throw the template resolve to the init command buffer. */
+        d3d12_command_allocator_allocate_init_command_buffer(list->allocator, list);
+        vk_patch_cmd_buffer = list->vk_init_commands;
+        if (!list->execute_indirect.has_emitted_indirect_to_compute_barrier)
+        {
+            VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+                    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 1, &barrier, 0, NULL, 0, NULL));
+            list->execute_indirect.has_emitted_indirect_to_compute_barrier = true;
+        }
+    }
+    else
+    {
+        vk_patch_cmd_buffer = list->vk_command_buffer;
+        VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+                VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 1, &barrier, 0, NULL, 0, NULL));
+        d3d12_command_list_end_current_render_pass(list, true);
+        d3d12_command_list_invalidate_current_pipeline(list, true);
+    }
+
+    VK_CALL(vkCmdPushConstants(vk_patch_cmd_buffer, signature->state_template.pipeline.vk_pipeline_layout,
+            VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(patch_args), &patch_args));
+    VK_CALL(vkCmdBindPipeline(vk_patch_cmd_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
+            signature->state_template.pipeline.vk_pipeline));
 
     /* One workgroup processes the patching for one draw. We could potentially use indirect dispatch
      * to restrict the patching work to just the indirect count, but meh, just more barriers.
      * We'll nop out the workgroup early based on direct count, and the number of threads should be trivial either way. */
-    VK_CALL(vkCmdDispatch(list->vk_command_buffer, max_command_count, 1, 1));
+    VK_CALL(vkCmdDispatch(vk_patch_cmd_buffer, max_command_count, 1, 1));
 
-    barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
-    barrier.dstAccessMask = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV | VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
-    VK_CALL(vkCmdPipelineBarrier(list->vk_command_buffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
-            VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV,
-            0, 1, &barrier, 0, NULL, 0, NULL));
+    if (vk_patch_cmd_buffer == list->vk_command_buffer)
+    {
+        barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+        barrier.dstAccessMask = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV | VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
+        VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV,
+                0, 1, &barrier, 0, NULL, 0, NULL));
+        /* The barrier is deferred if we moved the dispatch to init command buffer. */
+    }
 
     if (!d3d12_command_list_begin_render_pass(list))
     {
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index ebb9febd..abc6caa3 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -2077,6 +2077,12 @@ struct d3d12_command_list
         bool is_dirty;
     } index_buffer;
 
+    struct
+    {
+        bool has_observed_transition_to_indirect;
+        bool has_emitted_indirect_to_compute_barrier;
+    } execute_indirect;
+
     VkCommandBuffer vk_command_buffer;
     VkCommandBuffer vk_init_commands;
 
-- 
2.36.1

From 186b45a61faab7e88b32cad4b1bcd80a387fa1df Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 7 Jan 2022 13:47:17 +0100
Subject: [PATCH 15/42] vkd3d: Pass down required memory types to scratch
 allocators.

Separate scratch pools by their intended usage. Allows e.g. preprocess buffers to be
allocated differently from normal buffers. Potentially can also allow
for separate pools for host visible scratch memory etc down the line.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c       | 76 +++++++++++++++++------------
 libs/vkd3d/device.c        | 97 +++++++++++++++++++++++++++-----------
 libs/vkd3d/vkd3d_private.h | 33 ++++++++++---
 3 files changed, 142 insertions(+), 64 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 6ef41361..a075b48c 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -1546,7 +1546,7 @@ static ULONG STDMETHODCALLTYPE d3d12_command_allocator_Release(ID3D12CommandAllo
 {
     struct d3d12_command_allocator *allocator = impl_from_ID3D12CommandAllocator(iface);
     ULONG refcount = InterlockedDecrement(&allocator->refcount);
-    unsigned int i;
+    unsigned int i, j;
 
     TRACE("%p decreasing refcount to %u.\n", allocator, refcount);
 
@@ -1602,13 +1602,16 @@ static ULONG STDMETHODCALLTYPE d3d12_command_allocator_Release(ID3D12CommandAllo
         vkd3d_free(allocator->command_buffers);
         VK_CALL(vkDestroyCommandPool(device->vk_device, allocator->vk_command_pool, NULL));
 
-        for (i = 0; i < allocator->scratch_buffer_count; i++)
-            d3d12_device_return_scratch_buffer(device, &allocator->scratch_buffers[i]);
+        for (i = 0; i < VKD3D_SCRATCH_POOL_KIND_COUNT; i++)
+        {
+            for (j = 0; j < allocator->scratch_pools[i].scratch_buffer_count; j++)
+                d3d12_device_return_scratch_buffer(device, i, &allocator->scratch_pools[i].scratch_buffers[j]);
+            vkd3d_free(allocator->scratch_pools[i].scratch_buffers);
+        }
 
         for (i = 0; i < allocator->query_pool_count; i++)
             d3d12_device_return_query_pool(device, &allocator->query_pools[i]);
 
-        vkd3d_free(allocator->scratch_buffers);
         vkd3d_free(allocator->query_pools);
 
 #ifdef VKD3D_ENABLE_BREADCRUMBS
@@ -1677,7 +1680,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_allocator_Reset(ID3D12CommandAllo
     struct d3d12_device *device;
     LONG pending;
     VkResult vr;
-    size_t i;
+    size_t i, j;
 
     TRACE("iface %p.\n", iface);
 
@@ -1728,8 +1731,12 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_allocator_Reset(ID3D12CommandAllo
     }
 
     /* Return scratch buffers to the device */
-    for (i = 0; i < allocator->scratch_buffer_count; i++)
-        d3d12_device_return_scratch_buffer(device, &allocator->scratch_buffers[i]);
+    for (i = 0; i < VKD3D_SCRATCH_POOL_KIND_COUNT; i++)
+    {
+        for (j = 0; j < allocator->scratch_pools[i].scratch_buffer_count; j++)
+            d3d12_device_return_scratch_buffer(device, i, &allocator->scratch_pools[i].scratch_buffers[j]);
+        allocator->scratch_pools[i].scratch_buffer_count = 0;
+    }
 
 #ifdef VKD3D_ENABLE_BREADCRUMBS
     if (vkd3d_config_flags & VKD3D_CONFIG_FLAG_BREADCRUMBS)
@@ -1741,8 +1748,6 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_allocator_Reset(ID3D12CommandAllo
     }
 #endif
 
-    allocator->scratch_buffer_count = 0;
-
     /* Return query pools to the device */
     for (i = 0; i < allocator->query_pool_count; i++)
         d3d12_device_return_query_pool(device, &allocator->query_pools[i]);
@@ -1900,9 +1905,7 @@ static HRESULT d3d12_command_allocator_init(struct d3d12_command_allocator *allo
     allocator->command_buffers_size = 0;
     allocator->command_buffer_count = 0;
 
-    allocator->scratch_buffers = NULL;
-    allocator->scratch_buffers_size = 0;
-    allocator->scratch_buffer_count = 0;
+    memset(allocator->scratch_pools, 0, sizeof(allocator->scratch_pools));
 
     allocator->query_pools = NULL;
     allocator->query_pools_size = 0;
@@ -1952,8 +1955,11 @@ struct vkd3d_scratch_allocation
 };
 
 static bool d3d12_command_allocator_allocate_scratch_memory(struct d3d12_command_allocator *allocator,
-        VkDeviceSize size, VkDeviceSize alignment, struct vkd3d_scratch_allocation *allocation)
+        enum vkd3d_scratch_pool_kind kind,
+        VkDeviceSize size, VkDeviceSize alignment, uint32_t memory_types,
+        struct vkd3d_scratch_allocation *allocation)
 {
+    struct d3d12_command_allocator_scratch_pool *pool = &allocator->scratch_pools[kind];
     VkDeviceSize aligned_offset, aligned_size;
     struct vkd3d_scratch_buffer *scratch;
     unsigned int i;
@@ -1961,9 +1967,14 @@ static bool d3d12_command_allocator_allocate_scratch_memory(struct d3d12_command
     aligned_size = align(size, alignment);
 
     /* Probe last block first since the others are likely full */
-    for (i = allocator->scratch_buffer_count; i; i--)
+    for (i = pool->scratch_buffer_count; i; i--)
     {
-        scratch = &allocator->scratch_buffers[i - 1];
+        scratch = &pool->scratch_buffers[i - 1];
+
+        /* Extremely unlikely to fail since we have separate lists per pool kind, but to be 100% correct ... */
+        if (!(memory_types & (1u << scratch->allocation.device_allocation.vk_memory_type)))
+            continue;
+
         aligned_offset = align(scratch->offset, alignment);
 
         if (aligned_offset + aligned_size <= scratch->allocation.resource.size)
@@ -1977,21 +1988,21 @@ static bool d3d12_command_allocator_allocate_scratch_memory(struct d3d12_command
         }
     }
 
-    if (!vkd3d_array_reserve((void**)&allocator->scratch_buffers, &allocator->scratch_buffers_size,
-            allocator->scratch_buffer_count + 1, sizeof(*allocator->scratch_buffers)))
+    if (!vkd3d_array_reserve((void**)&pool->scratch_buffers, &pool->scratch_buffers_size,
+            pool->scratch_buffer_count + 1, sizeof(*pool->scratch_buffers)))
     {
         ERR("Failed to allocate scratch buffer.\n");
         return false;
     }
 
-    scratch = &allocator->scratch_buffers[allocator->scratch_buffer_count];
-    if (FAILED(d3d12_device_get_scratch_buffer(allocator->device, aligned_size, scratch)))
+    scratch = &pool->scratch_buffers[pool->scratch_buffer_count];
+    if (FAILED(d3d12_device_get_scratch_buffer(allocator->device, kind, aligned_size, memory_types, scratch)))
     {
         ERR("Failed to create scratch buffer.\n");
         return false;
     }
 
-    allocator->scratch_buffer_count += 1;
+    pool->scratch_buffer_count += 1;
     scratch->offset = aligned_size;
 
     allocation->buffer = scratch->allocation.resource.vk_buffer;
@@ -3380,7 +3391,8 @@ static bool d3d12_command_list_gather_pending_queries(struct d3d12_command_list
 
     /* Allocate scratch buffer and resolve virtual Vulkan queries into it */
     if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
-            resolve_buffer_size, max(ssbo_alignment, sizeof(uint64_t)), &resolve_buffer))
+            VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
+            resolve_buffer_size, max(ssbo_alignment, sizeof(uint64_t)), ~0u, &resolve_buffer))
         goto cleanup;
 
     for (i = 0; i < resolve_count; i++)
@@ -3397,7 +3409,8 @@ static bool d3d12_command_list_gather_pending_queries(struct d3d12_command_list
     entry_buffer_size = sizeof(struct query_entry) * list->pending_queries_count;
 
     if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
-            entry_buffer_size, ssbo_alignment, &entry_buffer))
+            VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
+            entry_buffer_size, ssbo_alignment, ~0u, &entry_buffer))
         goto cleanup;
 
     for (i = 0; i < dispatch_count; i++)
@@ -5409,7 +5422,8 @@ static bool d3d12_command_list_emit_predicated_command(struct d3d12_command_list
     vkd3d_meta_get_predicate_pipeline(&list->device->meta_ops, command_type, &pipeline_info);
 
     if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
-            pipeline_info.data_size, sizeof(uint32_t), scratch))
+            VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
+            pipeline_info.data_size, sizeof(uint32_t), ~0u, scratch))
         return false;
 
     d3d12_command_list_end_current_render_pass(list, true);
@@ -9228,7 +9242,8 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetPredication(d3d12_command_li
     if (resource)
     {
         if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
-                sizeof(uint32_t), sizeof(uint32_t), &scratch))
+                VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
+                sizeof(uint32_t), sizeof(uint32_t), ~0u, &scratch))
             return;
 
         begin_info.sType = VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT;
@@ -9492,9 +9507,10 @@ static void d3d12_command_list_execute_indirect_state_template(
     if (count_buffer)
     {
         if (FAILED(hr = d3d12_command_allocator_allocate_scratch_memory(list->allocator,
+                VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
                 sizeof(uint32_t),
                 list->device->device_info.device_generated_commands_properties_nv.minSequencesCountBufferOffsetAlignment,
-                &count_allocation)))
+                ~0u, &count_allocation)))
         {
             WARN("Failed to allocate count memory.\n");
             return;
@@ -12637,9 +12653,10 @@ static HRESULT d3d12_command_signature_allocate_stream_memory_for_list(
         struct vkd3d_scratch_allocation *allocation)
 {
     if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
+            VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
             max_command_count * signature->state_template.stride,
             list->device->device_info.device_generated_commands_properties_nv.minIndirectCommandsBufferOffsetAlignment,
-            allocation))
+            ~0u, allocation))
         return E_OUTOFMEMORY;
 
     return S_OK;
@@ -12675,12 +12692,13 @@ static HRESULT d3d12_command_signature_allocate_preprocess_memory_for_list(
 
     VK_CALL(vkGetGeneratedCommandsMemoryRequirementsNV(list->device->vk_device, &info, &memory_info));
 
-    if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator, memory_info.memoryRequirements.size,
+    if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
+            VKD3D_SCRATCH_POOL_KIND_INDIRECT_PREPROCESS,
+            memory_info.memoryRequirements.size,
             list->device->device_info.device_generated_commands_properties_nv.minIndirectCommandsBufferOffsetAlignment,
-            allocation))
+            memory_info.memoryRequirements.memoryTypeBits, allocation))
         return E_OUTOFMEMORY;
 
-    /* Going to assume the memory type is okay ... It's device local after all. */
     *size = memory_info.memoryRequirements.size;
     return S_OK;
 }
diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index 56bf9022..1d631ce0 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -2546,22 +2546,50 @@ static void d3d12_remove_device_singleton(LUID luid)
     }
 }
 
-static HRESULT d3d12_device_create_scratch_buffer(struct d3d12_device *device, VkDeviceSize size, struct vkd3d_scratch_buffer *scratch)
+static HRESULT d3d12_device_create_scratch_buffer(struct d3d12_device *device, enum vkd3d_scratch_pool_kind kind,
+        VkDeviceSize size, uint32_t memory_types, struct vkd3d_scratch_buffer *scratch)
 {
-    struct vkd3d_allocate_heap_memory_info alloc_info;
     HRESULT hr;
 
     TRACE("device %p, size %llu, scratch %p.\n", device, size, scratch);
 
-    memset(&alloc_info, 0, sizeof(alloc_info));
-    alloc_info.heap_desc.Properties.Type = D3D12_HEAP_TYPE_DEFAULT;
-    alloc_info.heap_desc.SizeInBytes = size;
-    alloc_info.heap_desc.Alignment = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;
-    alloc_info.heap_desc.Flags = D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS;
+    if (kind == VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE)
+    {
+        struct vkd3d_allocate_heap_memory_info alloc_info;
 
-    if (FAILED(hr = vkd3d_allocate_heap_memory(device, &device->memory_allocator,
-            &alloc_info, &scratch->allocation)))
-        return hr;
+        /* We only care about memory types for INDIRECT_PREPROCESS. */
+        assert(memory_types == ~0u);
+
+        memset(&alloc_info, 0, sizeof(alloc_info));
+        alloc_info.heap_desc.Properties.Type = D3D12_HEAP_TYPE_DEFAULT;
+        alloc_info.heap_desc.SizeInBytes = size;
+        alloc_info.heap_desc.Alignment = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;
+        alloc_info.heap_desc.Flags = D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS | D3D12_HEAP_FLAG_CREATE_NOT_ZEROED;
+
+        if (FAILED(hr = vkd3d_allocate_heap_memory(device, &device->memory_allocator,
+                &alloc_info, &scratch->allocation)))
+            return hr;
+    }
+    else if (kind == VKD3D_SCRATCH_POOL_KIND_INDIRECT_PREPROCESS)
+    {
+        struct vkd3d_allocate_memory_info alloc_info;
+        memset(&alloc_info, 0, sizeof(alloc_info));
+
+        alloc_info.heap_properties.Type = D3D12_HEAP_TYPE_DEFAULT;
+        alloc_info.memory_requirements.size = size;
+        alloc_info.memory_requirements.memoryTypeBits = memory_types;
+        alloc_info.heap_flags = D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS | D3D12_HEAP_FLAG_CREATE_NOT_ZEROED;
+        alloc_info.optional_memory_properties = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
+        alloc_info.flags = VKD3D_ALLOCATION_FLAG_GLOBAL_BUFFER;
+
+        if (FAILED(hr = vkd3d_allocate_memory(device, &device->memory_allocator,
+                &alloc_info, &scratch->allocation)))
+            return hr;
+    }
+    else
+    {
+        return E_INVALIDARG;
+    }
 
     scratch->offset = 0;
     return S_OK;
@@ -2574,35 +2602,47 @@ static void d3d12_device_destroy_scratch_buffer(struct d3d12_device *device, con
     vkd3d_free_memory(device, &device->memory_allocator, &scratch->allocation);
 }
 
-HRESULT d3d12_device_get_scratch_buffer(struct d3d12_device *device, VkDeviceSize min_size, struct vkd3d_scratch_buffer *scratch)
+HRESULT d3d12_device_get_scratch_buffer(struct d3d12_device *device, enum vkd3d_scratch_pool_kind kind,
+        VkDeviceSize min_size, uint32_t memory_types, struct vkd3d_scratch_buffer *scratch)
 {
+    struct d3d12_device_scratch_pool *pool = &device->scratch_pools[kind];
+    struct vkd3d_scratch_buffer *candidate;
+    size_t i;
+
     if (min_size > VKD3D_SCRATCH_BUFFER_SIZE)
-        return d3d12_device_create_scratch_buffer(device, min_size, scratch);
+        return d3d12_device_create_scratch_buffer(device, kind, min_size, memory_types, scratch);
 
     pthread_mutex_lock(&device->mutex);
 
-    if (device->scratch_buffer_count)
-    {
-        *scratch = device->scratch_buffers[--device->scratch_buffer_count];
-        scratch->offset = 0;
-        pthread_mutex_unlock(&device->mutex);
-        return S_OK;
-    }
-    else
+    for (i = pool->scratch_buffer_count; i; i--)
     {
-        pthread_mutex_unlock(&device->mutex);
-        return d3d12_device_create_scratch_buffer(device, VKD3D_SCRATCH_BUFFER_SIZE, scratch);
+        candidate = &pool->scratch_buffers[i - 1];
+
+        /* Extremely unlikely to fail since we have separate lists per pool kind, but to be 100% correct ... */
+        if (memory_types & (1u << candidate->allocation.device_allocation.vk_memory_type))
+        {
+            *scratch = *candidate;
+            scratch->offset = 0;
+            pool->scratch_buffers[i - 1] = pool->scratch_buffers[--pool->scratch_buffer_count];
+            pthread_mutex_unlock(&device->mutex);
+            return S_OK;
+        }
     }
+
+    pthread_mutex_unlock(&device->mutex);
+    return d3d12_device_create_scratch_buffer(device, kind, VKD3D_SCRATCH_BUFFER_SIZE, memory_types, scratch);
 }
 
-void d3d12_device_return_scratch_buffer(struct d3d12_device *device, const struct vkd3d_scratch_buffer *scratch)
+void d3d12_device_return_scratch_buffer(struct d3d12_device *device, enum vkd3d_scratch_pool_kind kind,
+        const struct vkd3d_scratch_buffer *scratch)
 {
+    struct d3d12_device_scratch_pool *pool = &device->scratch_pools[kind];
     pthread_mutex_lock(&device->mutex);
 
     if (scratch->allocation.resource.size == VKD3D_SCRATCH_BUFFER_SIZE &&
-            device->scratch_buffer_count < VKD3D_SCRATCH_BUFFER_COUNT)
+            pool->scratch_buffer_count < VKD3D_SCRATCH_BUFFER_COUNT)
     {
-        device->scratch_buffers[device->scratch_buffer_count++] = *scratch;
+        pool->scratch_buffers[pool->scratch_buffer_count++] = *scratch;
         pthread_mutex_unlock(&device->mutex);
     }
     else
@@ -2863,10 +2903,11 @@ static void d3d12_device_global_pipeline_cache_cleanup(struct d3d12_device *devi
 static void d3d12_device_destroy(struct d3d12_device *device)
 {
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
-    size_t i;
+    size_t i, j;
 
-    for (i = 0; i < device->scratch_buffer_count; i++)
-        d3d12_device_destroy_scratch_buffer(device, &device->scratch_buffers[i]);
+    for (i = 0; i < VKD3D_SCRATCH_POOL_KIND_COUNT; i++)
+        for (j = 0; j < device->scratch_pools[i].scratch_buffer_count; j++)
+            d3d12_device_destroy_scratch_buffer(device, &device->scratch_pools[i].scratch_buffers[j]);
 
     for (i = 0; i < device->query_pool_count; i++)
         d3d12_device_destroy_query_pool(device, &device->query_pools[i]);
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index abc6caa3..17a64548 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -1837,6 +1837,20 @@ struct vkd3d_query_pool
     uint32_t next_index;
 };
 
+struct d3d12_command_allocator_scratch_pool
+{
+    struct vkd3d_scratch_buffer *scratch_buffers;
+    size_t scratch_buffers_size;
+    size_t scratch_buffer_count;
+};
+
+enum vkd3d_scratch_pool_kind
+{
+    VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE = 0,
+    VKD3D_SCRATCH_POOL_KIND_INDIRECT_PREPROCESS,
+    VKD3D_SCRATCH_POOL_KIND_COUNT
+};
+
 /* ID3D12CommandAllocator */
 struct d3d12_command_allocator
 {
@@ -1863,9 +1877,7 @@ struct d3d12_command_allocator
     size_t command_buffers_size;
     size_t command_buffer_count;
 
-    struct vkd3d_scratch_buffer *scratch_buffers;
-    size_t scratch_buffers_size;
-    size_t scratch_buffer_count;
+    struct d3d12_command_allocator_scratch_pool scratch_pools[VKD3D_SCRATCH_POOL_KIND_COUNT];
 
     struct vkd3d_query_pool *query_pools;
     size_t query_pools_size;
@@ -3207,6 +3219,12 @@ struct vkd3d_descriptor_qa_heap_buffer_data;
 /* ID3D12DeviceExt */
 typedef ID3D12DeviceExt d3d12_device_vkd3d_ext_iface;
 
+struct d3d12_device_scratch_pool
+{
+    struct vkd3d_scratch_buffer scratch_buffers[VKD3D_SCRATCH_BUFFER_COUNT];
+    size_t scratch_buffer_count;
+};
+
 struct d3d12_device
 {
     d3d12_device_iface ID3D12Device_iface;
@@ -3241,8 +3259,7 @@ struct d3d12_device
 
     struct vkd3d_memory_allocator memory_allocator;
 
-    struct vkd3d_scratch_buffer scratch_buffers[VKD3D_SCRATCH_BUFFER_COUNT];
-    size_t scratch_buffer_count;
+    struct d3d12_device_scratch_pool scratch_pools[VKD3D_SCRATCH_POOL_KIND_COUNT];
 
     struct vkd3d_query_pool query_pools[VKD3D_VIRTUAL_QUERY_POOL_COUNT];
     size_t query_pool_count;
@@ -3316,8 +3333,10 @@ static inline struct d3d12_device *impl_from_ID3D12Device(d3d12_device_iface *if
 
 bool d3d12_device_validate_shader_meta(struct d3d12_device *device, const struct vkd3d_shader_meta *meta);
 
-HRESULT d3d12_device_get_scratch_buffer(struct d3d12_device *device, VkDeviceSize min_size, struct vkd3d_scratch_buffer *scratch);
-void d3d12_device_return_scratch_buffer(struct d3d12_device *device, const struct vkd3d_scratch_buffer *scratch);
+HRESULT d3d12_device_get_scratch_buffer(struct d3d12_device *device, enum vkd3d_scratch_pool_kind kind,
+        VkDeviceSize min_size, uint32_t memory_types, struct vkd3d_scratch_buffer *scratch);
+void d3d12_device_return_scratch_buffer(struct d3d12_device *device, enum vkd3d_scratch_pool_kind kind,
+        const struct vkd3d_scratch_buffer *scratch);
 
 HRESULT d3d12_device_get_query_pool(struct d3d12_device *device, uint32_t type_index, struct vkd3d_query_pool *pool);
 void d3d12_device_return_query_pool(struct d3d12_device *device, const struct vkd3d_query_pool *pool);
-- 
2.36.1

From 458391e794fe78bca65f4d9c051152f3770aeb8d Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Thu, 10 Feb 2022 12:56:27 +0100
Subject: [PATCH 16/42] vkd3d: Trace breadcrumbs for execute indirect
 templates.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/breadcrumbs.c   | 2 ++
 libs/vkd3d/command.c       | 1 +
 libs/vkd3d/vkd3d_private.h | 1 +
 3 files changed, 4 insertions(+)

diff --git a/libs/vkd3d/breadcrumbs.c b/libs/vkd3d/breadcrumbs.c
index 6fa08137..5825247c 100644
--- a/libs/vkd3d/breadcrumbs.c
+++ b/libs/vkd3d/breadcrumbs.c
@@ -50,6 +50,8 @@ static const char *vkd3d_breadcrumb_command_type_to_str(enum vkd3d_breadcrumb_co
             return "dispatch";
         case VKD3D_BREADCRUMB_COMMAND_EXECUTE_INDIRECT:
             return "execute_indirect";
+        case VKD3D_BREADCRUMB_COMMAND_EXECUTE_INDIRECT_TEMPLATE:
+            return "execute_indirect_template";
         case VKD3D_BREADCRUMB_COMMAND_COPY:
             return "copy";
         case VKD3D_BREADCRUMB_COMMAND_RESOLVE:
diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index a075b48c..f763d071 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -9711,6 +9711,7 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(d3d12_command_l
                 max_command_count,
                 arg_impl, arg_buffer_offset,
                 count_impl, count_buffer_offset);
+        VKD3D_BREADCRUMB_COMMAND(EXECUTE_INDIRECT_TEMPLATE);
         return;
     }
 
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 17a64548..9db4204c 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -2496,6 +2496,7 @@ enum vkd3d_breadcrumb_command_type
     VKD3D_BREADCRUMB_COMMAND_DRAW_INDEXED,
     VKD3D_BREADCRUMB_COMMAND_DISPATCH,
     VKD3D_BREADCRUMB_COMMAND_EXECUTE_INDIRECT,
+    VKD3D_BREADCRUMB_COMMAND_EXECUTE_INDIRECT_TEMPLATE,
     VKD3D_BREADCRUMB_COMMAND_COPY,
     VKD3D_BREADCRUMB_COMMAND_RESOLVE,
     VKD3D_BREADCRUMB_COMMAND_WBI,
-- 
2.36.1

From caa9b0ae24b0007f1a7315f16c50adfde2f149b6 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Mon, 14 Feb 2022 12:19:49 +0100
Subject: [PATCH 17/42] vkd3d: Add workaround for forced clearing of certain
 buffers.

If game uses NOT_ZEROED, it might still rely on buffers being properly
cleared to 0.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 include/vkd3d.h       | 1 +
 libs/vkd3d/command.c  | 4 +++-
 libs/vkd3d/device.c   | 5 +++++
 libs/vkd3d/resource.c | 8 ++++++++
 4 files changed, 17 insertions(+), 1 deletion(-)

diff --git a/include/vkd3d.h b/include/vkd3d.h
index d63a3304..4eebff43 100644
--- a/include/vkd3d.h
+++ b/include/vkd3d.h
@@ -88,6 +88,7 @@ extern "C" {
 #define VKD3D_CONFIG_FLAG_PIPELINE_LIBRARY_APP_CACHE_ONLY (1ull << 26)
 #define VKD3D_CONFIG_FLAG_SHADER_CACHE_SYNC (1ull << 27)
 #define VKD3D_CONFIG_FLAG_FORCE_RAW_VA_CBV (1ull << 28)
+#define VKD3D_CONFIG_FLAG_ZERO_MEMORY_WORKAROUNDS_COMMITTED_BUFFER_UAV (1ull << 29)
 
 typedef HRESULT (*PFN_vkd3d_signal_event)(HANDLE event);
 
diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index f763d071..c6284046 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -8395,7 +8395,9 @@ static void d3d12_command_list_clear_uav_with_copy(struct d3d12_command_list *li
     scratch_buffer_size = element_count * format->byte_count;
 
     if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
-            scratch_buffer_size, 16, &scratch))
+            VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
+            scratch_buffer_size, 16, ~0u,
+            &scratch))
     {
         ERR("Failed to allocate scratch memory for UAV clear.\n");
         return;
diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index 1d631ce0..71b3f4a7 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -495,6 +495,11 @@ static const struct vkd3d_instance_application_meta application_override[] = {
     /* MSVC fails to compile empty array. */
     { VKD3D_STRING_COMPARE_EXACT, "GravityMark.exe", VKD3D_CONFIG_FLAG_FORCE_MINIMUM_SUBGROUP_SIZE, 0 },
     { VKD3D_STRING_COMPARE_EXACT, "Deathloop.exe", VKD3D_CONFIG_FLAG_IGNORE_RTV_HOST_VISIBLE, 0 },
+    /* Halo Infinite (1240440).
+     * Game relies on NON_ZEROED committed UAVs to be cleared to zero on allocation.
+     * This works okay with zerovram on first game boot, but not later, since this memory is guaranteed to be recycled. */
+    { VKD3D_STRING_COMPARE_EXACT, "HaloInfinite.exe",
+            VKD3D_CONFIG_FLAG_ZERO_MEMORY_WORKAROUNDS_COMMITTED_BUFFER_UAV, 0 },
     /* Shadow of the Tomb Raider (750920).
      * Invariant workarounds actually cause more issues than they resolve on NV.
      * RADV already has workarounds by default.
diff --git a/libs/vkd3d/resource.c b/libs/vkd3d/resource.c
index 95520114..36b479e4 100644
--- a/libs/vkd3d/resource.c
+++ b/libs/vkd3d/resource.c
@@ -2803,6 +2803,14 @@ HRESULT d3d12_resource_create_committed(struct d3d12_device *device, const D3D12
         allocate_info.heap_desc.SizeInBytes = align(desc->Width, allocate_info.heap_desc.Alignment);
         allocate_info.heap_desc.Flags = heap_flags | D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS;
 
+        /* Be very careful with suballocated buffers. */
+        if ((vkd3d_config_flags & VKD3D_CONFIG_FLAG_ZERO_MEMORY_WORKAROUNDS_COMMITTED_BUFFER_UAV) &&
+                (desc->Flags & D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS) &&
+                desc->Width < VKD3D_VA_BLOCK_SIZE)
+        {
+            allocate_info.heap_desc.Flags &= ~D3D12_HEAP_FLAG_CREATE_NOT_ZEROED;
+        }
+
         if (FAILED(hr = vkd3d_allocate_heap_memory(device,
                 &device->memory_allocator, &allocate_info, &object->mem)))
             goto fail;
-- 
2.36.1

From 1b6f7d4c682c811392ea030a8214b255dcea3874 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Tue, 15 Feb 2022 15:58:16 +0100
Subject: [PATCH 18/42] vkd3d: Enable FORCE_RAW_VA_CBV for Halo Infinite as
 well.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/device.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index 71b3f4a7..94ca0c17 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -497,9 +497,10 @@ static const struct vkd3d_instance_application_meta application_override[] = {
     { VKD3D_STRING_COMPARE_EXACT, "Deathloop.exe", VKD3D_CONFIG_FLAG_IGNORE_RTV_HOST_VISIBLE, 0 },
     /* Halo Infinite (1240440).
      * Game relies on NON_ZEROED committed UAVs to be cleared to zero on allocation.
-     * This works okay with zerovram on first game boot, but not later, since this memory is guaranteed to be recycled. */
+     * This works okay with zerovram on first game boot, but not later, since this memory is guaranteed to be recycled.
+     * Game also relies on indirectly modifying CBV root descriptors, which means we are forced to rel yon RAW_VA_CBV. */
     { VKD3D_STRING_COMPARE_EXACT, "HaloInfinite.exe",
-            VKD3D_CONFIG_FLAG_ZERO_MEMORY_WORKAROUNDS_COMMITTED_BUFFER_UAV, 0 },
+            VKD3D_CONFIG_FLAG_ZERO_MEMORY_WORKAROUNDS_COMMITTED_BUFFER_UAV | VKD3D_CONFIG_FLAG_FORCE_RAW_VA_CBV, 0 },
     /* Shadow of the Tomb Raider (750920).
      * Invariant workarounds actually cause more issues than they resolve on NV.
      * RADV already has workarounds by default.
-- 
2.36.1

From ebbf4b5338e2539e7fde680c065459e08e3d0350 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 18 Feb 2022 13:22:11 +0100
Subject: [PATCH 19/42] vkd3d: Add debug ring path for execute indirect
 template patches.

Somehow inspect draw parameters this way.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/meson.build                        |  1 +
 libs/vkd3d/meta.c                             | 56 ++++++++++--
 .../cs_execute_indirect_patch_debug_ring.comp | 90 +++++++++++++++++++
 libs/vkd3d/vkd3d_private.h                    |  6 +-
 libs/vkd3d/vkd3d_shaders.h                    |  1 +
 meson.build                                   |  2 +-
 6 files changed, 145 insertions(+), 11 deletions(-)
 create mode 100644 libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp

diff --git a/libs/vkd3d/meson.build b/libs/vkd3d/meson.build
index 7a7e6749..7644ed61 100644
--- a/libs/vkd3d/meson.build
+++ b/libs/vkd3d/meson.build
@@ -28,6 +28,7 @@ vkd3d_shaders =[
   'shaders/vs_swapchain_fullscreen.vert',
   'shaders/fs_swapchain_fullscreen.frag',
   'shaders/cs_execute_indirect_patch.comp',
+  'shaders/cs_execute_indirect_patch_debug_ring.comp',
 ]
 
 vkd3d_src = [
diff --git a/libs/vkd3d/meta.c b/libs/vkd3d/meta.c
index b49f3d71..27fc2c87 100644
--- a/libs/vkd3d/meta.c
+++ b/libs/vkd3d/meta.c
@@ -1244,14 +1244,24 @@ HRESULT vkd3d_execute_indirect_ops_init(struct vkd3d_execute_indirect_ops *meta_
     return S_OK;
 }
 
+struct vkd3d_meta_execute_indirect_spec_constant_data
+{
+    struct vkd3d_shader_debug_ring_spec_constants constants;
+    uint32_t workgroup_size_x;
+};
+
 HRESULT vkd3d_meta_get_execute_indirect_pipeline(struct vkd3d_meta_ops *meta_ops,
         uint32_t patch_command_count, struct vkd3d_execute_indirect_info *info)
 {
+    struct vkd3d_meta_execute_indirect_spec_constant_data execute_indirect_spec_constants;
+    VkSpecializationMapEntry map_entry[VKD3D_SHADER_DEBUG_RING_SPEC_INFO_MAP_ENTRIES + 1];
     struct vkd3d_execute_indirect_ops *meta_indirect_ops = &meta_ops->execute_indirect;
-    VkSpecializationMapEntry map_entry;
+    struct vkd3d_shader_debug_ring_spec_info debug_ring_info;
+
     VkSpecializationInfo spec;
     HRESULT hr = S_OK;
     VkResult vr;
+    bool debug;
     size_t i;
     int rc;
 
@@ -1271,14 +1281,41 @@ HRESULT vkd3d_meta_get_execute_indirect_pipeline(struct vkd3d_meta_ops *meta_ops
         }
     }
 
-    map_entry.constantID = 0;
-    map_entry.offset = 0;
-    map_entry.size = sizeof(patch_command_count);
+    debug = meta_ops->device->debug_ring.active;
 
-    spec.pMapEntries = &map_entry;
-    spec.pData = &patch_command_count;
-    spec.mapEntryCount = 1;
-    spec.dataSize = sizeof(patch_command_count);
+    /* If we have debug ring, we can dump indirect command buffer data to the ring as well.
+     * Vital for debugging broken execute indirect data with templates. */
+    if (debug)
+    {
+        vkd3d_shader_debug_ring_init_spec_constant(meta_ops->device, &debug_ring_info,
+                0 /* Reserve this hash for internal debug streams. */);
+
+        memset(&execute_indirect_spec_constants, 0, sizeof(execute_indirect_spec_constants));
+        execute_indirect_spec_constants.constants = debug_ring_info.constants;
+        execute_indirect_spec_constants.workgroup_size_x = patch_command_count;
+
+        memcpy(map_entry, debug_ring_info.map_entries, sizeof(debug_ring_info.map_entries));
+        map_entry[VKD3D_SHADER_DEBUG_RING_SPEC_INFO_MAP_ENTRIES].constantID = 4;
+        map_entry[VKD3D_SHADER_DEBUG_RING_SPEC_INFO_MAP_ENTRIES].offset =
+                offsetof(struct vkd3d_meta_execute_indirect_spec_constant_data, workgroup_size_x);
+        map_entry[VKD3D_SHADER_DEBUG_RING_SPEC_INFO_MAP_ENTRIES].size = sizeof(patch_command_count);
+
+        spec.pMapEntries = map_entry;
+        spec.pData = &execute_indirect_spec_constants;
+        spec.mapEntryCount = ARRAY_SIZE(map_entry);
+        spec.dataSize = sizeof(execute_indirect_spec_constants);
+    }
+    else
+    {
+        map_entry[0].constantID = 0;
+        map_entry[0].offset = 0;
+        map_entry[0].size = sizeof(patch_command_count);
+
+        spec.pMapEntries = map_entry;
+        spec.pData = &patch_command_count;
+        spec.mapEntryCount = 1;
+        spec.dataSize = sizeof(patch_command_count);
+    }
 
     vkd3d_array_reserve((void**)&meta_indirect_ops->pipelines, &meta_indirect_ops->pipelines_size,
             meta_indirect_ops->pipelines_count + 1, sizeof(*meta_indirect_ops->pipelines));
@@ -1286,7 +1323,8 @@ HRESULT vkd3d_meta_get_execute_indirect_pipeline(struct vkd3d_meta_ops *meta_ops
     meta_indirect_ops->pipelines[meta_indirect_ops->pipelines_count].workgroup_size_x = patch_command_count;
 
     vr = vkd3d_meta_create_compute_pipeline(meta_ops->device,
-            sizeof(cs_execute_indirect_patch), cs_execute_indirect_patch,
+            debug ? sizeof(cs_execute_indirect_patch_debug_ring) : sizeof(cs_execute_indirect_patch),
+            debug ? cs_execute_indirect_patch_debug_ring : cs_execute_indirect_patch,
             meta_indirect_ops->vk_pipeline_layout, &spec,
             &meta_indirect_ops->pipelines[meta_indirect_ops->pipelines_count].vk_pipeline);
 
diff --git a/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp b/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp
new file mode 100644
index 00000000..8445ac73
--- /dev/null
+++ b/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp
@@ -0,0 +1,90 @@
+#version 450
+#extension GL_EXT_buffer_reference : require
+#extension GL_EXT_buffer_reference_uvec2 : require
+#extension GL_GOOGLE_include_directive : require
+#include "../../../include/shader-debug/debug_channel.h"
+
+layout(local_size_x_id = 4) in;
+
+struct Command
+{
+	uint type;
+	uint src_offset;
+	uint dst_offset;
+};
+
+const int COMMAND_TYPE_COPY_U32 = 0;
+const int COMMAND_TYPE_COPY_INDEX_TYPE = 1;
+const int DXGI_FORMAT_R32_UINT = 0x2a;
+const int VK_INDEX_TYPE_UINT16 = 0;
+const int VK_INDEX_TYPE_UINT32 = 1;
+
+layout(buffer_reference, std430, buffer_reference_align = 4) readonly buffer Commands
+{
+	Command commands[];
+};
+
+layout(buffer_reference, std430, buffer_reference_align = 4) readonly buffer SrcBuffer {
+	uint values[];
+};
+
+layout(buffer_reference, std430, buffer_reference_align = 4) writeonly buffer DstBuffer {
+	uint values[];
+};
+
+layout(buffer_reference, std430, buffer_reference_align = 4) readonly buffer IndirectCount {
+	uint count;
+};
+
+layout(buffer_reference, std430, buffer_reference_align = 4) writeonly buffer IndirectCountWrite {
+	uint count;
+};
+
+layout(push_constant) uniform Registers
+{
+	Commands commands_va;
+	SrcBuffer src_buffer_va;
+	DstBuffer dst_buffer_va;
+	uvec2 indirect_count_va;
+	IndirectCountWrite dst_indirect_count_va;
+	uint src_stride;
+	uint dst_stride;
+
+	// Debug metadata here
+	uint debug_tag;
+};
+
+void main()
+{
+    if (debug_tag != 0u)
+        DEBUG_CHANNEL_INIT(uvec3(debug_tag, gl_WorkGroupID.x, gl_LocalInvocationIndex));
+
+    Command cmd = commands_va.commands[gl_LocalInvocationIndex];
+
+    uint draw_id = gl_WorkGroupID.x;
+    uint max_draws = gl_NumWorkGroups.x;
+    if (any(notEqual(indirect_count_va, uvec2(0))))
+    {
+        max_draws = min(max_draws, IndirectCount(indirect_count_va).count);
+        if (gl_WorkGroupID.x == 0u)
+            dst_indirect_count_va.count = max_draws;
+    }
+
+    if (debug_tag != 0u && gl_WorkGroupID.x == 0)
+        DEBUG_CHANNEL_MSG_UNIFORM(int(max_draws), int(gl_NumWorkGroups.x));
+
+    if (draw_id < max_draws)
+    {
+        uint src_offset = src_stride * draw_id + cmd.src_offset;
+        uint dst_offset = dst_stride * draw_id + cmd.dst_offset;
+
+        uint src_value = src_buffer_va.values[src_offset];
+        if (cmd.type == COMMAND_TYPE_COPY_INDEX_TYPE)
+            src_value = src_value == DXGI_FORMAT_R32_UINT ? VK_INDEX_TYPE_UINT32 : VK_INDEX_TYPE_UINT16;
+
+        if (debug_tag != 0u)
+            DEBUG_CHANNEL_MSG(cmd.type, dst_offset, src_offset, src_value);
+
+        dst_buffer_va.values[dst_offset] = src_value;
+    }
+}
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 9db4204c..0bbe13f6 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -1451,10 +1451,11 @@ struct vkd3d_shader_debug_ring_spec_constants
     uint32_t ring_words;
 };
 
+#define VKD3D_SHADER_DEBUG_RING_SPEC_INFO_MAP_ENTRIES 4
 struct vkd3d_shader_debug_ring_spec_info
 {
     struct vkd3d_shader_debug_ring_spec_constants constants;
-    VkSpecializationMapEntry map_entries[4];
+    VkSpecializationMapEntry map_entries[VKD3D_SHADER_DEBUG_RING_SPEC_INFO_MAP_ENTRIES];
     VkSpecializationInfo spec_info;
 };
 
@@ -3002,6 +3003,9 @@ struct vkd3d_execute_indirect_args
     VkDeviceAddress dst_indirect_count_va;
     uint32_t api_buffer_word_stride;
     uint32_t device_generated_commands_word_stride;
+
+    /* Arbitrary tag used for debug version of state patcher. Debug messages from tag 0 are ignored. */
+    uint32_t debug_tag;
 };
 
 struct vkd3d_execute_indirect_pipeline
diff --git a/libs/vkd3d/vkd3d_shaders.h b/libs/vkd3d/vkd3d_shaders.h
index 9e5698d6..41637e82 100644
--- a/libs/vkd3d/vkd3d_shaders.h
+++ b/libs/vkd3d/vkd3d_shaders.h
@@ -46,6 +46,7 @@ enum vkd3d_meta_copy_mode
 #include <cs_resolve_predicate.h>
 #include <cs_resolve_query.h>
 #include <cs_execute_indirect_patch.h>
+#include <cs_execute_indirect_patch_debug_ring.h>
 #include <vs_fullscreen_layer.h>
 #include <vs_fullscreen.h>
 #include <gs_fullscreen.h>
diff --git a/meson.build b/meson.build
index dfc297e5..e9815b50 100644
--- a/meson.build
+++ b/meson.build
@@ -83,7 +83,7 @@ idl_generator = generator(idl_compiler,
   arguments : [ '-h', '-o', '@OUTPUT@', '@INPUT@' ])
 
 glsl_compiler  = find_program('glslangValidator')
-glsl_args = [ '-V', '--vn', '@BASENAME@', '@INPUT@', '-o', '@OUTPUT@' ]
+glsl_args = [ '-V', '--target-env', 'vulkan1.1', '--vn', '@BASENAME@', '@INPUT@', '-o', '@OUTPUT@' ]
 if run_command(glsl_compiler, [ '--quiet', '--version' ], check : false).returncode() == 0
     glsl_args += [ '--quiet' ]
 endif
-- 
2.36.1

From c2d516e688e9121645cf7f1524c75c78dcb61eb2 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 18 Feb 2022 13:23:02 +0100
Subject: [PATCH 20/42] vkd3d: Clamp command count in execute indirect path.

Shouldn't be required, but take no chances.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/shaders/cs_execute_indirect_patch.comp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/libs/vkd3d/shaders/cs_execute_indirect_patch.comp b/libs/vkd3d/shaders/cs_execute_indirect_patch.comp
index 43e96204..45476e55 100644
--- a/libs/vkd3d/shaders/cs_execute_indirect_patch.comp
+++ b/libs/vkd3d/shaders/cs_execute_indirect_patch.comp
@@ -54,10 +54,11 @@ void main()
 	Command cmd = commands_va.commands[gl_LocalInvocationIndex];
 
 	uint draw_id = gl_WorkGroupID.x;
-	uint max_draws = ~0u;
+	uint max_draws = gl_NumWorkGroups.x;
+
 	if (any(notEqual(indirect_count_va, uvec2(0))))
 	{
-		max_draws = IndirectCount(indirect_count_va).count;
+		max_draws = min(max_draws, IndirectCount(indirect_count_va).count);
 		if (gl_WorkGroupID.x == 0u)
 			dst_indirect_count_va.count = max_draws;
 	}
-- 
2.36.1

From 4aeca164689fb4a3dcbaf743ef873cfdf12cc285 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 18 Feb 2022 13:41:19 +0100
Subject: [PATCH 21/42] vkd3d: Refactor out patch command token enum.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c       | 7 -------
 libs/vkd3d/vkd3d_private.h | 7 +++++++
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index c6284046..af421014 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -12560,13 +12560,6 @@ CONST_VTBL struct ID3D12CommandSignatureVtbl d3d12_command_signature_vtbl =
     d3d12_command_signature_GetDevice,
 };
 
-enum vkd3d_patch_command_token
-{
-    VKD3D_PATCH_COMMAND_TOKEN_COPY_U32 = 0,
-    VKD3D_PATCH_COMMAND_TOKEN_COPY_INDEX_FORMAT = 1,
-    VKD3D_PATCH_COMMAND_INT_MAX = 0x7fffffff
-};
-
 struct vkd3d_patch_command
 {
     enum vkd3d_patch_command_token token;
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 0bbe13f6..72f53f5f 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -2393,6 +2393,13 @@ struct vkd3d_execute_indirect_info
     VkPipeline vk_pipeline;
 };
 
+enum vkd3d_patch_command_token
+{
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_U32 = 0,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_INDEX_FORMAT = 1,
+    VKD3D_PATCH_COMMAND_INT_MAX = 0x7fffffff
+};
+
 /* ID3D12CommandSignature */
 struct d3d12_command_signature
 {
-- 
2.36.1

From 8140b26c939c4c9f54fe0eff8be4738f68b0ed42 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 18 Feb 2022 14:25:37 +0100
Subject: [PATCH 22/42] vkd3d: Encode in detail which commands we're emitting
 in template.

Feed this back to debug ring for less cryptic logs.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c                          | 58 ++++++++++++++++---
 .../shaders/cs_execute_indirect_patch.comp    |  3 +-
 .../cs_execute_indirect_patch_debug_ring.comp |  3 +-
 libs/vkd3d/vkd3d_private.h                    | 20 ++++++-
 4 files changed, 70 insertions(+), 14 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index af421014..8bba4e63 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -12704,6 +12704,7 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
         struct d3d12_root_signature *root_signature,
         struct d3d12_device *device)
 {
+    const enum vkd3d_patch_command_token *generic_u32_copy_types;
     const struct vkd3d_shader_root_parameter *root_parameter;
     const struct vkd3d_shader_root_constant *root_constant;
     struct vkd3d_patch_command *patch_commands = NULL;
@@ -12721,6 +12722,46 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
     HRESULT hr = S_OK;
     uint32_t i, j;
 
+    /* Mostly for debug. Lets debug ring report what it is writing easily. */
+    static const enum vkd3d_patch_command_token ibv_types[] =
+    {
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_IBO_VA_LO,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_IBO_VA_HI,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_IBO_SIZE,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_INDEX_FORMAT,
+    };
+
+    static const enum vkd3d_patch_command_token vbv_types[] =
+    {
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_VA_LO,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_VA_HI,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_SIZE,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_STRIDE,
+    };
+
+    static const enum vkd3d_patch_command_token draw_types[] =
+    {
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_VERTEX_COUNT,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_INSTANCE_COUNT,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_FIRST_VERTEX,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_FIRST_INSTANCE,
+    };
+
+    static const enum vkd3d_patch_command_token draw_indexed_types[] =
+    {
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_INDEX_COUNT,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_INSTANCE_COUNT,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_FIRST_INDEX,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_VERTEX_OFFSET,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_FIRST_INSTANCE,
+    };
+
+    static const enum vkd3d_patch_command_token va_types[] =
+    {
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_ROOT_VA_LO,
+        VKD3D_PATCH_COMMAND_TOKEN_COPY_ROOT_VA_HI,
+    };
+
     if (!device->device_info.device_generated_commands_features_nv.deviceGeneratedCommands)
     {
         WARN("Device generated commands not supported, indirect state commands will be ignored.\n");
@@ -12754,6 +12795,7 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
                 dst_word_offset = token.offset / sizeof(uint32_t);
 
                 generic_u32_copy_count = argument_desc->Constant.Num32BitValuesToSet;
+                generic_u32_copy_types = NULL;
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW:
@@ -12782,6 +12824,7 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
 
                 /* Simply patch by copying U32s. Need to handle unaligned U32s since everything is tightly packed. */
                 generic_u32_copy_count = sizeof(VkDeviceAddress) / sizeof(uint32_t);
+                generic_u32_copy_types = va_types;
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW:
@@ -12796,6 +12839,7 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
 
                 /* The VBV indirect layout is the same as DX, so just copy the U32s. */
                 generic_u32_copy_count = sizeof(D3D12_VERTEX_BUFFER_VIEW) / sizeof(uint32_t);
+                generic_u32_copy_types = vbv_types;
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW:
@@ -12811,18 +12855,13 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
                         patch_commands_count + sizeof(D3D12_INDEX_BUFFER_VIEW) / sizeof(uint32_t),
                         sizeof(*patch_commands));
 
-                for (j = 0; j < 3; j++)
+                for (j = 0; j < 4; j++)
                 {
-                    patch_commands[patch_commands_count].token = VKD3D_PATCH_COMMAND_TOKEN_COPY_U32;
+                    patch_commands[patch_commands_count].token = ibv_types[j];
                     patch_commands[patch_commands_count].src_offset = src_word_offset++;
                     patch_commands[patch_commands_count].dst_offset = dst_word_offset++;
                     patch_commands_count++;
                 }
-
-                patch_commands[patch_commands_count].token = VKD3D_PATCH_COMMAND_TOKEN_COPY_INDEX_FORMAT;
-                patch_commands[patch_commands_count].src_offset = src_word_offset++;
-                patch_commands[patch_commands_count].dst_offset = dst_word_offset++;
-                patch_commands_count++;
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_DRAW:
@@ -12832,6 +12871,7 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
                 stream_stride += sizeof(VkDrawIndirectCommand);
                 dst_word_offset = token.offset / sizeof(uint32_t);
                 generic_u32_copy_count = sizeof(VkDrawIndirectCommand) / sizeof(uint32_t);
+                generic_u32_copy_types = draw_types;
                 break;
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED:
@@ -12841,6 +12881,7 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
                 stream_stride += sizeof(VkDrawIndexedIndirectCommand);
                 dst_word_offset = token.offset / sizeof(uint32_t);
                 generic_u32_copy_count = sizeof(VkDrawIndexedIndirectCommand) / sizeof(uint32_t);
+                generic_u32_copy_types = draw_indexed_types;
                 break;
 
             default:
@@ -12861,7 +12902,8 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
             /* Simply patch by copying U32s. */
             for (j = 0; j < generic_u32_copy_count; j++, patch_commands_count++)
             {
-                patch_commands[patch_commands_count].token = VKD3D_PATCH_COMMAND_TOKEN_COPY_U32;
+                patch_commands[patch_commands_count].token =
+                        generic_u32_copy_types ? generic_u32_copy_types[j] : VKD3D_PATCH_COMMAND_TOKEN_COPY_CONST_U32;
                 patch_commands[patch_commands_count].src_offset = src_word_offset++;
                 patch_commands[patch_commands_count].dst_offset = dst_word_offset++;
             }
diff --git a/libs/vkd3d/shaders/cs_execute_indirect_patch.comp b/libs/vkd3d/shaders/cs_execute_indirect_patch.comp
index 45476e55..c2522910 100644
--- a/libs/vkd3d/shaders/cs_execute_indirect_patch.comp
+++ b/libs/vkd3d/shaders/cs_execute_indirect_patch.comp
@@ -11,8 +11,7 @@ struct Command
 	uint dst_offset;
 };
 
-const int COMMAND_TYPE_COPY_U32 = 0;
-const int COMMAND_TYPE_COPY_INDEX_TYPE = 1;
+const int COMMAND_TYPE_COPY_INDEX_TYPE = 4;
 const int DXGI_FORMAT_R32_UINT = 0x2a;
 const int VK_INDEX_TYPE_UINT16 = 0;
 const int VK_INDEX_TYPE_UINT32 = 1;
diff --git a/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp b/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp
index 8445ac73..64615006 100644
--- a/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp
+++ b/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp
@@ -13,8 +13,7 @@ struct Command
 	uint dst_offset;
 };
 
-const int COMMAND_TYPE_COPY_U32 = 0;
-const int COMMAND_TYPE_COPY_INDEX_TYPE = 1;
+const int COMMAND_TYPE_COPY_INDEX_TYPE = 4;
 const int DXGI_FORMAT_R32_UINT = 0x2a;
 const int VK_INDEX_TYPE_UINT16 = 0;
 const int VK_INDEX_TYPE_UINT32 = 1;
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 72f53f5f..54865ea4 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -2395,8 +2395,24 @@ struct vkd3d_execute_indirect_info
 
 enum vkd3d_patch_command_token
 {
-    VKD3D_PATCH_COMMAND_TOKEN_COPY_U32 = 0,
-    VKD3D_PATCH_COMMAND_TOKEN_COPY_INDEX_FORMAT = 1,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_CONST_U32 = 0,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_IBO_VA_LO = 1,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_IBO_VA_HI = 2,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_IBO_SIZE = 3,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_INDEX_FORMAT = 4,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_VA_LO = 5,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_VA_HI = 6,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_SIZE = 7,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_STRIDE = 8,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_ROOT_VA_LO = 9,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_ROOT_VA_HI = 10,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_VERTEX_COUNT = 11,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_INDEX_COUNT = 12,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_INSTANCE_COUNT = 13,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_FIRST_INDEX = 14,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_FIRST_VERTEX = 15,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_FIRST_INSTANCE = 16,
+    VKD3D_PATCH_COMMAND_TOKEN_COPY_VERTEX_OFFSET = 17,
     VKD3D_PATCH_COMMAND_INT_MAX = 0x7fffffff
 };
 
-- 
2.36.1

From 5b33483ce9bb9dbc5cf34a8e77227d1432b0772e Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 18 Feb 2022 14:26:11 +0100
Subject: [PATCH 23/42] debug: Pretty-print execute template debug messages.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/debug_ring.c | 162 ++++++++++++++++++++++++++++++++--------
 1 file changed, 130 insertions(+), 32 deletions(-)

diff --git a/libs/vkd3d/debug_ring.c b/libs/vkd3d/debug_ring.c
index 780dcb72..c4aaa0b7 100644
--- a/libs/vkd3d/debug_ring.c
+++ b/libs/vkd3d/debug_ring.c
@@ -61,12 +61,56 @@ void vkd3d_shader_debug_ring_init_spec_constant(struct d3d12_device *device,
 #define DEBUG_CHANNEL_WORD_COOKIE 0xdeadca70u
 #define DEBUG_CHANNEL_WORD_MASK 0xfffffff0u
 
+static const char *vkd3d_patch_command_token_str(enum vkd3d_patch_command_token token)
+{
+    switch (token)
+    {
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_CONST_U32: return "RootConst";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_IBO_VA_LO: return "IBO VA LO";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_IBO_VA_HI: return "IBO VA HI";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_IBO_SIZE: return "IBO Size";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_INDEX_FORMAT: return "IBO Type";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_VA_LO: return "VBO VA LO";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_VA_HI: return "VBO VA HI";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_SIZE: return "VBO Size";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_STRIDE: return "VBO Stride";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_ROOT_VA_LO: return "ROOT VA LO";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_ROOT_VA_HI: return "ROOT VA HI";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_VERTEX_COUNT: return "Vertex Count";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_INDEX_COUNT: return "Index Count";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_INSTANCE_COUNT: return "Instance Count";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_FIRST_INDEX: return "First Index";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_FIRST_VERTEX: return "First Vertex";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_FIRST_INSTANCE: return "First Instance";
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_VERTEX_OFFSET: return "Vertex Offset";
+        default: return "???";
+    }
+}
+
+static bool vkd3d_patch_command_token_is_hex(enum vkd3d_patch_command_token token)
+{
+    switch (token)
+    {
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_IBO_VA_LO:
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_IBO_VA_HI:
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_VA_LO:
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_VBO_VA_HI:
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_ROOT_VA_LO:
+        case VKD3D_PATCH_COMMAND_TOKEN_COPY_ROOT_VA_HI:
+            return true;
+
+        default:
+            return false;
+    }
+}
+
 static bool vkd3d_shader_debug_ring_print_message(struct vkd3d_shader_debug_ring *ring,
         uint32_t word_offset, uint32_t message_word_count)
 {
     uint32_t i, debug_instance, debug_thread_id[3], fmt;
     char message_buffer[4096];
     uint64_t shader_hash;
+    size_t len, avail;
 
     if (message_word_count < 8)
     {
@@ -80,52 +124,106 @@ static bool vkd3d_shader_debug_ring_print_message(struct vkd3d_shader_debug_ring
         debug_thread_id[i] = READ_RING_WORD(word_offset + 4 + i);
     fmt = READ_RING_WORD(word_offset + 7);
 
-    snprintf(message_buffer, sizeof(message_buffer), "Shader: %"PRIx64": Instance %u, ID (%u, %u, %u):",
-            shader_hash, debug_instance,
-            debug_thread_id[0], debug_thread_id[1], debug_thread_id[2]);
-
     word_offset += 8;
     message_word_count -= 8;
 
-    for (i = 0; i < message_word_count; i++)
+    if (shader_hash == 0)
     {
-        union
+        /* We got this from our internal debug shaders. Pretty-print.
+         * TODO: Might consider a callback system that listeners from different subsystems can listen to and print their own messages,
+         * but that is overengineering at this time ... */
+        snprintf(message_buffer, sizeof(message_buffer), "ExecuteIndirect: Instance %u, Debug tag %u, DrawID %u (ThreadID %u): ",
+                debug_instance, debug_thread_id[0], debug_thread_id[1], debug_thread_id[2]);
+
+        if (message_word_count == 2)
+        {
+            len = strlen(message_buffer);
+            avail = sizeof(message_buffer) - len;
+            snprintf(message_buffer + len, avail, "DrawCount %u, MaxDrawCount %u",
+                    READ_RING_WORD(word_offset + 0),
+                    READ_RING_WORD(word_offset + 1));
+        }
+        else if (message_word_count == 4)
         {
-            float f32;
-            uint32_t u32;
-            int32_t i32;
-        } u;
-        const char *delim;
-        size_t len, avail;
-        u.u32 = READ_RING_WORD(word_offset + i);
+            union { uint32_t u32; float f32; int32_t s32; } value;
+            enum vkd3d_patch_command_token token;
+            uint32_t dst_offset;
+            uint32_t src_offset;
+
+            len = strlen(message_buffer);
+            avail = sizeof(message_buffer) - len;
+
+            token = READ_RING_WORD(word_offset + 0);
+            dst_offset = READ_RING_WORD(word_offset + 1);
+            src_offset = READ_RING_WORD(word_offset + 2);
+            value.u32 = READ_RING_WORD(word_offset + 3);
+
+            if (vkd3d_patch_command_token_is_hex(token))
+            {
+                snprintf(message_buffer + len, avail, "%s <- #%08x",
+                        vkd3d_patch_command_token_str(token), value.u32);
+            }
+            else if (token == VKD3D_PATCH_COMMAND_TOKEN_COPY_CONST_U32)
+            {
+                snprintf(message_buffer + len, avail, "%s <- {hex #%08x, s32 %d, f32 %f}",
+                        vkd3d_patch_command_token_str(token), value.u32, value.s32, value.f32);
+            }
+            else
+            {
+                snprintf(message_buffer + len, avail, "%s <- %d",
+                        vkd3d_patch_command_token_str(token), value.s32);
+            }
 
-        len = strlen(message_buffer);
-        if (len + 1 >= sizeof(message_buffer))
-            break;
-        avail = sizeof(message_buffer) - len;
+            len = strlen(message_buffer);
+            avail = sizeof(message_buffer) - len;
+            snprintf(message_buffer + len, avail, " (dst offset %u, src offset %u)", dst_offset, src_offset);
+        }
+    }
+    else
+    {
+        snprintf(message_buffer, sizeof(message_buffer), "Shader: %"PRIx64": Instance %u, ID (%u, %u, %u):",
+                shader_hash, debug_instance,
+                debug_thread_id[0], debug_thread_id[1], debug_thread_id[2]);
 
-        delim = i == 0 ? " " : ", ";
+        for (i = 0; i < message_word_count; i++)
+        {
+            union
+            {
+                float f32;
+                uint32_t u32;
+                int32_t i32;
+            } u;
+            const char *delim;
+            u.u32 = READ_RING_WORD(word_offset + i);
+
+            len = strlen(message_buffer);
+            if (len + 1 >= sizeof(message_buffer))
+                break;
+            avail = sizeof(message_buffer) - len;
+
+            delim = i == 0 ? " " : ", ";
 
 #define VKD3D_DEBUG_CHANNEL_FMT_HEX 0u
 #define VKD3D_DEBUG_CHANNEL_FMT_I32 1u
 #define VKD3D_DEBUG_CHANNEL_FMT_F32 2u
-        switch ((fmt >> (2u * i)) & 3u)
-        {
-            case VKD3D_DEBUG_CHANNEL_FMT_HEX:
-                snprintf(message_buffer + len, avail, "%s#%x", delim, u.u32);
-                break;
+            switch ((fmt >> (2u * i)) & 3u)
+            {
+                case VKD3D_DEBUG_CHANNEL_FMT_HEX:
+                    snprintf(message_buffer + len, avail, "%s#%x", delim, u.u32);
+                    break;
 
-            case VKD3D_DEBUG_CHANNEL_FMT_I32:
-                snprintf(message_buffer + len, avail, "%s%d", delim, u.i32);
-                break;
+                case VKD3D_DEBUG_CHANNEL_FMT_I32:
+                    snprintf(message_buffer + len, avail, "%s%d", delim, u.i32);
+                    break;
 
-            case VKD3D_DEBUG_CHANNEL_FMT_F32:
-                snprintf(message_buffer + len, avail, "%s%f", delim, u.f32);
-                break;
+                case VKD3D_DEBUG_CHANNEL_FMT_F32:
+                    snprintf(message_buffer + len, avail, "%s%f", delim, u.f32);
+                    break;
 
-            default:
-                snprintf(message_buffer + len, avail, "%s????", delim);
-                break;
+                default:
+                    snprintf(message_buffer + len, avail, "%s????", delim);
+                    break;
+            }
         }
     }
 
-- 
2.36.1

From 02298892178529d3a3fc6d48f6eebea7aa1abf39 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 18 Feb 2022 14:48:07 +0100
Subject: [PATCH 24/42] debug: Make Instance sorting easier.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/debug_ring.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libs/vkd3d/debug_ring.c b/libs/vkd3d/debug_ring.c
index c4aaa0b7..7d486f96 100644
--- a/libs/vkd3d/debug_ring.c
+++ b/libs/vkd3d/debug_ring.c
@@ -132,7 +132,7 @@ static bool vkd3d_shader_debug_ring_print_message(struct vkd3d_shader_debug_ring
         /* We got this from our internal debug shaders. Pretty-print.
          * TODO: Might consider a callback system that listeners from different subsystems can listen to and print their own messages,
          * but that is overengineering at this time ... */
-        snprintf(message_buffer, sizeof(message_buffer), "ExecuteIndirect: Instance %u, Debug tag %u, DrawID %u (ThreadID %u): ",
+        snprintf(message_buffer, sizeof(message_buffer), "ExecuteIndirect: Instance %010u, Debug tag %u, DrawID %u (ThreadID %u): ",
                 debug_instance, debug_thread_id[0], debug_thread_id[1], debug_thread_id[2]);
 
         if (message_word_count == 2)
@@ -181,7 +181,7 @@ static bool vkd3d_shader_debug_ring_print_message(struct vkd3d_shader_debug_ring
     }
     else
     {
-        snprintf(message_buffer, sizeof(message_buffer), "Shader: %"PRIx64": Instance %u, ID (%u, %u, %u):",
+        snprintf(message_buffer, sizeof(message_buffer), "Shader: %"PRIx64": Instance %010u, ID (%u, %u, %u):",
                 shader_hash, debug_instance,
                 debug_thread_id[0], debug_thread_id[1], debug_thread_id[2]);
 
-- 
2.36.1

From eb1e3ae656e7fc4756e49531a224960f81ce458b Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 18 Feb 2022 14:57:42 +0100
Subject: [PATCH 25/42] debug: Add concept of implicit instance index to debug
 ring.

For internal debug shaders, it is helpful to ensure in-order logs when
sorted for later inspection.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 include/shader-debug/debug_channel.h                     | 8 ++++++++
 libs/vkd3d/command.c                                     | 9 +++++++++
 libs/vkd3d/debug_ring.c                                  | 3 ++-
 .../shaders/cs_execute_indirect_patch_debug_ring.comp    | 3 ++-
 libs/vkd3d/vkd3d_private.h                               | 1 +
 5 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/include/shader-debug/debug_channel.h b/include/shader-debug/debug_channel.h
index 97e3b2ab..aa54fa76 100644
--- a/include/shader-debug/debug_channel.h
+++ b/include/shader-debug/debug_channel.h
@@ -97,6 +97,14 @@ void DEBUG_CHANNEL_INIT(uvec3 id)
 #endif
 }
 
+void DEBUG_CHANNEL_INIT_IMPLICIT_INSTANCE(uvec3 id, uint inst)
+{
+	if (!DEBUG_SHADER_RING_ACTIVE)
+		return;
+	DEBUG_CHANNEL_ID = id;
+	DEBUG_CHANNEL_INSTANCE_COUNTER = inst;
+}
+
 void DEBUG_CHANNEL_UNLOCK_MESSAGE(RingBuffer buf, uint offset, uint num_words)
 {
 	memoryBarrierBuffer();
diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 8bba4e63..7471af7a 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -9526,6 +9526,15 @@ static void d3d12_command_list_execute_indirect_state_template(
     patch_args.dst_indirect_count_va = count_buffer ? count_allocation.va : 0;
     patch_args.api_buffer_word_stride = signature->desc.ByteStride / sizeof(uint32_t);
     patch_args.device_generated_commands_word_stride = signature->state_template.stride / sizeof(uint32_t);
+    patch_args.debug_tag = 0; /* Modify to non-zero value as desired when debugging. */
+
+    if (patch_args.debug_tag != 0)
+    {
+        /* Makes log easier to understand since a sorted log will appear in-order. */
+        static uint32_t vkd3d_implicit_instance_count;
+        patch_args.implicit_instance = vkd3d_atomic_uint32_increment(
+                &vkd3d_implicit_instance_count, vkd3d_memory_order_relaxed) - 1;
+    }
 
     barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
     barrier.pNext = NULL;
diff --git a/libs/vkd3d/debug_ring.c b/libs/vkd3d/debug_ring.c
index 7d486f96..2d67ee88 100644
--- a/libs/vkd3d/debug_ring.c
+++ b/libs/vkd3d/debug_ring.c
@@ -130,9 +130,10 @@ static bool vkd3d_shader_debug_ring_print_message(struct vkd3d_shader_debug_ring
     if (shader_hash == 0)
     {
         /* We got this from our internal debug shaders. Pretty-print.
+         * Make sure the log is sortable for easier debug.
          * TODO: Might consider a callback system that listeners from different subsystems can listen to and print their own messages,
          * but that is overengineering at this time ... */
-        snprintf(message_buffer, sizeof(message_buffer), "ExecuteIndirect: Instance %010u, Debug tag %u, DrawID %u (ThreadID %u): ",
+        snprintf(message_buffer, sizeof(message_buffer), "ExecuteIndirect: GlobalCommandIndex %010u, Debug tag %010u, DrawID %04u (ThreadID %04u): ",
                 debug_instance, debug_thread_id[0], debug_thread_id[1], debug_thread_id[2]);
 
         if (message_word_count == 2)
diff --git a/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp b/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp
index 64615006..6a63a445 100644
--- a/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp
+++ b/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp
@@ -51,12 +51,13 @@ layout(push_constant) uniform Registers
 
 	// Debug metadata here
 	uint debug_tag;
+    uint implicit_instance;
 };
 
 void main()
 {
     if (debug_tag != 0u)
-        DEBUG_CHANNEL_INIT(uvec3(debug_tag, gl_WorkGroupID.x, gl_LocalInvocationIndex));
+        DEBUG_CHANNEL_INIT_IMPLICIT_INSTANCE(uvec3(debug_tag, gl_WorkGroupID.x, gl_LocalInvocationIndex), implicit_instance);
 
     Command cmd = commands_va.commands[gl_LocalInvocationIndex];
 
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 54865ea4..2baab669 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -3029,6 +3029,7 @@ struct vkd3d_execute_indirect_args
 
     /* Arbitrary tag used for debug version of state patcher. Debug messages from tag 0 are ignored. */
     uint32_t debug_tag;
+    uint32_t implicit_instance;
 };
 
 struct vkd3d_execute_indirect_pipeline
-- 
2.36.1

From d7567cbb970c7b96b3bcf610d5d5ac12eb64e66b Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 1 Jun 2022 14:31:27 +0200
Subject: [PATCH 26/42] vkd3d: Do patch barrier after ending render pass.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 7471af7a..e73d5201 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -9556,9 +9556,9 @@ static void d3d12_command_list_execute_indirect_state_template(
     else
     {
         vk_patch_cmd_buffer = list->vk_command_buffer;
+        d3d12_command_list_end_current_render_pass(list, true);
         VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
                 VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 1, &barrier, 0, NULL, 0, NULL));
-        d3d12_command_list_end_current_render_pass(list, true);
         d3d12_command_list_invalidate_current_pipeline(list, true);
     }
 
-- 
2.36.1

From 2078912c26fb8faa960ec2fafbd56bf24ead51f9 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 8 Jun 2022 12:32:46 +0200
Subject: [PATCH 27/42] common: Assert that alignment is > 0.

Found bug when allocating device generated commands.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 include/private/vkd3d_common.h | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/include/private/vkd3d_common.h b/include/private/vkd3d_common.h
index 5a12a19c..c72b1cb0 100644
--- a/include/private/vkd3d_common.h
+++ b/include/private/vkd3d_common.h
@@ -27,6 +27,7 @@
 #include <stdint.h>
 #include <limits.h>
 #include <stdbool.h>
+#include <assert.h>
 
 #ifdef _MSC_VER
 #include <intrin.h>
@@ -46,11 +47,13 @@
 
 static inline uint64_t align64(uint64_t addr, uint64_t alignment)
 {
+    assert(alignment > 0);
     return (addr + (alignment - 1)) & ~(alignment - 1);
 }
 
 static inline size_t align(size_t addr, size_t alignment)
 {
+    assert(alignment > 0);
     return (addr + (alignment - 1)) & ~(alignment - 1);
 }
 
-- 
2.36.1

From 6ac298929d212592c085a5456a658247a1d99d93 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 8 Jun 2022 12:34:01 +0200
Subject: [PATCH 28/42] vkd3d: Take memory requirement for preprocess buffer
 into account.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index e73d5201..d311b19f 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -12676,6 +12676,7 @@ static HRESULT d3d12_command_signature_allocate_preprocess_memory_for_list(
     const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
     VkGeneratedCommandsMemoryRequirementsInfoNV info;
     VkMemoryRequirements2 memory_info;
+    uint32_t alignment;
 
     memory_info.sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
     memory_info.pNext = NULL;
@@ -12697,10 +12698,13 @@ static HRESULT d3d12_command_signature_allocate_preprocess_memory_for_list(
 
     VK_CALL(vkGetGeneratedCommandsMemoryRequirementsNV(list->device->vk_device, &info, &memory_info));
 
+    alignment = max(memory_info.memoryRequirements.alignment,
+            list->device->device_info.device_generated_commands_properties_nv.minIndirectCommandsBufferOffsetAlignment);
+
     if (!d3d12_command_allocator_allocate_scratch_memory(list->allocator,
             VKD3D_SCRATCH_POOL_KIND_INDIRECT_PREPROCESS,
             memory_info.memoryRequirements.size,
-            list->device->device_info.device_generated_commands_properties_nv.minIndirectCommandsBufferOffsetAlignment,
+            alignment,
             memory_info.memoryRequirements.memoryTypeBits, allocation))
         return E_OUTOFMEMORY;
 
-- 
2.36.1

From ab071fb2083d2f305e27c19ec061d25185f58c20 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 8 Jun 2022 12:34:25 +0200
Subject: [PATCH 29/42] vkd3d: Don't use zero alignment for preprocess buffer.

Horrible bug where we'd end up always allocating from offset 0.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/device.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index 94ca0c17..f20781f5 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -2584,6 +2584,7 @@ static HRESULT d3d12_device_create_scratch_buffer(struct d3d12_device *device, e
         alloc_info.heap_properties.Type = D3D12_HEAP_TYPE_DEFAULT;
         alloc_info.memory_requirements.size = size;
         alloc_info.memory_requirements.memoryTypeBits = memory_types;
+        alloc_info.memory_requirements.alignment = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;
         alloc_info.heap_flags = D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS | D3D12_HEAP_FLAG_CREATE_NOT_ZEROED;
         alloc_info.optional_memory_properties = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
         alloc_info.flags = VKD3D_ALLOCATION_FLAG_GLOBAL_BUFFER;
-- 
2.36.1

From b77091ba6be58e5a06f56e52a5c5794006b9e50e Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 8 Jun 2022 13:17:36 +0200
Subject: [PATCH 30/42] vkd3d: Don't suballocate scratch buffers.

Scratch buffers are 1 MiB blocks which will end
up being suballocated. This was not intended and a fallout from the
earlier change where VA_SIZE was bumped to 2 MiB for Elden Ring.

Introduce a memory allocation flag INTERNAL_SCRATCH which disables
suballocation and VA map insert.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/device.c        |  3 ++-
 libs/vkd3d/heap.c          |  1 +
 libs/vkd3d/memory.c        | 25 +++++++++++++++++--------
 libs/vkd3d/vkd3d_private.h |  5 +++++
 4 files changed, 25 insertions(+), 9 deletions(-)

diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index f20781f5..4a994f63 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -2571,6 +2571,7 @@ static HRESULT d3d12_device_create_scratch_buffer(struct d3d12_device *device, e
         alloc_info.heap_desc.SizeInBytes = size;
         alloc_info.heap_desc.Alignment = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;
         alloc_info.heap_desc.Flags = D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS | D3D12_HEAP_FLAG_CREATE_NOT_ZEROED;
+        alloc_info.extra_allocation_flags = VKD3D_ALLOCATION_FLAG_INTERNAL_SCRATCH;
 
         if (FAILED(hr = vkd3d_allocate_heap_memory(device, &device->memory_allocator,
                 &alloc_info, &scratch->allocation)))
@@ -2587,7 +2588,7 @@ static HRESULT d3d12_device_create_scratch_buffer(struct d3d12_device *device, e
         alloc_info.memory_requirements.alignment = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;
         alloc_info.heap_flags = D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS | D3D12_HEAP_FLAG_CREATE_NOT_ZEROED;
         alloc_info.optional_memory_properties = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
-        alloc_info.flags = VKD3D_ALLOCATION_FLAG_GLOBAL_BUFFER;
+        alloc_info.flags = VKD3D_ALLOCATION_FLAG_GLOBAL_BUFFER | VKD3D_ALLOCATION_FLAG_INTERNAL_SCRATCH;
 
         if (FAILED(hr = vkd3d_allocate_memory(device, &device->memory_allocator,
                 &alloc_info, &scratch->allocation)))
diff --git a/libs/vkd3d/heap.c b/libs/vkd3d/heap.c
index 6640ebe7..910d8344 100644
--- a/libs/vkd3d/heap.c
+++ b/libs/vkd3d/heap.c
@@ -240,6 +240,7 @@ static HRESULT d3d12_heap_init(struct d3d12_heap *heap, struct d3d12_device *dev
 
     alloc_info.heap_desc = heap->desc;
     alloc_info.host_ptr = host_address;
+    alloc_info.extra_allocation_flags = 0;
 
     if (FAILED(hr = vkd3d_private_store_init(&heap->private_store)))
         return hr;
diff --git a/libs/vkd3d/memory.c b/libs/vkd3d/memory.c
index 13307cdb..f7ff0829 100644
--- a/libs/vkd3d/memory.c
+++ b/libs/vkd3d/memory.c
@@ -349,12 +349,15 @@ static HRESULT vkd3d_import_host_memory(struct d3d12_device *device, void *host_
     return hr;
 }
 
-static HRESULT vkd3d_allocation_assign_gpu_address(struct vkd3d_memory_allocation *allocation, struct d3d12_device *device, struct vkd3d_memory_allocator *allocator)
+static HRESULT vkd3d_allocation_assign_gpu_address(struct vkd3d_memory_allocation *allocation,
+        struct d3d12_device *device, struct vkd3d_memory_allocator *allocator)
 {
     if (device->device_info.buffer_device_address_features.bufferDeviceAddress)
         allocation->resource.va = vkd3d_get_buffer_device_address(device, allocation->resource.vk_buffer);
-    else
+    else if (!(allocation->flags & VKD3D_ALLOCATION_FLAG_INTERNAL_SCRATCH))
         allocation->resource.va = vkd3d_va_map_alloc_fake_va(&allocator->va_map, allocation->resource.size);
+    else
+        allocation->resource.va = 0xdeadbeef;
 
     if (!allocation->resource.va)
     {
@@ -362,7 +365,9 @@ static HRESULT vkd3d_allocation_assign_gpu_address(struct vkd3d_memory_allocatio
         return E_OUTOFMEMORY;
     }
 
-    vkd3d_va_map_insert(&allocator->va_map, &allocation->resource);
+    /* Internal scratch buffers are not visible to application so we never have to map it back to VkBuffer. */
+    if (!(allocation->flags & VKD3D_ALLOCATION_FLAG_INTERNAL_SCRATCH))
+        vkd3d_va_map_insert(&allocator->va_map, &allocation->resource);
     return S_OK;
 }
 
@@ -446,10 +451,12 @@ static void vkd3d_memory_allocation_free(const struct vkd3d_memory_allocation *a
 
     if ((allocation->flags & VKD3D_ALLOCATION_FLAG_GPU_ADDRESS) && allocation->resource.va)
     {
-        vkd3d_va_map_remove(&allocator->va_map, &allocation->resource);
-
-        if (!device->device_info.buffer_device_address_features.bufferDeviceAddress)
-            vkd3d_va_map_free_fake_va(&allocator->va_map, allocation->resource.va, allocation->resource.size);
+        if (!(allocation->flags & VKD3D_ALLOCATION_FLAG_INTERNAL_SCRATCH))
+        {
+            vkd3d_va_map_remove(&allocator->va_map, &allocation->resource);
+            if (!device->device_info.buffer_device_address_features.bufferDeviceAddress)
+                vkd3d_va_map_free_fake_va(&allocator->va_map, allocation->resource.va, allocation->resource.size);
+        }
     }
 
     if (allocation->resource.view_map)
@@ -1417,7 +1424,8 @@ HRESULT vkd3d_allocate_memory(struct d3d12_device *device, struct vkd3d_memory_a
 
     suballocate = !info->pNext && !info->host_ptr &&
             info->memory_requirements.size < VKD3D_VA_BLOCK_SIZE &&
-            !(info->heap_flags & (D3D12_HEAP_FLAG_DENY_BUFFERS | D3D12_HEAP_FLAG_ALLOW_WRITE_WATCH));
+            !(info->heap_flags & (D3D12_HEAP_FLAG_DENY_BUFFERS | D3D12_HEAP_FLAG_ALLOW_WRITE_WATCH) &&
+            !(info->flags & VKD3D_ALLOCATION_FLAG_INTERNAL_SCRATCH));
 
     if (suballocate)
         hr = vkd3d_suballocate_memory(device, allocator, info, allocation);
@@ -1447,6 +1455,7 @@ HRESULT vkd3d_allocate_heap_memory(struct d3d12_device *device, struct vkd3d_mem
     alloc_info.heap_flags = info->heap_desc.Flags;
     alloc_info.host_ptr = info->host_ptr;
 
+    alloc_info.flags |= info->extra_allocation_flags;
     if (!(info->heap_desc.Flags & D3D12_HEAP_FLAG_DENY_BUFFERS))
         alloc_info.flags |= VKD3D_ALLOCATION_FLAG_GLOBAL_BUFFER;
 
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 2baab669..a9198889 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -586,6 +586,10 @@ enum vkd3d_allocation_flag
     VKD3D_ALLOCATION_FLAG_ALLOW_WRITE_WATCH = (1u << 3),
     VKD3D_ALLOCATION_FLAG_NO_FALLBACK       = (1u << 4),
     VKD3D_ALLOCATION_FLAG_DEDICATED         = (1u << 5),
+    /* Intended for internal allocation of scratch buffers.
+     * They are never suballocated since we do that ourselves,
+     * and we do not consume space in the VA map. */
+    VKD3D_ALLOCATION_FLAG_INTERNAL_SCRATCH  = (1u << 6),
 };
 
 #define VKD3D_MEMORY_CHUNK_SIZE (VKD3D_VA_BLOCK_SIZE * 8)
@@ -607,6 +611,7 @@ struct vkd3d_allocate_heap_memory_info
 {
     D3D12_HEAP_DESC heap_desc;
     void *host_ptr;
+    uint32_t extra_allocation_flags;
 };
 
 struct vkd3d_allocate_resource_memory_info
-- 
2.36.1

From 0ea5a1779789a34633ce413a57197e08ee381054 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 8 Jun 2022 14:35:22 +0200
Subject: [PATCH 31/42] dxil-spirv: Update submodule.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 subprojects/dxil-spirv | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/subprojects/dxil-spirv b/subprojects/dxil-spirv
index e08570fd..b1afbf5f 160000
--- a/subprojects/dxil-spirv
+++ b/subprojects/dxil-spirv
@@ -1 +1 @@
-Subproject commit e08570fd2aa2bbe5bb374bee6be6bb7b7c5a1748
+Subproject commit b1afbf5fa8e6f10f6c226cea222a8a5d5518870f
-- 
2.36.1

From 6434db2c82eb581850af3b0860b245eb9d67f1dd Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 8 Jun 2022 15:30:59 +0200
Subject: [PATCH 32/42] vkd3d: Add quirk option to range check every raw VA
 CBV.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 include/vkd3d.h          |  1 +
 include/vkd3d_shader.h   |  3 +++
 libs/vkd3d-shader/dxil.c | 27 +++++++++++++++++++++++++++
 libs/vkd3d/device.c      |  2 ++
 4 files changed, 33 insertions(+)

diff --git a/include/vkd3d.h b/include/vkd3d.h
index 4eebff43..db573125 100644
--- a/include/vkd3d.h
+++ b/include/vkd3d.h
@@ -89,6 +89,7 @@ extern "C" {
 #define VKD3D_CONFIG_FLAG_SHADER_CACHE_SYNC (1ull << 27)
 #define VKD3D_CONFIG_FLAG_FORCE_RAW_VA_CBV (1ull << 28)
 #define VKD3D_CONFIG_FLAG_ZERO_MEMORY_WORKAROUNDS_COMMITTED_BUFFER_UAV (1ull << 29)
+#define VKD3D_CONFIG_FLAG_FORCE_ROBUST_PHYSICAL_CBV (1ull << 30)
 
 typedef HRESULT (*PFN_vkd3d_signal_event)(HANDLE event);
 
diff --git a/include/vkd3d_shader.h b/include/vkd3d_shader.h
index 7f7e893c..0ac0195a 100644
--- a/include/vkd3d_shader.h
+++ b/include/vkd3d_shader.h
@@ -333,6 +333,9 @@ enum vkd3d_shader_quirk
     /* For Position builtins in Output storage class, emit Invariant decoration.
      * Normally, games have to emit Precise math for position, but if they forget ... */
     VKD3D_SHADER_QUIRK_INVARIANT_POSITION = (1 << 2),
+
+    /* For raw VA CBVs, range check every access. */
+    VKD3D_SHADER_QUIRK_FORCE_ROBUST_PHYSICAL_CBV = (1 << 3),
 };
 
 struct vkd3d_shader_quirk_hash
diff --git a/libs/vkd3d-shader/dxil.c b/libs/vkd3d-shader/dxil.c
index 0a3ed2cd..96f426d1 100644
--- a/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d-shader/dxil.c
@@ -846,6 +846,18 @@ int vkd3d_shader_compile_dxil(const struct vkd3d_shader_code *dxbc,
         }
     }
 
+    if (quirks & VKD3D_SHADER_QUIRK_FORCE_ROBUST_PHYSICAL_CBV)
+    {
+        const dxil_spv_option_robust_physical_cbv_load robust_cbv =
+                { { DXIL_SPV_OPTION_ROBUST_PHYSICAL_CBV_LOAD }, DXIL_SPV_TRUE };
+        if (dxil_spv_converter_add_option(converter, &robust_cbv.base) != DXIL_SPV_SUCCESS)
+        {
+            ERR("dxil-spirv does not support ROBUST_PHYSICAL_CBV_LOAD.\n");
+            ret = VKD3D_ERROR_NOT_IMPLEMENTED;
+            goto end;
+        }
+    }
+
     remap_userdata.shader_interface_info = shader_interface_info;
     remap_userdata.shader_interface_local_info = NULL;
     remap_userdata.num_root_descriptors = num_root_descriptors;
@@ -925,6 +937,7 @@ int vkd3d_shader_compile_dxil_export(const struct vkd3d_shader_code *dxil,
     vkd3d_shader_hash_t hash;
     char *demangled_export;
     int ret = VKD3D_OK;
+    uint32_t quirks;
     void *code;
 
     dxil_spv_set_thread_log_callback(vkd3d_dxil_log_callback, NULL);
@@ -943,6 +956,8 @@ int vkd3d_shader_compile_dxil_export(const struct vkd3d_shader_code *dxil,
         }
     }
 
+    quirks = vkd3d_shader_compile_arguments_select_quirks(compiler_args, hash);
+
     dxil_spv_begin_thread_allocator_context();
 
     vkd3d_shader_dump_shader(hash, dxil, "lib.dxil");
@@ -1213,6 +1228,18 @@ int vkd3d_shader_compile_dxil_export(const struct vkd3d_shader_code *dxil,
             WARN("dxil-spirv does not support SHADER_SOURCE_FILE.\n");
     }
 
+    if (quirks & VKD3D_SHADER_QUIRK_FORCE_ROBUST_PHYSICAL_CBV)
+    {
+        const dxil_spv_option_robust_physical_cbv_load robust_cbv =
+                { { DXIL_SPV_OPTION_ROBUST_PHYSICAL_CBV_LOAD }, DXIL_SPV_TRUE };
+        if (dxil_spv_converter_add_option(converter, &robust_cbv.base) != DXIL_SPV_SUCCESS)
+        {
+            ERR("dxil-spirv does not support ROBUST_PHYSICAL_CBV_LOAD.\n");
+            ret = VKD3D_ERROR_NOT_IMPLEMENTED;
+            goto end;
+        }
+    }
+
     if (compiler_args)
     {
         for (i = 0; i < compiler_args->target_extension_count; i++)
diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index 4a994f63..cbbf8ac3 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -617,6 +617,7 @@ static void vkd3d_instance_apply_global_shader_quirks(void)
     static const struct override overrides[] =
     {
         { VKD3D_CONFIG_FLAG_FORCE_NO_INVARIANT_POSITION, VKD3D_SHADER_QUIRK_INVARIANT_POSITION, true },
+        { VKD3D_CONFIG_FLAG_FORCE_ROBUST_PHYSICAL_CBV, VKD3D_SHADER_QUIRK_FORCE_ROBUST_PHYSICAL_CBV, false },
     };
     uint64_t eq_test;
     unsigned int i;
@@ -660,6 +661,7 @@ static const struct vkd3d_debug_option vkd3d_config_options[] =
     {"pipeline_library_app_cache", VKD3D_CONFIG_FLAG_PIPELINE_LIBRARY_APP_CACHE_ONLY},
     {"shader_cache_sync", VKD3D_CONFIG_FLAG_SHADER_CACHE_SYNC},
     {"force_raw_va_cbv", VKD3D_CONFIG_FLAG_FORCE_RAW_VA_CBV},
+    {"force_robust_physical_cbv", VKD3D_CONFIG_FLAG_FORCE_ROBUST_PHYSICAL_CBV},
 };
 
 static void vkd3d_config_flags_init_once(void)
-- 
2.36.1

From e497e56aa19b5793780f221f5b3980e534af5dd0 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Thu, 9 Jun 2022 15:27:45 +0200
Subject: [PATCH 33/42] vkd3d: Don't synchronize against PREPROCESS stages.

They are implied when using isPreprocessed = VK_FALSE.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index d311b19f..ffb775af 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -4084,9 +4084,9 @@ static HRESULT d3d12_command_list_build_init_commands(struct d3d12_command_list
         barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
         barrier.pNext = NULL;
         barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
-        barrier.dstAccessMask = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV | VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
+        barrier.dstAccessMask = VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
         VK_CALL(vkCmdPipelineBarrier(list->vk_init_commands, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
-                VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV,
+                VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
                 0, 1, &barrier, 0, NULL, 0, NULL));
     }
 
@@ -9575,9 +9575,9 @@ static void d3d12_command_list_execute_indirect_state_template(
     if (vk_patch_cmd_buffer == list->vk_command_buffer)
     {
         barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
-        barrier.dstAccessMask = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV | VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
+        barrier.dstAccessMask = VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
         VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
-                VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV,
+                VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
                 0, 1, &barrier, 0, NULL, 0, NULL));
         /* The barrier is deferred if we moved the dispatch to init command buffer. */
     }
-- 
2.36.1

From bc922b8dd9ea0b6ad3d633648db5e14ce033f2ca Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 10 Jun 2022 11:04:46 +0200
Subject: [PATCH 34/42] tests: Test both aligned and "unaligned" argument
 buffer offsets.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 tests/d3d12_command.c | 19 ++++++++++++-------
 1 file changed, 12 insertions(+), 7 deletions(-)

diff --git a/tests/d3d12_command.c b/tests/d3d12_command.c
index 00c1c9c1..69124ea4 100644
--- a/tests/d3d12_command.c
+++ b/tests/d3d12_command.c
@@ -1467,7 +1467,6 @@ void test_execute_indirect_state(void)
     D3D12_VERTEX_BUFFER_VIEW vbvs[2];
     ID3D12Resource *argument_buffer;
     struct test_context_desc desc;
-    ID3D12Resource *count_buffer;
     ID3D12PipelineState *psos[2];
     struct test_context context;
     struct resource_readback rb;
@@ -1988,14 +1987,20 @@ void test_execute_indirect_state(void)
         argument_buffer = create_upload_buffer(context.device, 256 * 1024, NULL);
         argument_buffer_late = create_default_buffer(context.device, 256 * 1024,
                 D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COPY_DEST);
+
+#define UNALIGNED_ARGUMENT_BUFFER_OFFSET (64 * 1024 + 4)
+#define UNALIGNED_COUNT_BUFFER_OFFSET (128 * 1024 + 4)
+#define ALIGNED_COUNT_BUFFER_OFFSET (128 * 1024 + 4 * 1024)
         {
-            void *ptr;
-            ID3D12Resource_Map(argument_buffer, 0, NULL, &ptr);
+            uint8_t *ptr;
+            ID3D12Resource_Map(argument_buffer, 0, NULL, (void**)&ptr);
             memcpy(ptr, tests[i].argument_buffer_data, tests[i].argument_buffer_size);
+            memcpy(ptr + UNALIGNED_ARGUMENT_BUFFER_OFFSET, tests[i].argument_buffer_data, tests[i].argument_buffer_size);
+            memcpy(ptr + UNALIGNED_COUNT_BUFFER_OFFSET, &tests[i].api_max_count, sizeof(tests[i].api_max_count));
+            memcpy(ptr + ALIGNED_COUNT_BUFFER_OFFSET, &tests[i].api_max_count, sizeof(tests[i].api_max_count));
             ID3D12Resource_Unmap(argument_buffer, 0, NULL);
         }
 
-        count_buffer = create_upload_buffer(context.device, sizeof(tests[i].api_max_count), &tests[i].api_max_count);
         streamout_buffer = create_default_buffer(context.device, 64 * 1024,
                 D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_STREAM_OUT);
 
@@ -2034,13 +2039,14 @@ void test_execute_indirect_state(void)
                 argument_buffer, 0, NULL, 0);
         /* Test equivalent call with indirect count. */
         ID3D12GraphicsCommandList_ExecuteIndirect(command_list, command_signature, 1024,
-                argument_buffer, 0, count_buffer, 0);
+                argument_buffer, UNALIGNED_ARGUMENT_BUFFER_OFFSET,
+                argument_buffer, UNALIGNED_COUNT_BUFFER_OFFSET);
         /* Test equivalent, but now with late transition to INDIRECT. */
         ID3D12GraphicsCommandList_CopyResource(command_list, argument_buffer_late, argument_buffer);
         transition_resource_state(command_list, argument_buffer_late, D3D12_RESOURCE_STATE_COPY_DEST,
                 D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT);
         ID3D12GraphicsCommandList_ExecuteIndirect(command_list, command_signature, 1024,
-                argument_buffer_late, 0, count_buffer, 0);
+                argument_buffer_late, 0, argument_buffer_late, ALIGNED_COUNT_BUFFER_OFFSET);
 
         /* Root descriptors which are part of the state block are cleared to NULL. Recover them here
          * since attempting to draw next test will crash GPU. */
@@ -2118,7 +2124,6 @@ void test_execute_indirect_state(void)
         ID3D12CommandSignature_Release(command_signature);
         ID3D12Resource_Release(argument_buffer);
         ID3D12Resource_Release(argument_buffer_late);
-        ID3D12Resource_Release(count_buffer);
         ID3D12Resource_Release(streamout_buffer);
         release_resource_readback(&rb);
     }
-- 
2.36.1

From 538c3c1f193514ae5f0b6809632ef2caba976efa Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 10 Jun 2022 14:34:03 +0200
Subject: [PATCH 35/42] vkd3d: Attempt to pack indirect command buffer tighter
 if we can.

If implementation reports 4 alignment on offset, it must be able to
handle 4 byte offset on VAs.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 35 ++++++++++++++++++++++++++++-------
 1 file changed, 28 insertions(+), 7 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index ffb775af..5184ee01 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -12722,9 +12722,11 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
     const struct vkd3d_shader_root_constant *root_constant;
     struct vkd3d_patch_command *patch_commands = NULL;
     VkIndirectCommandsLayoutTokenNV *tokens = NULL;
+    uint32_t required_stride_alignment = 0;
     VkIndirectCommandsLayoutTokenNV token;
     uint32_t generic_u32_copy_count;
     size_t patch_commands_count = 0;
+    uint32_t required_alignment = 0;
     size_t patch_commands_size = 0;
     uint32_t root_parameter_index;
     uint32_t src_word_offset = 0;
@@ -12801,8 +12803,9 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
                 token.pushconstantSize = argument_desc->Constant.Num32BitValuesToSet;
                 token.pushconstantOffset *= sizeof(uint32_t);
                 token.pushconstantSize *= sizeof(uint32_t);
+                required_alignment = sizeof(uint32_t);
 
-                stream_stride = align(stream_stride, sizeof(uint32_t));
+                stream_stride = align(stream_stride, required_alignment);
                 token.offset = stream_stride;
                 stream_stride += token.pushconstantSize;
                 dst_word_offset = token.offset / sizeof(uint32_t);
@@ -12829,8 +12832,9 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
                 token.pushconstantShaderStageFlags = root_signature->graphics.vk_push_stages;
                 token.pushconstantOffset = root_parameter->descriptor.raw_va_root_descriptor_index * sizeof(VkDeviceAddress);
                 token.pushconstantSize = sizeof(VkDeviceAddress);
+                required_alignment = sizeof(uint32_t);
 
-                stream_stride = align(stream_stride, sizeof(uint32_t));
+                stream_stride = align(stream_stride, required_alignment);
                 token.offset = stream_stride;
                 stream_stride += token.pushconstantSize;
                 dst_word_offset = token.offset / sizeof(uint32_t);
@@ -12845,7 +12849,13 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
                 token.vertexBindingUnit = argument_desc->VertexBuffer.Slot;
                 token.vertexDynamicStride = VK_TRUE;
 
-                stream_stride = align(stream_stride, sizeof(VkDeviceAddress));
+                /* If device exposes 4 byte alignment of the indirect command buffer, it implies we can
+                 * pack VA at sub-scalar alignment. Probably not completely within spec, but hey ... */
+                required_alignment = min(
+                        device->device_info.device_generated_commands_properties_nv.minIndirectCommandsBufferOffsetAlignment,
+                        sizeof(VkDeviceAddress));
+
+                stream_stride = align(stream_stride, required_alignment);
                 token.offset = stream_stride;
                 stream_stride += sizeof(VkBindVertexBufferIndirectCommandNV);
                 dst_word_offset = token.offset / sizeof(uint32_t);
@@ -12857,7 +12867,14 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW:
                 token.tokenType = VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV;
-                stream_stride = align(stream_stride, sizeof(VkDeviceAddress));
+
+                /* If device exposes 4 byte alignment of the indirect command buffer, it implies we can
+                 * pack VA at sub-scalar alignment. Probably not completely within spec, but hey ... */
+                required_alignment = min(
+                        device->device_info.device_generated_commands_properties_nv.minIndirectCommandsBufferOffsetAlignment,
+                        sizeof(VkDeviceAddress));
+
+                stream_stride = align(stream_stride, required_alignment);
                 token.offset = stream_stride;
                 stream_stride += sizeof(VkBindVertexBufferIndirectCommandNV);
                 dst_word_offset = token.offset / sizeof(uint32_t);
@@ -12879,7 +12896,8 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_DRAW:
                 token.tokenType = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV;
-                stream_stride = align(stream_stride, sizeof(uint32_t));
+                required_alignment = sizeof(uint32_t);
+                stream_stride = align(stream_stride, required_alignment);
                 token.offset = stream_stride;
                 stream_stride += sizeof(VkDrawIndirectCommand);
                 dst_word_offset = token.offset / sizeof(uint32_t);
@@ -12889,7 +12907,8 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED:
                 token.tokenType = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV;
-                stream_stride = align(stream_stride, sizeof(uint32_t));
+                required_alignment = sizeof(uint32_t);
+                stream_stride = align(stream_stride, required_alignment);
                 token.offset = stream_stride;
                 stream_stride += sizeof(VkDrawIndexedIndirectCommand);
                 dst_word_offset = token.offset / sizeof(uint32_t);
@@ -12921,9 +12940,11 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
                 patch_commands[patch_commands_count].dst_offset = dst_word_offset++;
             }
         }
+
+        required_stride_alignment = max(required_stride_alignment, required_alignment);
     }
 
-    stream_stride = align(stream_stride, sizeof(VkDeviceAddress));
+    stream_stride = align(stream_stride, required_stride_alignment);
 
     if (FAILED(hr = d3d12_command_signature_init_patch_commands_buffer(signature, device, patch_commands, patch_commands_count)))
         goto end;
-- 
2.36.1

From d23f5f434362692d8c16844abb759916fe6394e8 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 10 Jun 2022 14:35:21 +0200
Subject: [PATCH 36/42] vkd3d: Attempt to reuse application indirect command
 buffer.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 201 +++++++++++++++++++++++++++----------------
 1 file changed, 127 insertions(+), 74 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 5184ee01..ffa593e4 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -9466,6 +9466,7 @@ static void d3d12_command_list_execute_indirect_state_template(
         struct d3d12_resource *count_buffer, UINT64 count_buffer_offset)
 {
     const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
+    const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV *props;
     struct vkd3d_scratch_allocation preprocess_allocation;
     struct vkd3d_scratch_allocation stream_allocation;
     struct vkd3d_scratch_allocation count_allocation;
@@ -9476,6 +9477,8 @@ static void d3d12_command_list_execute_indirect_state_template(
     VkDeviceSize preprocess_size;
     VkPipeline current_pipeline;
     VkMemoryBarrier barrier;
+    bool require_ibo_update;
+    bool require_patch;
     unsigned int i;
     HRESULT hr;
 
@@ -9491,6 +9494,8 @@ static void d3d12_command_list_execute_indirect_state_template(
     current_pipeline = list->current_pipeline;
 
     memset(&patch_args, 0, sizeof(patch_args));
+    patch_args.debug_tag = 0; /* Modify to non-zero value as desired when debugging. */
+
     if (FAILED(hr = d3d12_command_signature_allocate_preprocess_memory_for_list(
             list, signature, current_pipeline,
             max_command_count, &preprocess_allocation, &preprocess_size)))
@@ -9499,87 +9504,120 @@ static void d3d12_command_list_execute_indirect_state_template(
         return;
     }
 
-    if (FAILED(hr = d3d12_command_signature_allocate_stream_memory_for_list(
-            list, signature, max_command_count, &stream_allocation)))
-    {
-        WARN("Failed to allocate stream memory.\n");
-        return;
-    }
+    /* If everything regarding alignment works out, we can just reuse the app indirect buffer instead. */
+    require_ibo_update = false;
+    require_patch = false;
 
-    if (count_buffer)
+    /* Bind IBO. If we always update the IBO indirectly, do not validate the index buffer here.
+     * We can render fine even with a NULL IBO bound. */
+    for (i = 0; i < signature->desc.NumArgumentDescs; i++)
     {
-        if (FAILED(hr = d3d12_command_allocator_allocate_scratch_memory(list->allocator,
-                VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
-                sizeof(uint32_t),
-                list->device->device_info.device_generated_commands_properties_nv.minSequencesCountBufferOffsetAlignment,
-                ~0u, &count_allocation)))
+        if (signature->desc.pArgumentDescs[i].Type == D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW)
         {
-            WARN("Failed to allocate count memory.\n");
-            return;
+            require_ibo_update = true;
+            break;
         }
     }
 
-    patch_args.template_va = signature->state_template.buffer_va;
-    patch_args.api_buffer_va = d3d12_resource_get_va(arg_buffer, arg_buffer_offset);
-    patch_args.device_generated_commands_va = stream_allocation.va;
-    patch_args.indirect_count_va = count_buffer ? d3d12_resource_get_va(count_buffer, count_buffer_offset) : 0;
-    patch_args.dst_indirect_count_va = count_buffer ? count_allocation.va : 0;
-    patch_args.api_buffer_word_stride = signature->desc.ByteStride / sizeof(uint32_t);
-    patch_args.device_generated_commands_word_stride = signature->state_template.stride / sizeof(uint32_t);
-    patch_args.debug_tag = 0; /* Modify to non-zero value as desired when debugging. */
+    /* - Stride can mismatch, i.e. we need internal alignment of arguments.
+     * - Min required alignment on the indirect buffer itself might be too strict.
+     * - Min required alignment on count buffer might be too strict.
+     * - We require debugging.
+     * - Temporary: IBO type rewrite is required. TODO: Use index type LUT feature. */
+    props = &list->device->device_info.device_generated_commands_properties_nv;
 
-    if (patch_args.debug_tag != 0)
+    if ((signature->state_template.stride != signature->desc.ByteStride && max_command_count > 1) ||
+            (arg_buffer_offset & (props->minIndirectCommandsBufferOffsetAlignment - 1)) ||
+            (count_buffer && (count_buffer_offset & (props->minSequencesCountBufferOffsetAlignment - 1))) ||
+            patch_args.debug_tag ||
+            require_ibo_update)
     {
-        /* Makes log easier to understand since a sorted log will appear in-order. */
-        static uint32_t vkd3d_implicit_instance_count;
-        patch_args.implicit_instance = vkd3d_atomic_uint32_increment(
-                &vkd3d_implicit_instance_count, vkd3d_memory_order_relaxed) - 1;
+        require_patch = true;
     }
 
-    barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
-    barrier.pNext = NULL;
-    barrier.srcAccessMask = 0;
-    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
-
-    if (!list->execute_indirect.has_observed_transition_to_indirect)
+    if (require_patch)
     {
-        /* Fast path, throw the template resolve to the init command buffer. */
-        d3d12_command_allocator_allocate_init_command_buffer(list->allocator, list);
-        vk_patch_cmd_buffer = list->vk_init_commands;
-        if (!list->execute_indirect.has_emitted_indirect_to_compute_barrier)
+        if (FAILED(hr = d3d12_command_signature_allocate_stream_memory_for_list(
+                list, signature, max_command_count, &stream_allocation)))
+        {
+            WARN("Failed to allocate stream memory.\n");
+            return;
+        }
+
+        if (count_buffer)
+        {
+            if (FAILED(hr = d3d12_command_allocator_allocate_scratch_memory(list->allocator,
+                    VKD3D_SCRATCH_POOL_KIND_DEVICE_STORAGE,
+                    sizeof(uint32_t),
+                    props->minSequencesCountBufferOffsetAlignment,
+                    ~0u, &count_allocation)))
+            {
+                WARN("Failed to allocate count memory.\n");
+                return;
+            }
+        }
+
+        patch_args.template_va = signature->state_template.buffer_va;
+        patch_args.api_buffer_va = d3d12_resource_get_va(arg_buffer, arg_buffer_offset);
+        patch_args.device_generated_commands_va = stream_allocation.va;
+        patch_args.indirect_count_va = count_buffer ? d3d12_resource_get_va(count_buffer, count_buffer_offset) : 0;
+        patch_args.dst_indirect_count_va = count_buffer ? count_allocation.va : 0;
+        patch_args.api_buffer_word_stride = signature->desc.ByteStride / sizeof(uint32_t);
+        patch_args.device_generated_commands_word_stride = signature->state_template.stride / sizeof(uint32_t);
+
+        if (patch_args.debug_tag != 0)
+        {
+            /* Makes log easier to understand since a sorted log will appear in-order. */
+            static uint32_t vkd3d_implicit_instance_count;
+            patch_args.implicit_instance = vkd3d_atomic_uint32_increment(
+                    &vkd3d_implicit_instance_count, vkd3d_memory_order_relaxed) - 1;
+        }
+
+        barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
+        barrier.pNext = NULL;
+        barrier.srcAccessMask = 0;
+        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
+
+        if (!list->execute_indirect.has_observed_transition_to_indirect)
+        {
+            /* Fast path, throw the template resolve to the init command buffer. */
+            d3d12_command_allocator_allocate_init_command_buffer(list->allocator, list);
+            vk_patch_cmd_buffer = list->vk_init_commands;
+            if (!list->execute_indirect.has_emitted_indirect_to_compute_barrier)
+            {
+                VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+                        VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 1, &barrier, 0, NULL, 0, NULL));
+                list->execute_indirect.has_emitted_indirect_to_compute_barrier = true;
+            }
+        }
+        else
         {
+            vk_patch_cmd_buffer = list->vk_command_buffer;
+            d3d12_command_list_end_current_render_pass(list, true);
             VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
                     VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 1, &barrier, 0, NULL, 0, NULL));
-            list->execute_indirect.has_emitted_indirect_to_compute_barrier = true;
+            d3d12_command_list_invalidate_current_pipeline(list, true);
         }
-    }
-    else
-    {
-        vk_patch_cmd_buffer = list->vk_command_buffer;
-        d3d12_command_list_end_current_render_pass(list, true);
-        VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
-                VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 1, &barrier, 0, NULL, 0, NULL));
-        d3d12_command_list_invalidate_current_pipeline(list, true);
-    }
 
-    VK_CALL(vkCmdPushConstants(vk_patch_cmd_buffer, signature->state_template.pipeline.vk_pipeline_layout,
-            VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(patch_args), &patch_args));
-    VK_CALL(vkCmdBindPipeline(vk_patch_cmd_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
-            signature->state_template.pipeline.vk_pipeline));
+        VK_CALL(vkCmdPushConstants(vk_patch_cmd_buffer, signature->state_template.pipeline.vk_pipeline_layout,
+                VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(patch_args), &patch_args));
+        VK_CALL(vkCmdBindPipeline(vk_patch_cmd_buffer, VK_PIPELINE_BIND_POINT_COMPUTE,
+                signature->state_template.pipeline.vk_pipeline));
 
-    /* One workgroup processes the patching for one draw. We could potentially use indirect dispatch
-     * to restrict the patching work to just the indirect count, but meh, just more barriers.
-     * We'll nop out the workgroup early based on direct count, and the number of threads should be trivial either way. */
-    VK_CALL(vkCmdDispatch(vk_patch_cmd_buffer, max_command_count, 1, 1));
+        /* One workgroup processes the patching for one draw. We could potentially use indirect dispatch
+         * to restrict the patching work to just the indirect count, but meh, just more barriers.
+         * We'll nop out the workgroup early based on direct count, and the number of threads should be trivial either way. */
+        VK_CALL(vkCmdDispatch(vk_patch_cmd_buffer, max_command_count, 1, 1));
 
-    if (vk_patch_cmd_buffer == list->vk_command_buffer)
-    {
-        barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
-        barrier.dstAccessMask = VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
-        VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
-                VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
-                0, 1, &barrier, 0, NULL, 0, NULL));
-        /* The barrier is deferred if we moved the dispatch to init command buffer. */
+        if (vk_patch_cmd_buffer == list->vk_command_buffer)
+        {
+            barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+            barrier.dstAccessMask = VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
+            VK_CALL(vkCmdPipelineBarrier(vk_patch_cmd_buffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
+                    0, 1, &barrier, 0, NULL, 0, NULL));
+            /* The barrier is deferred if we moved the dispatch to init command buffer. */
+        }
     }
 
     if (!d3d12_command_list_begin_render_pass(list))
@@ -9588,13 +9626,7 @@ static void d3d12_command_list_execute_indirect_state_template(
         return;
     }
 
-    /* Bind IBO. If we always update the IBO indirectly, do not validate the index buffer here.
-     * We can render fine even with a NULL IBO bound. */
-    for (i = 0; i < signature->desc.NumArgumentDescs; i++)
-        if (signature->desc.pArgumentDescs[i].Type == D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW)
-            break;
-
-    if (i == signature->desc.NumArgumentDescs &&
+    if (!require_ibo_update &&
             signature->desc.pArgumentDescs[signature->desc.NumArgumentDescs - 1].Type ==
                     D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED &&
             !d3d12_command_list_update_index_buffer(list))
@@ -9618,8 +9650,16 @@ static void d3d12_command_list_execute_indirect_state_template(
 
     if (count_buffer)
     {
-        generated.sequencesCountBuffer = count_allocation.buffer;
-        generated.sequencesCountOffset = count_allocation.offset;
+        if (require_patch)
+        {
+            generated.sequencesCountBuffer = count_allocation.buffer;
+            generated.sequencesCountOffset = count_allocation.offset;
+        }
+        else
+        {
+            generated.sequencesCountBuffer = count_buffer->res.vk_buffer;
+            generated.sequencesCountOffset = count_buffer->mem.offset + count_buffer_offset;
+        }
     }
     else
     {
@@ -9627,8 +9667,21 @@ static void d3d12_command_list_execute_indirect_state_template(
         generated.sequencesCountOffset = 0;
     }
 
-    stream.buffer = stream_allocation.buffer;
-    stream.offset = stream_allocation.offset;
+    if (require_patch)
+    {
+        stream.buffer = stream_allocation.buffer;
+        stream.offset = stream_allocation.offset;
+    }
+    else
+    {
+        stream.buffer = arg_buffer->res.vk_buffer;
+        stream.offset = arg_buffer->mem.offset + arg_buffer_offset;
+    }
+
+    if (require_patch)
+        INFO("Template requires patching :(\n");
+    else
+        INFO("Template skips patching :)\n");
 
     VK_CALL(vkCmdExecuteGeneratedCommandsNV(list->vk_command_buffer, VK_FALSE, &generated));
 
-- 
2.36.1

From 24de683375e582800051fae06872f89b90901584 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 10 Jun 2022 15:36:18 +0200
Subject: [PATCH 37/42] vkd3d: Use index type LUT.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c                                | 13 +++++++++----
 libs/vkd3d/shaders/cs_execute_indirect_patch.comp   |  9 ---------
 .../cs_execute_indirect_patch_debug_ring.comp       |  7 -------
 3 files changed, 9 insertions(+), 20 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index ffa593e4..36b3e201 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -9522,15 +9522,13 @@ static void d3d12_command_list_execute_indirect_state_template(
     /* - Stride can mismatch, i.e. we need internal alignment of arguments.
      * - Min required alignment on the indirect buffer itself might be too strict.
      * - Min required alignment on count buffer might be too strict.
-     * - We require debugging.
-     * - Temporary: IBO type rewrite is required. TODO: Use index type LUT feature. */
+     * - We require debugging. */
     props = &list->device->device_info.device_generated_commands_properties_nv;
 
     if ((signature->state_template.stride != signature->desc.ByteStride && max_command_count > 1) ||
             (arg_buffer_offset & (props->minIndirectCommandsBufferOffsetAlignment - 1)) ||
             (count_buffer && (count_buffer_offset & (props->minSequencesCountBufferOffsetAlignment - 1))) ||
-            patch_args.debug_tag ||
-            require_ibo_update)
+            patch_args.debug_tag)
     {
         require_patch = true;
     }
@@ -12830,6 +12828,9 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
         VKD3D_PATCH_COMMAND_TOKEN_COPY_ROOT_VA_HI,
     };
 
+    static const VkIndexType vk_index_types[] = { VK_INDEX_TYPE_UINT32, VK_INDEX_TYPE_UINT16 };
+    static const uint32_t d3d_index_types[] = { DXGI_FORMAT_R32_UINT, DXGI_FORMAT_R16_UINT };
+
     if (!device->device_info.device_generated_commands_features_nv.deviceGeneratedCommands)
     {
         WARN("Device generated commands not supported, indirect state commands will be ignored.\n");
@@ -12920,6 +12921,9 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
 
             case D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW:
                 token.tokenType = VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV;
+                token.indexTypeCount = ARRAY_SIZE(vk_index_types);
+                token.pIndexTypeValues = d3d_index_types;
+                token.pIndexTypes = vk_index_types;
 
                 /* If device exposes 4 byte alignment of the indirect command buffer, it implies we can
                  * pack VA at sub-scalar alignment. Probably not completely within spec, but hey ... */
@@ -12997,6 +13001,7 @@ static HRESULT d3d12_command_signature_init_state_template(struct d3d12_command_
         required_stride_alignment = max(required_stride_alignment, required_alignment);
     }
 
+    stream_stride = max(stream_stride, desc->ByteStride);
     stream_stride = align(stream_stride, required_stride_alignment);
 
     if (FAILED(hr = d3d12_command_signature_init_patch_commands_buffer(signature, device, patch_commands, patch_commands_count)))
diff --git a/libs/vkd3d/shaders/cs_execute_indirect_patch.comp b/libs/vkd3d/shaders/cs_execute_indirect_patch.comp
index c2522910..46455009 100644
--- a/libs/vkd3d/shaders/cs_execute_indirect_patch.comp
+++ b/libs/vkd3d/shaders/cs_execute_indirect_patch.comp
@@ -11,11 +11,6 @@ struct Command
 	uint dst_offset;
 };
 
-const int COMMAND_TYPE_COPY_INDEX_TYPE = 4;
-const int DXGI_FORMAT_R32_UINT = 0x2a;
-const int VK_INDEX_TYPE_UINT16 = 0;
-const int VK_INDEX_TYPE_UINT32 = 1;
-
 layout(buffer_reference, std430, buffer_reference_align = 4) readonly buffer Commands
 {
 	Command commands[];
@@ -66,11 +61,7 @@ void main()
 	{
 		uint src_offset = src_stride * draw_id + cmd.src_offset;
 		uint dst_offset = dst_stride * draw_id + cmd.dst_offset;
-
 		uint src_value = src_buffer_va.values[src_offset];
-		if (cmd.type == COMMAND_TYPE_COPY_INDEX_TYPE)
-			src_value = src_value == DXGI_FORMAT_R32_UINT ? VK_INDEX_TYPE_UINT32 : VK_INDEX_TYPE_UINT16;
-
 		dst_buffer_va.values[dst_offset] = src_value;
 	}
 }
diff --git a/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp b/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp
index 6a63a445..33e245a6 100644
--- a/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp
+++ b/libs/vkd3d/shaders/cs_execute_indirect_patch_debug_ring.comp
@@ -13,11 +13,6 @@ struct Command
 	uint dst_offset;
 };
 
-const int COMMAND_TYPE_COPY_INDEX_TYPE = 4;
-const int DXGI_FORMAT_R32_UINT = 0x2a;
-const int VK_INDEX_TYPE_UINT16 = 0;
-const int VK_INDEX_TYPE_UINT32 = 1;
-
 layout(buffer_reference, std430, buffer_reference_align = 4) readonly buffer Commands
 {
 	Command commands[];
@@ -79,8 +74,6 @@ void main()
         uint dst_offset = dst_stride * draw_id + cmd.dst_offset;
 
         uint src_value = src_buffer_va.values[src_offset];
-        if (cmd.type == COMMAND_TYPE_COPY_INDEX_TYPE)
-            src_value = src_value == DXGI_FORMAT_R32_UINT ? VK_INDEX_TYPE_UINT32 : VK_INDEX_TYPE_UINT16;
 
         if (debug_tag != 0u)
             DEBUG_CHANNEL_MSG(cmd.type, dst_offset, src_offset, src_value);
-- 
2.36.1

From ce5df40f01280af70bde2ff94468741dac7eea85 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Mon, 13 Jun 2022 14:19:56 +0200
Subject: [PATCH 38/42] vkd3d-shader: Workaround trivial compiler warning.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d-shader/spirv.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libs/vkd3d-shader/spirv.c b/libs/vkd3d-shader/spirv.c
index 7051e3f8..1bbb7eb2 100644
--- a/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d-shader/spirv.c
@@ -9391,9 +9391,9 @@ static void vkd3d_dxbc_compiler_emit_gather4(struct vkd3d_dxbc_compiler *compile
     unsigned int image_flags = VKD3D_IMAGE_FLAG_SAMPLED;
     SpvImageOperandsMask operands_mask = 0;
     unsigned int image_operand_count = 0;
+    uint32_t image_operands[1] = { 0 };
     struct vkd3d_shader_image image;
     unsigned int component_idx;
-    uint32_t image_operands[1];
     DWORD coordinate_mask;
     bool extended_offset;
     bool is_sparse_op;
-- 
2.36.1

From 010db2bb7ba1e853a304bdb7d4c017129ed8a526 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Mon, 13 Jun 2022 14:20:49 +0200
Subject: [PATCH 39/42] tests: Fix compiler warnings in various tests.

Mostly related to casting vec4 struct to float where array[4] is expected.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 tests/d3d12_clear.c         |  6 +++---
 tests/d3d12_copy.c          |  2 +-
 tests/d3d12_raytracing.c    |  2 +-
 tests/d3d12_render_target.c | 13 +++++++------
 tests/d3d12_shaders.c       | 24 ++++++++++++------------
 tests/d3d12_sm_advanced.c   |  8 ++++----
 6 files changed, 28 insertions(+), 27 deletions(-)

diff --git a/tests/d3d12_copy.c b/tests/d3d12_copy.c
index e3951786..1370d2a5 100644
--- a/tests/d3d12_copy.c
+++ b/tests/d3d12_copy.c
@@ -554,9 +554,9 @@ void test_copy_texture_buffer(void)
 
 void test_copy_buffer_to_depth_stencil(void)
 {
+    ID3D12Resource *src_buffer_stencil = NULL;
     ID3D12GraphicsCommandList *command_list;
     struct resource_readback rb_stencil;
-    ID3D12Resource *src_buffer_stencil;
     struct resource_readback rb_depth;
     ID3D12Resource *src_buffer_depth;
     struct test_context_desc desc;
diff --git a/tests/d3d12_raytracing.c b/tests/d3d12_raytracing.c
index c3ef98a5..d596608c 100644
--- a/tests/d3d12_raytracing.c
+++ b/tests/d3d12_raytracing.c
@@ -1509,7 +1509,7 @@ static void test_raytracing_pipeline(enum rt_test_mode mode, D3D12_RAYTRACING_TI
 #define INSTANCE_GEOM_SCALE (0.5f)
 
     D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC postbuild_desc[3];
-    float sbt_colors[NUM_GEOM_DESC * NUM_UNMASKED_INSTANCES + 1][2];
+    float sbt_colors[NUM_GEOM_DESC * NUM_UNMASKED_INSTANCES + 1][2] = {{0}};
     D3D12_ROOT_SIGNATURE_DESC root_signature_desc;
     D3D12_DESCRIPTOR_RANGE descriptor_ranges[2];
     ID3D12GraphicsCommandList4 *command_list4;
diff --git a/tests/d3d12_render_target.c b/tests/d3d12_render_target.c
index af2723bd..d2e3a823 100644
--- a/tests/d3d12_render_target.c
+++ b/tests/d3d12_render_target.c
@@ -24,8 +24,8 @@
 
 void test_unbound_rtv_rendering(void)
 {
-    static const struct vec4 white = { 1.0f, 1.0f, 1.0f, 1.0f };
     static const struct vec4 red = { 1.0f, 0.0f, 0.0f, 1.0f };
+    static const float white[] = { 1.0f, 1.0f, 1.0f, 1.0f };
     D3D12_GRAPHICS_PIPELINE_STATE_DESC pso_desc;
     ID3D12GraphicsCommandList *command_list;
     D3D12_CPU_DESCRIPTOR_HANDLE rt_handle;
@@ -91,8 +91,8 @@ void test_unbound_rtv_rendering(void)
             &IID_ID3D12PipelineState, (void **)&context.pipeline_state);
     ok(hr == S_OK, "Failed to create state, hr %#x.\n", hr);
 
-    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, &white.x, 0, NULL);
-    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, rt_handle, &white.x, 0, NULL);
+    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, white, 0, NULL);
+    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, rt_handle, white, 0, NULL);
     ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, context.root_signature);
     ID3D12GraphicsCommandList_SetPipelineState(command_list, context.pipeline_state);
     ID3D12GraphicsCommandList_IASetPrimitiveTopology(command_list, D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
@@ -120,7 +120,8 @@ void test_unbound_rtv_rendering(void)
 
 void test_unknown_rtv_format(void)
 {
-    static const struct vec4 white = {1.0f, 1.0f, 1.0f, 1.0f};
+    static const struct vec4 vec4_white = {1.0f, 1.0f, 1.0f, 1.0f};
+    static const float white[] = {1.0f, 1.0f, 1.0f, 1.0f};
     struct vec4 expected_vec4 = {0.0f, 0.0f, 0.0f, 1.0f};
     D3D12_GRAPHICS_PIPELINE_STATE_DESC pso_desc;
     ID3D12GraphicsCommandList *command_list;
@@ -185,7 +186,7 @@ void test_unknown_rtv_format(void)
     create_render_target(&context, &desc, &render_targets[1], &rtvs[2]);
 
     for (i = 0; i < ARRAY_SIZE(rtvs); ++i)
-        ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, rtvs[i], &white.x, 0, NULL);
+        ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, rtvs[i], white, 0, NULL);
 
     /* NULL RTV */
     memset(&rtv_desc, 0, sizeof(rtv_desc));
@@ -212,7 +213,7 @@ void test_unknown_rtv_format(void)
     transition_resource_state(command_list, render_targets[1],
             D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_COPY_SOURCE);
 
-    check_sub_resource_vec4(context.render_target, 0, queue, command_list, &white, 0);
+    check_sub_resource_vec4(context.render_target, 0, queue, command_list, &vec4_white, 0);
     reset_command_list(command_list, context.allocator);
     expected_vec4.x = 2.0f;
     check_sub_resource_vec4(render_targets[0], 0, queue, command_list, &expected_vec4, 0);
diff --git a/tests/d3d12_shaders.c b/tests/d3d12_shaders.c
index 5a7ffbf2..15a3e86b 100644
--- a/tests/d3d12_shaders.c
+++ b/tests/d3d12_shaders.c
@@ -5134,7 +5134,7 @@ void test_gather(void)
         {0.3f, 1.3f, 1.2f, 0.2f}, {1.3f, 2.3f, 2.2f, 1.2f}, {2.3f, 3.3f, 3.2f, 2.2f}, {3.3f, 3.3f, 3.2f, 3.2f},
         {0.3f, 1.3f, 1.3f, 0.3f}, {1.3f, 2.3f, 2.3f, 1.3f}, {2.3f, 3.3f, 3.3f, 2.3f}, {3.3f, 3.3f, 3.3f, 3.3f},
     };
-    static const struct vec4 white = {1.0f, 1.0f, 1.0f, 1.0f};
+    static const float white[] = {1.0f, 1.0f, 1.0f, 1.0f};
     static const D3D12_SUBRESOURCE_DATA resource_data = {&texture_data, sizeof(texture_data) / 4};
 
     memset(&desc, 0, sizeof(desc));
@@ -5171,7 +5171,7 @@ void test_gather(void)
     context.pipeline_state = create_pipeline_state(context.device,
             context.root_signature, desc.rt_format, NULL, &ps_gather4, NULL);
 
-    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, &white.x, 0, NULL);
+    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, white, 0, NULL);
 
     ID3D12GraphicsCommandList_OMSetRenderTargets(command_list, 1, &context.rtv, false, NULL);
     ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, context.root_signature);
@@ -5209,7 +5209,7 @@ void test_gather(void)
     context.pipeline_state = create_pipeline_state(context.device,
             context.root_signature, desc.rt_format, NULL, &ps_gather4_offset, NULL);
 
-    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, &white.x, 0, NULL);
+    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, white, 0, NULL);
 
     ID3D12GraphicsCommandList_OMSetRenderTargets(command_list, 1, &context.rtv, false, NULL);
     ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, context.root_signature);
@@ -5247,7 +5247,7 @@ void test_gather(void)
     context.pipeline_state = create_pipeline_state(context.device,
             context.root_signature, desc.rt_format, NULL, &ps_gather4_green, NULL);
 
-    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, &white.x, 0, NULL);
+    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, white, 0, NULL);
 
     ID3D12GraphicsCommandList_OMSetRenderTargets(command_list, 1, &context.rtv, false, NULL);
     ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, context.root_signature);
@@ -5285,7 +5285,7 @@ void test_gather(void)
     context.pipeline_state = create_pipeline_state(context.device,
             context.root_signature, desc.rt_format, NULL, &ps_gather4_po, NULL);
 
-    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, &white.x, 0, NULL);
+    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, white, 0, NULL);
 
     ID3D12GraphicsCommandList_OMSetRenderTargets(command_list, 1, &context.rtv, false, NULL);
     ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, context.root_signature);
@@ -5321,7 +5321,7 @@ void test_gather(void)
     constants.offset_x = 0;
     constants.offset_y = 0;
 
-    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, &white.x, 0, NULL);
+    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, white, 0, NULL);
 
     ID3D12GraphicsCommandList_OMSetRenderTargets(command_list, 1, &context.rtv, false, NULL);
     ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, context.root_signature);
@@ -5455,7 +5455,7 @@ void test_gather_c(void)
         {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 1.0f, 1.0f, 0.0f}, {1.0f, 1.0f, 1.0f, 1.0f}, {1.0f, 1.0f, 1.0f, 1.0f},
         {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 1.0f, 1.0f, 0.0f}, {1.0f, 1.0f, 1.0f, 1.0f}, {1.0f, 1.0f, 1.0f, 1.0f},
     };
-    static const struct vec4 white = {1.0f, 1.0f, 1.0f, 1.0f};
+    static const float white[] = {1.0f, 1.0f, 1.0f, 1.0f};
     static const D3D12_SUBRESOURCE_DATA resource_data = {&texture_data, sizeof(texture_data) / 4};
     static const D3D12_STATIC_SAMPLER_DESC sampler_desc =
     {
@@ -5511,7 +5511,7 @@ void test_gather_c(void)
     context.pipeline_state = create_pipeline_state(context.device,
             context.root_signature, desc.rt_format, NULL, &ps_gather4_c, NULL);
 
-    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, &white.x, 0, NULL);
+    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, white, 0, NULL);
 
     ID3D12GraphicsCommandList_OMSetRenderTargets(command_list, 1, &context.rtv, false, NULL);
     ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, context.root_signature);
@@ -5549,7 +5549,7 @@ void test_gather_c(void)
     context.pipeline_state = create_pipeline_state(context.device,
             context.root_signature, desc.rt_format, NULL, &ps_gather4_po_c, NULL);
 
-    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, &white.x, 0, NULL);
+    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, white, 0, NULL);
 
     ID3D12GraphicsCommandList_OMSetRenderTargets(command_list, 1, &context.rtv, false, NULL);
     ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, context.root_signature);
@@ -5585,7 +5585,7 @@ void test_gather_c(void)
     constants.offset_x = 0;
     constants.offset_y = 0;
 
-    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, &white.x, 0, NULL);
+    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, white, 0, NULL);
 
     ID3D12GraphicsCommandList_OMSetRenderTargets(command_list, 1, &context.rtv, false, NULL);
     ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, context.root_signature);
@@ -6281,7 +6281,7 @@ void test_multisample_array_texture(void)
     };
     static const D3D12_SHADER_BYTECODE ps = {ps_code, sizeof(ps_code)};
     static const float white[] = {1.0f, 1.0f, 1.0f, 1.0f};
-    static const struct vec4 colors[] =
+    static const float colors[][4] =
     {
         {1.0f, 0.0f, 0.0f, 1.0f},
         {0.0f, 1.0f, 0.0f, 1.0f},
@@ -6387,7 +6387,7 @@ void test_multisample_array_texture(void)
         rtv_desc.Texture2DMSArray.ArraySize = 1;
         ID3D12Device_CreateRenderTargetView(device, texture, &rtv_desc, cpu_handle);
 
-        ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, cpu_handle, &colors[i].x, 0, NULL);
+        ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, cpu_handle, colors[i], 0, NULL);
     }
 
     transition_resource_state(command_list, texture,
diff --git a/tests/d3d12_sm_advanced.c b/tests/d3d12_sm_advanced.c
index 061f5c53..4a1a18a3 100644
--- a/tests/d3d12_sm_advanced.c
+++ b/tests/d3d12_sm_advanced.c
@@ -2131,8 +2131,8 @@ void test_sv_barycentric(void)
 #define BARY_RES 128
 
     static const D3D12_VIEWPORT vp = { 0, 0, BARY_RES, BARY_RES, 0, 1 };
-    static const float white[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
     static const D3D12_RECT sci = { 0, 0, BARY_RES, BARY_RES };
+    static const float white[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
     static const uint8_t provoking_lut[] = {
         192, 212, 224, 244,
         128, 144, 160, 176,
@@ -4834,7 +4834,7 @@ void test_shader_sm66_is_helper_lane(void)
 {
     /* Oh, hi there. */
     static const float alpha_keys[4] = { 0.75f, 2.25f, 3.25f, 3.75f };
-    static const struct vec4 white = { 1.0f, 1.0f, 1.0f, 1.0f };
+    static const float white[] = { 1.0f, 1.0f, 1.0f, 1.0f };
     D3D12_FEATURE_DATA_SHADER_MODEL shader_model;
     D3D12_GRAPHICS_PIPELINE_STATE_DESC pso_desc;
     D3D12_UNORDERED_ACCESS_VIEW_DESC uav_desc;
@@ -5041,7 +5041,7 @@ void test_shader_sm66_is_helper_lane(void)
     ID3D12Device_CreateUnorderedAccessView(context.device, atomic_buffer, NULL, &uav_desc, cpu_handle);
 
     ID3D12GraphicsCommandList_SetDescriptorHeaps(command_list, 1, &heap);
-    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, &white.x, 0, NULL);
+    ID3D12GraphicsCommandList_ClearRenderTargetView(command_list, context.rtv, white, 0, NULL);
     ID3D12GraphicsCommandList_OMSetRenderTargets(command_list, 1, &context.rtv, false, NULL);
     ID3D12GraphicsCommandList_SetGraphicsRootSignature(command_list, context.root_signature);
     ID3D12GraphicsCommandList_SetPipelineState(command_list, context.pipeline_state);
@@ -5088,7 +5088,7 @@ void test_shader_sm66_is_helper_lane(void)
                 expected.w = 8881.0f;
             }
             else
-                expected = white;
+                memcpy(&expected, white, sizeof(white));
 
             ok(compare_vec4(value, &expected, 0), "Mismatch pixel %u, %u, (%f %f %f %f) != (%f %f %f %f).\n",
                     x, y, expected.x, expected.y, expected.z, expected.w,
-- 
2.36.1

From c3036fa85c6e2cd35e0f1f436bb72e492ced0169 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Tue, 14 Jun 2022 11:48:33 +0200
Subject: [PATCH 40/42] vkd3d: Demote patching logs to TRACE.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 libs/vkd3d/command.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 36b3e201..2be09ce7 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -9677,9 +9677,9 @@ static void d3d12_command_list_execute_indirect_state_template(
     }
 
     if (require_patch)
-        INFO("Template requires patching :(\n");
+        TRACE("Template requires patching :(\n");
     else
-        INFO("Template skips patching :)\n");
+        TRACE("Template skips patching :)\n");
 
     VK_CALL(vkCmdExecuteGeneratedCommandsNV(list->vk_command_buffer, VK_FALSE, &generated));
 
-- 
2.36.1

From c0856f3702a106c0023bbc2b3fa3d7d62be8a1a8 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Tue, 14 Jun 2022 12:20:06 +0200
Subject: [PATCH 41/42] idl: Fix const correctness of UpdateTileMappings.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 include/vkd3d_d3d12.idl | 4 ++--
 libs/vkd3d/command.c    | 3 ++-
 2 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/include/vkd3d_d3d12.idl b/include/vkd3d_d3d12.idl
index a63dc32c..5b42a53e 100644
--- a/include/vkd3d_d3d12.idl
+++ b/include/vkd3d_d3d12.idl
@@ -3644,8 +3644,8 @@ interface ID3D12CommandQueue : ID3D12Pageable
             ID3D12Heap *heap,
             UINT range_count,
             const D3D12_TILE_RANGE_FLAGS *range_flags,
-            UINT *heap_range_offsets,
-            UINT *range_tile_counts,
+            const UINT *heap_range_offsets,
+            const UINT *range_tile_counts,
             D3D12_TILE_MAPPING_FLAGS flags);
 
     void CopyTileMappings(ID3D12Resource *dst_resource,
diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 2be09ce7..00f5b3fc 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -10910,7 +10910,8 @@ static unsigned int vkd3d_get_tile_index_from_region(const struct d3d12_sparse_i
 static void STDMETHODCALLTYPE d3d12_command_queue_UpdateTileMappings(ID3D12CommandQueue *iface,
         ID3D12Resource *resource, UINT region_count, const D3D12_TILED_RESOURCE_COORDINATE *region_coords,
         const D3D12_TILE_REGION_SIZE *region_sizes, ID3D12Heap *heap, UINT range_count,
-        const D3D12_TILE_RANGE_FLAGS *range_flags, UINT *heap_range_offsets, UINT *range_tile_counts,
+        const D3D12_TILE_RANGE_FLAGS *range_flags,
+        const UINT *heap_range_offsets, const UINT *range_tile_counts,
         D3D12_TILE_MAPPING_FLAGS flags)
 {
     struct d3d12_command_queue *command_queue = impl_from_ID3D12CommandQueue(iface);
-- 
2.36.1

From 826bb341b576103cc7c8902c3c307280597f0358 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Tue, 14 Jun 2022 12:21:21 +0200
Subject: [PATCH 42/42] tests: Add test for freeing underlying memory of a
 reserved resource.

As long as the reserved regions are not used, this is okay.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 tests/d3d12_sparse.c | 124 +++++++++++++++++++++++++++++++++++++++++++
 tests/d3d12_tests.h  |   1 +
 2 files changed, 125 insertions(+)

diff --git a/tests/d3d12_sparse.c b/tests/d3d12_sparse.c
index 27a9afdf..746e54c5 100644
--- a/tests/d3d12_sparse.c
+++ b/tests/d3d12_sparse.c
@@ -3383,3 +3383,127 @@ void test_texture_feedback_instructions_dxil(void)
     test_texture_feedback_instructions(true);
 }
 
+void test_sparse_buffer_memory_lifetime(void)
+{
+    /* Attempt to bind sparse memory, then free the underlying heap, but keep the sparse resource
+     * alive. This should confuse drivers that attempt to track BO lifetimes. */
+    const D3D12_TILE_RANGE_FLAGS range_flag = D3D12_TILE_RANGE_FLAG_NONE;
+    D3D12_UNORDERED_ACCESS_VIEW_DESC uav_desc;
+    D3D12_FEATURE_DATA_D3D12_OPTIONS options;
+    D3D12_TILE_REGION_SIZE region_size;
+    const UINT ones[] = { 1, 1, 1, 1 };
+    struct test_context context;
+    struct resource_readback rb;
+    ID3D12DescriptorHeap *cpu;
+    ID3D12DescriptorHeap *gpu;
+    D3D12_HEAP_DESC heap_desc;
+    D3D12_RESOURCE_DESC desc;
+    ID3D12Resource *sparse;
+    ID3D12Resource *buffer;
+    ID3D12Heap *heap_live;
+    ID3D12Heap *heap;
+    unsigned int i;
+    HRESULT hr;
+
+    if (!init_compute_test_context(&context))
+        return;
+
+    hr = ID3D12Device_CheckFeatureSupport(context.device, D3D12_FEATURE_D3D12_OPTIONS, &options, sizeof(options));
+    ok(hr == S_OK, "Failed to check feature support, hr %#x.\n", hr);
+
+    if (options.TiledResourcesTier < D3D12_TILED_RESOURCES_TIER_1)
+    {
+        skip("Tiled resources Tier 1 not supported by device.\n");
+        destroy_test_context(&context);
+        return;
+    }
+
+    memset(&heap_desc, 0, sizeof(heap_desc));
+    heap_desc.SizeInBytes = 4 * 1024 * 1024;
+    heap_desc.Properties.Type = D3D12_HEAP_TYPE_DEFAULT;
+    heap_desc.Alignment = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;
+    heap_desc.Flags = D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS;
+    hr = ID3D12Device_CreateHeap(context.device, &heap_desc, &IID_ID3D12Heap, (void**)&heap);
+    ok(SUCCEEDED(hr), "Failed to create heap, hr #%x.\n", hr);
+    hr = ID3D12Device_CreateHeap(context.device, &heap_desc, &IID_ID3D12Heap, (void**)&heap_live);
+    ok(SUCCEEDED(hr), "Failed to create heap, hr #%x.\n", hr);
+
+    memset(&desc, 0, sizeof(desc));
+    desc.Width = 64 * 1024 * 1024;
+    desc.Height = 1;
+    desc.DepthOrArraySize = 1;
+    desc.SampleDesc.Count = 1;
+    desc.Format = DXGI_FORMAT_UNKNOWN;
+    desc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
+    desc.MipLevels = 1;
+    desc.Alignment = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;
+    desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
+    desc.Flags = D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
+    hr = ID3D12Device_CreateReservedResource(context.device, &desc, D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
+            NULL, &IID_ID3D12Resource, (void**)&sparse);
+    ok(SUCCEEDED(hr), "Failed to create reserved resource, hr #%x.\n", hr);
+
+    region_size.UseBox = FALSE;
+    region_size.NumTiles = 1;
+    for (i = 0; i < 2; i++)
+    {
+        const D3D12_TILED_RESOURCE_COORDINATE region_start_coordinate = { i, 0, 0, 0 };
+        const UINT offset = i;
+        const UINT count = 1;
+
+        ID3D12CommandQueue_UpdateTileMappings(context.queue, sparse, 1, &region_start_coordinate, &region_size,
+                i == 0 ? heap : heap_live, 1, &range_flag, &offset, &count, D3D12_TILE_MAPPING_FLAG_NONE);
+    }
+    wait_queue_idle(context.device, context.queue);
+
+    buffer = create_default_buffer(context.device, 128 * 1024,
+            D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COPY_DEST);
+    cpu = create_cpu_descriptor_heap(context.device, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, 1);
+    gpu = create_gpu_descriptor_heap(context.device, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, 1);
+    memset(&uav_desc, 0, sizeof(uav_desc));
+    uav_desc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
+    uav_desc.Format = DXGI_FORMAT_R32_UINT;
+    uav_desc.Buffer.NumElements = 128 * 1024 / 4;
+    uav_desc.Buffer.FirstElement = 0;
+    ID3D12Device_CreateUnorderedAccessView(context.device, sparse, NULL, &uav_desc,
+            ID3D12DescriptorHeap_GetCPUDescriptorHandleForHeapStart(cpu));
+    ID3D12Device_CreateUnorderedAccessView(context.device, sparse, NULL, &uav_desc,
+            ID3D12DescriptorHeap_GetCPUDescriptorHandleForHeapStart(gpu));
+    ID3D12GraphicsCommandList_SetDescriptorHeaps(context.list, 1, &gpu);
+    ID3D12GraphicsCommandList_ClearUnorderedAccessViewUint(context.list,
+            ID3D12DescriptorHeap_GetGPUDescriptorHandleForHeapStart(gpu),
+            ID3D12DescriptorHeap_GetCPUDescriptorHandleForHeapStart(cpu), sparse, ones, 0, NULL);
+    transition_resource_state(context.list, sparse,
+            D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_COPY_SOURCE);
+    ID3D12GraphicsCommandList_CopyBufferRegion(context.list, buffer, 0, sparse, 0, 128 * 1024);
+    transition_resource_state(context.list, buffer,
+            D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_COPY_SOURCE);
+    get_buffer_readback_with_command_list(buffer, DXGI_FORMAT_R32_UINT,
+            &rb, context.queue, context.list);
+    reset_command_list(context.list, context.allocator);
+    ok(get_readback_uint(&rb, 0, 0, 0) == 1, "Got #%x, expected 1.\n", get_readback_uint(&rb, 0, 0, 0));
+    ok(get_readback_uint(&rb, 64 * 1024 / 4, 0, 0) == 1, "Got #%x, expected 1.\n", get_readback_uint(&rb, 64 * 1024 / 4, 0, 0));
+    release_resource_readback(&rb);
+
+    ID3D12Heap_Release(heap);
+
+    /* Access a resource where we can hypothetically access the freed heap memory. */
+    /* On AMD Windows native at least, if we read the freed region, we read garbage, which proves it's not required to unbind explicitly.
+     * We'd read 0 in that case. */
+    ID3D12GraphicsCommandList_CopyBufferRegion(context.list, buffer, 0, sparse, 64 * 1024, 64 * 1024);
+    transition_resource_state(context.list, buffer,
+            D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_COPY_SOURCE);
+    get_buffer_readback_with_command_list(buffer, DXGI_FORMAT_R32_UINT,
+            &rb, context.queue, context.list);
+
+    ok(get_readback_uint(&rb, 64 * 1024 / 4, 0, 0) == 1, "Got #%x, expected 1.\n", get_readback_uint(&rb, 64 * 1024 / 4, 0, 0));
+    release_resource_readback(&rb);
+
+    ID3D12Resource_Release(buffer);
+    ID3D12Resource_Release(sparse);
+    ID3D12DescriptorHeap_Release(cpu);
+    ID3D12DescriptorHeap_Release(gpu);
+    ID3D12Heap_Release(heap_live);
+    destroy_test_context(&context);
+}
+
diff --git a/tests/d3d12_tests.h b/tests/d3d12_tests.h
index 626e7093..d11551a2 100644
--- a/tests/d3d12_tests.h
+++ b/tests/d3d12_tests.h
@@ -308,3 +308,4 @@ decl_test(test_shader_waveop_maximal_convergence);
 decl_test(test_uav_3d_sliced_view);
 decl_test(test_pipeline_no_ps_nonzero_rts);
 decl_test(test_root_descriptor_offset_sign);
+decl_test(test_sparse_buffer_memory_lifetime);
-- 
2.36.1

