From fc7ddaf0da2d118072e09d09d52c9ef3b3d5221e Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 7 Apr 2022 15:42:03 -0400
Subject: [PATCH 1/2] vkd3d: Implement ID3D12Resource sharing.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 libs/vkd3d/device.c          | 125 ++++++++++++++++++++++++++++++++++-
 libs/vkd3d/meson.build       |   1 +
 libs/vkd3d/resource.c        |  44 ++++++++++--
 libs/vkd3d/shared_metadata.c |  50 ++++++++++++++
 libs/vkd3d/swapchain.c       |   2 +-
 libs/vkd3d/vkd3d_private.h   |  50 +++++++++++++-
 libs/vkd3d/vulkan_procs.h    |   6 ++
 7 files changed, 269 insertions(+), 9 deletions(-)
 create mode 100644 libs/vkd3d/shared_metadata.c

diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index d47125432..0eb34440a 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -84,6 +84,7 @@ static const struct vkd3d_optional_extension_info optional_device_extensions[] =
     VK_EXTENSION(KHR_UNIFORM_BUFFER_STANDARD_LAYOUT, KHR_uniform_buffer_standard_layout),
     VK_EXTENSION(KHR_MAINTENANCE_4, KHR_maintenance4),
     VK_EXTENSION(KHR_FRAGMENT_SHADER_BARYCENTRIC, KHR_fragment_shader_barycentric),
+    VK_EXTENSION(KHR_EXTERNAL_MEMORY_WIN32, KHR_external_memory_win32),
     /* EXT extensions */
     VK_EXTENSION(EXT_CALIBRATED_TIMESTAMPS, EXT_calibrated_timestamps),
     VK_EXTENSION(EXT_CONDITIONAL_RENDERING, EXT_conditional_rendering),
@@ -4311,18 +4312,136 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateSharedHandle(d3d12_device_if
         ID3D12DeviceChild *object, const SECURITY_ATTRIBUTES *attributes, DWORD access,
         const WCHAR *name, HANDLE *handle)
 {
-    FIXME("iface %p, object %p, attributes %p, access %#x, name %s, handle %p stub!\n",
+    struct d3d12_device *device = impl_from_ID3D12Device(iface);
+    const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
+    ID3D12Resource *resource_iface;
+
+    TRACE("iface %p, object %p, attributes %p, access %#x, name %s, handle %p\n",
             iface, object, attributes, access, debugstr_w(name), handle);
 
+    if (SUCCEEDED(ID3D12DeviceChild_QueryInterface(object, &IID_ID3D12Resource, (void**)&resource_iface)))
+    {
+        struct d3d12_resource *resource = impl_from_ID3D12Resource(resource_iface);
+        VkMemoryGetWin32HandleInfoKHR win32_handle_info;
+        VkResult vr;
+
+        if (!(resource->heap_flags & D3D12_HEAP_FLAG_SHARED))
+        {
+            ID3D12Resource_Release(resource_iface);
+            return DXGI_ERROR_INVALID_CALL;
+        }
+
+        if (attributes)
+            FIXME("attributes %p not handled\n", attributes);
+        if (access)
+            FIXME("access %#x not handled\n", access);
+        if (name)
+            FIXME("name %s not handled\n", debugstr_w(name));
+
+        win32_handle_info.sType = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR;
+        win32_handle_info.pNext = NULL;
+        win32_handle_info.memory = resource->mem.device_allocation.vk_memory;
+        win32_handle_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+
+        vr = VK_CALL(vkGetMemoryWin32HandleKHR(device->vk_device, &win32_handle_info, handle));
+
+        ID3D12Resource_Release(resource_iface);
+        return vr ? E_FAIL : S_OK;
+    }
+
+    FIXME("Creating shared handle for type of object %p unsupported\n", object);
     return E_NOTIMPL;
 }
 
+static inline bool handle_is_kmt_style(HANDLE handle)
+{
+    return (ULONG_PTR)handle & 0x40000000 && ((ULONG_PTR)handle - 2) % 4 == 0;
+}
+
 static HRESULT STDMETHODCALLTYPE d3d12_device_OpenSharedHandle(d3d12_device_iface *iface,
         HANDLE handle, REFIID riid, void **object)
 {
-    FIXME("iface %p, handle %p, riid %s, object %p stub!\n",
+    struct d3d12_device *device = impl_from_ID3D12Device(iface);
+    HRESULT hr;
+
+    TRACE("iface %p, handle %p, riid %s, object %p\n",
             iface, handle, debugstr_guid(riid), object);
 
+    if (IsEqualGUID(riid, &IID_ID3D12Resource))
+    {
+        struct DxvkSharedTextureMetadata metadata;
+        D3D12_RESOURCE_DESC1 desc;
+        D3D12_HEAP_PROPERTIES heap_props;
+        struct d3d12_resource *resource;
+        bool kmt_handle = false;
+
+        if (handle_is_kmt_style(handle))
+        {
+            handle = vkd3d_open_kmt_handle(handle);
+            kmt_handle = true;
+
+            if (handle == INVALID_HANDLE_VALUE)
+            {
+                WARN("Failed to open KMT-style ID3D12Resource shared handle.\n");
+                *object = NULL;
+                return E_INVALIDARG;
+            }
+        }
+
+        if (!vkd3d_get_shared_metadata(handle, &metadata, sizeof(metadata), NULL))
+        {
+            WARN("Failed to get ID3D12Resource shared handle metadata.\n");
+            if (kmt_handle)
+                CloseHandle(handle);
+
+            *object = NULL;
+            return E_INVALIDARG;
+        }
+
+        desc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
+        desc.Alignment = 0;
+        desc.Width = metadata.Width;
+        desc.Height = metadata.Height;
+        desc.DepthOrArraySize = metadata.ArraySize;
+        desc.MipLevels = metadata.MipLevels;
+        desc.Format = metadata.Format;
+        desc.SampleDesc = metadata.SampleDesc;
+        switch (metadata.TextureLayout)
+        {
+            case D3D11_TEXTURE_LAYOUT_UNDEFINED: desc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN; break;
+            case D3D11_TEXTURE_LAYOUT_ROW_MAJOR: desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR; break;
+            case D3D11_TEXTURE_LAYOUT_64K_STANDARD_SWIZZLE: desc.Layout = D3D12_TEXTURE_LAYOUT_64KB_STANDARD_SWIZZLE; break;
+            default: desc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
+        }
+        desc.Flags = D3D12_RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS;
+        if (metadata.BindFlags & D3D11_BIND_RENDER_TARGET)
+            desc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
+        desc.SamplerFeedbackMipRegion.Width = 0;
+        desc.SamplerFeedbackMipRegion.Height = 0;
+        desc.SamplerFeedbackMipRegion.Depth = 0;
+
+        heap_props.Type = D3D12_HEAP_TYPE_DEFAULT;
+        heap_props.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
+        heap_props.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
+        heap_props.CreationNodeMask = 0;
+        heap_props.VisibleNodeMask = 0;
+
+        hr = d3d12_resource_create_committed(device, &desc, &heap_props,
+                D3D12_HEAP_FLAG_SHARED, D3D12_RESOURCE_STATE_COMMON, NULL, handle, &resource);
+        if (kmt_handle)
+            CloseHandle(handle);
+
+        if (FAILED(hr))
+        {
+            WARN("Failed to open shared ID3D12Resource, hr %#x.\n", hr);
+            *object = NULL;
+            return hr;
+        }
+
+        return return_interface(&resource->ID3D12Resource_iface, &IID_ID3D12Resource, riid, object);
+    }
+
+    FIXME("Opening shared handle type %s unsupported\n", debugstr_guid(riid));
     return E_NOTIMPL;
 }
 
@@ -5049,7 +5168,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommittedResource2(d3d12_dev
         FIXME("Ignoring protected session %p.\n", protected_session);
 
     if (FAILED(hr = d3d12_resource_create_committed(device, desc, heap_properties,
-            heap_flags, initial_state, optimized_clear_value, &object)))
+            heap_flags, initial_state, optimized_clear_value, NULL, &object)))
     {
         *resource = NULL;
         return hr;
diff --git a/libs/vkd3d/meson.build b/libs/vkd3d/meson.build
index 4038c7ffb..3bfd8f1ae 100644
--- a/libs/vkd3d/meson.build
+++ b/libs/vkd3d/meson.build
@@ -41,6 +41,7 @@ vkd3d_src = [
   'meta.c',
   'platform.c',
   'resource.c',
+  'shared_metadata.c',
   'state.c',
   'utils.c',
   'debug_ring.c',
diff --git a/libs/vkd3d/resource.c b/libs/vkd3d/resource.c
index e8145755a..f6e4da0b5 100644
--- a/libs/vkd3d/resource.c
+++ b/libs/vkd3d/resource.c
@@ -502,6 +502,7 @@ static HRESULT vkd3d_get_image_create_info(struct d3d12_device *device,
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
     VkImageCreateInfo *image_info = &create_info->image_info;
     const bool sparse_resource = !heap_properties;
+    VkExternalMemoryImageCreateInfo external_info;
     const struct vkd3d_format *format;
     bool use_concurrent;
     unsigned int i;
@@ -522,12 +523,22 @@ static HRESULT vkd3d_get_image_create_info(struct d3d12_device *device,
     image_info->sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
     image_info->pNext = NULL;
     image_info->flags = 0;
+
+    if (resource && resource->heap_flags & D3D12_HEAP_FLAG_SHARED)
+    {
+        external_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
+        external_info.pNext = image_info->pNext;
+        external_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+
+        image_info->pNext = &external_info;
+    }
+
     if (!(desc->Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL))
     {
         if (vkd3d_get_format_compatibility_list(device, desc, compat_list))
         {
             format_list->sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR;
-            format_list->pNext = NULL;
+            format_list->pNext = image_info->pNext;
             format_list->viewFormatCount = compat_list->format_count;
             format_list->pViewFormats = compat_list->vk_formats;

@@ -2679,7 +2690,7 @@ static HRESULT d3d12_resource_create(struct d3d12_device *device, uint32_t flags
 
 HRESULT d3d12_resource_create_committed(struct d3d12_device *device, const D3D12_RESOURCE_DESC1 *desc,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags, D3D12_RESOURCE_STATES initial_state,
-        const D3D12_CLEAR_VALUE *optimized_clear_value, struct d3d12_resource **resource)
+        const D3D12_CLEAR_VALUE *optimized_clear_value, HANDLE shared_handle, struct d3d12_resource **resource)
 {
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
     struct d3d12_resource *object;
@@ -2693,9 +2704,12 @@ HRESULT d3d12_resource_create_committed(struct d3d12_device *device, const D3D12
     {
         VkMemoryDedicatedRequirements dedicated_requirements;
         struct vkd3d_allocate_memory_info allocate_info;
+        VkExternalMemoryImageCreateInfo external_info;
+        VkImportMemoryWin32HandleInfoKHR import_info;
         VkMemoryDedicatedAllocateInfo dedicated_info;
         VkImageMemoryRequirementsInfo2 image_info;
         VkMemoryRequirements2 memory_requirements;
+        VkExportMemoryAllocateInfo export_info;
         VkBindImageMemoryInfo bind_info;
         bool use_dedicated_allocation;
         VkResult vr;
@@ -2732,10 +2746,32 @@ HRESULT d3d12_resource_create_committed(struct d3d12_device *device, const D3D12
         else
             allocate_info.heap_flags |= D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES;
 
+        if (heap_flags & D3D12_HEAP_FLAG_SHARED)
+        {
+            use_dedicated_allocation = true;
+
+            if (shared_handle && shared_handle != INVALID_HANDLE_VALUE)
+            {
+                import_info.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
+                import_info.pNext = allocate_info.pNext;
+                import_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+                import_info.handle = shared_handle;
+                import_info.name = NULL;
+                allocate_info.pNext = &import_info;
+            }
+            else
+            {
+                export_info.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
+                export_info.pNext = allocate_info.pNext;
+                export_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+                allocate_info.pNext = &export_info;
+            }
+        }
+
         if (use_dedicated_allocation)
         {
             dedicated_info.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
-            dedicated_info.pNext = NULL;
+            dedicated_info.pNext = allocate_info.pNext;
             dedicated_info.image = object->res.vk_image;
             dedicated_info.buffer = VK_NULL_HANDLE;
             allocate_info.pNext = &dedicated_info;
@@ -2846,7 +2882,7 @@ HRESULT d3d12_resource_create_placed(struct d3d12_device *device, const D3D12_RE
                 heap->desc.Flags & ~(D3D12_HEAP_FLAG_DENY_BUFFERS |
                         D3D12_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES |
                         D3D12_HEAP_FLAG_DENY_RT_DS_TEXTURES),
-                initial_state, optimized_clear_value, resource)))
+                initial_state, optimized_clear_value, NULL, resource)))
         {
             ERR("Failed to create fallback committed resource.\n");
         }
diff --git a/libs/vkd3d/shared_metadata.c b/libs/vkd3d/shared_metadata.c
new file mode 100644
index 000000000..5082b92ce
--- /dev/null
+++ b/libs/vkd3d/shared_metadata.c
@@ -0,0 +1,50 @@
+#define VKD3D_DBG_CHANNEL VKD3D_DBG_CHANNEL_API
+#include "vkd3d_private.h"
+
+#include "winioctl.h"
+
+#define IOCTL_SHARED_GPU_RESOURCE_SET_METADATA           CTL_CODE(FILE_DEVICE_VIDEO, 4, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+#define IOCTL_SHARED_GPU_RESOURCE_GET_METADATA           CTL_CODE(FILE_DEVICE_VIDEO, 5, METHOD_BUFFERED, FILE_READ_ACCESS)
+#define IOCTL_SHARED_GPU_RESOURCE_OPEN                   CTL_CODE(FILE_DEVICE_VIDEO, 1, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+bool vkd3d_set_shared_metadata(HANDLE handle, void *buf, uint32_t buf_size)
+{
+    DWORD ret_size;
+
+    return DeviceIoControl(handle, IOCTL_SHARED_GPU_RESOURCE_SET_METADATA, buf, buf_size, NULL, 0, &ret_size, NULL);
+}
+
+bool vkd3d_get_shared_metadata(HANDLE handle, void *buf, uint32_t buf_size, uint32_t *metadata_size)
+{
+    DWORD ret_size;
+
+    bool ret = DeviceIoControl(handle, IOCTL_SHARED_GPU_RESOURCE_GET_METADATA, NULL, 0, buf, buf_size, &ret_size, NULL);
+
+    if (metadata_size)
+        *metadata_size = ret_size;
+
+    return ret;
+}
+
+HANDLE vkd3d_open_kmt_handle(HANDLE kmt_handle)
+{
+    struct
+    {
+        unsigned int kmt_handle;
+        /* the following parameter represents a larger sized string for a dynamically allocated struct for use when opening an object by name */
+        WCHAR name[1];
+    } shared_resource_open;
+
+    HANDLE nt_handle = CreateFileA("\\\\.\\SharedGpuResource", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (nt_handle == INVALID_HANDLE_VALUE)
+        return nt_handle;
+
+    shared_resource_open.kmt_handle = (ULONG_PTR)kmt_handle;
+    shared_resource_open.name[0] = 0;
+    if (!DeviceIoControl(nt_handle, IOCTL_SHARED_GPU_RESOURCE_OPEN, &shared_resource_open, sizeof(shared_resource_open), NULL, 0, NULL, NULL))
+    {
+        CloseHandle(nt_handle);
+        return INVALID_HANDLE_VALUE;
+    }
+    return nt_handle;
+}
diff --git a/libs/vkd3d/swapchain.c b/libs/vkd3d/swapchain.c
index 47ec8a0a6..5c6105dd7 100644
--- a/libs/vkd3d/swapchain.c
+++ b/libs/vkd3d/swapchain.c
@@ -955,7 +955,7 @@ static HRESULT d3d12_swapchain_create_user_buffers(struct d3d12_swapchain *swapc
         {
             if (FAILED(hr = d3d12_resource_create_committed(d3d12_swapchain_device(swapchain),
                     &resource_desc, &heap_properties, D3D12_HEAP_FLAG_NONE,
-                    D3D12_RESOURCE_STATE_PRESENT, NULL, &object)))
+                    D3D12_RESOURCE_STATE_PRESENT, NULL, NULL, &object)))
             {
                 ERR("Failed to create image for swapchain buffer");
                 return hr;
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index 903ff8ec6..e81e75b90 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -132,6 +132,7 @@ struct vkd3d_vulkan_info
     bool KHR_maintenance4;
     bool KHR_ray_tracing_maintenance1;
     bool KHR_fragment_shader_barycentric;
+    bool KHR_external_memory_win32;
     /* EXT device extensions */
     bool EXT_calibrated_timestamps;
     bool EXT_conditional_rendering;
@@ -895,7 +896,7 @@ VkImageSubresource vk_image_subresource_from_d3d12(
 
 HRESULT d3d12_resource_create_committed(struct d3d12_device *device, const D3D12_RESOURCE_DESC1 *desc,
         const D3D12_HEAP_PROPERTIES *heap_properties, D3D12_HEAP_FLAGS heap_flags, D3D12_RESOURCE_STATES initial_state,
-        const D3D12_CLEAR_VALUE *optimized_clear_value, struct d3d12_resource **resource);
+        const D3D12_CLEAR_VALUE *optimized_clear_value, HANDLE shared_handle, struct d3d12_resource **resource);
 HRESULT d3d12_resource_create_placed(struct d3d12_device *device, const D3D12_RESOURCE_DESC1 *desc,
         struct d3d12_heap *heap, uint64_t heap_offset, D3D12_RESOURCE_STATES initial_state,
         const D3D12_CLEAR_VALUE *optimized_clear_value, struct d3d12_resource **resource);
@@ -3693,6 +3694,53 @@ void vkd3d_acceleration_structure_copy(
         D3D12_GPU_VIRTUAL_ADDRESS dst, D3D12_GPU_VIRTUAL_ADDRESS src,
         D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE mode);
 
+typedef enum D3D11_USAGE
+{
+    D3D11_USAGE_DEFAULT,
+    D3D11_USAGE_IMMUTABLE,
+    D3D11_USAGE_DYNAMIC,
+    D3D11_USAGE_STAGING,
+} D3D11_USAGE;
+
+typedef enum D3D11_BIND_FLAG
+{
+    D3D11_BIND_VERTEX_BUFFER    = 0x0001,
+    D3D11_BIND_INDEX_BUFFER     = 0x0002,
+    D3D11_BIND_CONSTANT_BUFFER  = 0x0004,
+    D3D11_BIND_SHADER_RESOURCE  = 0x0008,
+    D3D11_BIND_STREAM_OUTPUT    = 0x0010,
+    D3D11_BIND_RENDER_TARGET    = 0x0020,
+    D3D11_BIND_DEPTH_STENCIL    = 0x0040,
+    D3D11_BIND_UNORDERED_ACCESS = 0x0080,
+    D3D11_BIND_DECODER          = 0x0200,
+    D3D11_BIND_VIDEO_ENCODER    = 0x0400
+} D3D11_BIND_FLAG;
+
+typedef enum D3D11_TEXTURE_LAYOUT
+{
+    D3D11_TEXTURE_LAYOUT_UNDEFINED = 0x0,
+    D3D11_TEXTURE_LAYOUT_ROW_MAJOR = 0x1,
+    D3D11_TEXTURE_LAYOUT_64K_STANDARD_SWIZZLE = 0x2,
+} D3D11_TEXTURE_LAYOUT;
+
+struct DxvkSharedTextureMetadata {
+    UINT             Width;
+    UINT             Height;
+    UINT             MipLevels;
+    UINT             ArraySize;
+    DXGI_FORMAT      Format;
+    DXGI_SAMPLE_DESC SampleDesc;
+    D3D11_USAGE      Usage;
+    UINT             BindFlags;
+    UINT             CPUAccessFlags;
+    UINT             MiscFlags;
+    D3D11_TEXTURE_LAYOUT TextureLayout;
+};
+
+bool vkd3d_set_shared_metadata(HANDLE handle, void *buf, uint32_t buf_size);
+bool vkd3d_get_shared_metadata(HANDLE handle, void *buf, uint32_t buf_size, uint32_t *metadata_size);
+HANDLE vkd3d_open_kmt_handle(HANDLE kmt_handle);
+
 #define VKD3D_VENDOR_ID_NVIDIA 0x10DE
 #define VKD3D_VENDOR_ID_AMD 0x1002
 #define VKD3D_VENDOR_ID_INTEL 0x8086
diff --git a/libs/vkd3d/vulkan_procs.h b/libs/vkd3d/vulkan_procs.h
index 36e3f4c8e..e65c83029 100644
--- a/libs/vkd3d/vulkan_procs.h
+++ b/libs/vkd3d/vulkan_procs.h
@@ -218,6 +218,12 @@ VK_DEVICE_EXT_PFN(vkCmdCopyImage2KHR)
 VK_DEVICE_EXT_PFN(vkCmdCopyImageToBuffer2KHR)
 VK_DEVICE_EXT_PFN(vkCmdResolveImage2KHR)
 
+#ifdef VK_KHR_external_memory_win32
+/* VK_KHR_external_memory_win32 */
+VK_DEVICE_EXT_PFN(vkGetMemoryWin32HandleKHR)
+VK_DEVICE_EXT_PFN(vkGetMemoryWin32HandlePropertiesKHR)
+#endif
+
 /* VK_EXT_calibrated_timestamps */
 VK_DEVICE_EXT_PFN(vkGetCalibratedTimestampsEXT)
 VK_INSTANCE_EXT_PFN(vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)

From 0978503465d132b622446a35855ea8408250026b Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Mon, 11 Apr 2022 16:53:16 -0400
Subject: [PATCH 2/2] vkd3d: Implement ID3D12Fence sharing.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 libs/vkd3d/command.c       | 250 +++++++++++++++++++++++++------------
 libs/vkd3d/device.c        |  38 ++++++
 libs/vkd3d/meson.build     |   1 +
 libs/vkd3d/shared_fence.c  | 149 ++++++++++++++++++++++
 libs/vkd3d/shared_fence.h  |  11 ++
 libs/vkd3d/vkd3d_private.h |  50 +++++---
 6 files changed, 405 insertions(+), 94 deletions(-)
 create mode 100644 libs/vkd3d/shared_fence.c
 create mode 100644 libs/vkd3d/shared_fence.h

diff --git a/libs/vkd3d/command.c b/libs/vkd3d/command.c
index 64e4e4ac4..3ce776eec 100644
--- a/libs/vkd3d/command.c
+++ b/libs/vkd3d/command.c
@@ -560,11 +560,21 @@ static void d3d12_fence_dec_ref(struct d3d12_fence *fence)
         vkd3d_private_store_destroy(&fence->private_store);
         d3d12_fence_destroy_vk_objects(fence);
 
-        vkd3d_free(fence->events);
         vkd3d_free(fence->pending_updates);
         pthread_mutex_destroy(&fence->mutex);
-        pthread_cond_destroy(&fence->cond);
-        pthread_cond_destroy(&fence->null_event_cond);
+
+        if (fence->is_shared)
+        {
+            CloseHandle(fence->shared.handle);
+            shared_fence_close(fence->shared.fence);
+        }
+        else
+        {
+            vkd3d_free(fence->local.events);
+            pthread_cond_destroy(&fence->local.cond);
+            pthread_cond_destroy(&fence->local.null_event_cond);
+        }
+
         vkd3d_free(fence);
     }
 }
@@ -600,11 +610,13 @@ static void d3d12_fence_signal_external_events_locked(struct d3d12_fence *fence)
     unsigned int i, j;
     HRESULT hr;
 
-    for (i = 0, j = 0; i < fence->event_count; ++i)
+    assert(!fence->is_shared);
+
+    for (i = 0, j = 0; i < fence->local.event_count; ++i)
     {
-        struct vkd3d_waiting_event *current = &fence->events[i];
+        struct vkd3d_waiting_event *current = &fence->local.events[i];
 
-        if (current->value <= fence->virtual_value)
+        if (current->value <= fence->local.virtual_value)
         {
             if (current->event)
             {
@@ -620,23 +632,25 @@ static void d3d12_fence_signal_external_events_locked(struct d3d12_fence *fence)
         else
         {
             if (i != j)
-                fence->events[j] = *current;
+                fence->local.events[j] = *current;
             ++j;
         }
     }
 
-    fence->event_count = j;
+    fence->local.event_count = j;
 
     if (signal_null_event_cond)
-        pthread_cond_broadcast(&fence->null_event_cond);
+        pthread_cond_broadcast(&fence->local.null_event_cond);
 }
 
 static void d3d12_fence_block_until_pending_value_reaches_locked(struct d3d12_fence *fence, UINT64 pending_value)
 {
-    while (pending_value > fence->max_pending_virtual_timeline_value)
+    assert(!fence->is_shared);
+
+    while (pending_value > fence->local.max_pending_virtual_timeline_value)
     {
         TRACE("Blocking wait on fence %p until it reaches 0x%"PRIx64".\n", fence, pending_value);
-        pthread_cond_wait(&fence->cond, &fence->mutex);
+        pthread_cond_wait(&fence->local.cond, &fence->mutex);
     }
 }
 
@@ -645,13 +659,15 @@ static void d3d12_fence_update_pending_value_locked(struct d3d12_fence *fence)
     uint64_t new_max_pending_virtual_timeline_value = 0;
     size_t i;
 
+    assert(!fence->is_shared);
+
     for (i = 0; i < fence->pending_updates_count; i++)
         new_max_pending_virtual_timeline_value = max(fence->pending_updates[i].virtual_value, new_max_pending_virtual_timeline_value);
-    new_max_pending_virtual_timeline_value = max(fence->virtual_value, new_max_pending_virtual_timeline_value);
+    new_max_pending_virtual_timeline_value = max(fence->local.virtual_value, new_max_pending_virtual_timeline_value);
 
     /* If we're signalling the fence, wake up any submission threads which can now safely kick work. */
-    fence->max_pending_virtual_timeline_value = new_max_pending_virtual_timeline_value;
-    pthread_cond_broadcast(&fence->cond);
+    fence->local.max_pending_virtual_timeline_value = new_max_pending_virtual_timeline_value;
+    pthread_cond_broadcast(&fence->local.cond);
 }
 
 static void d3d12_fence_lock(struct d3d12_fence *fence)
@@ -669,9 +685,11 @@ static bool d3d12_fence_can_elide_wait_semaphore_locked(struct d3d12_fence *fenc
 {
     unsigned int i;
 
+    assert(!fence->is_shared);
+
     /* Relevant if the semaphore has been signalled already on host.
      * We should not wait on the timeline semaphore directly, we can simply submit in-place. */
-    if (fence->virtual_value >= value)
+    if (fence->local.virtual_value >= value)
         return true;
 
     /* We can elide a wait if we can use the submission order guarantee.
@@ -694,13 +712,15 @@ static HRESULT d3d12_fence_signal_cpu_timeline_semaphore(struct d3d12_fence *fen
 {
     int rc;
 
+    assert(!fence->is_shared);
+
     if ((rc = pthread_mutex_lock(&fence->mutex)))
     {
         ERR("Failed to lock mutex, error %d.\n", rc);
         return hresult_from_errno(rc);
     }
 
-    fence->virtual_value = value;
+    fence->local.virtual_value = value;
     d3d12_fence_signal_external_events_locked(fence);
     d3d12_fence_update_pending_value_locked(fence);
     pthread_mutex_unlock(&fence->mutex);
@@ -726,8 +746,10 @@ static uint64_t d3d12_fence_get_physical_wait_value_locked(struct d3d12_fence *f
     uint64_t target_physical_value = UINT64_MAX;
     size_t i;
 
+    assert(!fence->is_shared);
+
     /* This shouldn't happen, we will have elided the wait completely in can_elide_wait_semaphore_locked. */
-    assert(virtual_value > fence->virtual_value);
+    assert(virtual_value > fence->local.virtual_value);
 
     /* Find the smallest physical value which is at least the virtual value. */
     for (i = 0; i < fence->pending_updates_count; i++)
@@ -745,6 +767,7 @@ static uint64_t d3d12_fence_get_physical_wait_value_locked(struct d3d12_fence *f
 
 static HRESULT d3d12_fence_signal(struct d3d12_fence *fence, uint64_t physical_value)
 {
+    uint64_t virtual_value;
     bool did_signal;
     size_t i;
     int rc;
@@ -769,8 +792,14 @@ static HRESULT d3d12_fence_signal(struct d3d12_fence *fence, uint64_t physical_v
         {
             if (fence->physical_value == fence->pending_updates[i].physical_value)
             {
-                fence->virtual_value = fence->pending_updates[i].virtual_value;
-                d3d12_fence_signal_external_events_locked(fence);
+                virtual_value = fence->pending_updates[i].virtual_value;
+                if (fence->is_shared)
+                    shared_fence_signal(fence->shared.fence, virtual_value);
+                else
+                {
+                    fence->local.virtual_value = virtual_value;
+                    d3d12_fence_signal_external_events_locked(fence);
+                }
                 fence->pending_updates[i] = fence->pending_updates[--fence->pending_updates_count];
                 did_signal = true;
                 break;
@@ -782,7 +811,8 @@ static HRESULT d3d12_fence_signal(struct d3d12_fence *fence, uint64_t physical_v
     }
 
     /* In case we have a rewind signalled from GPU, we need to recompute the max pending timeline value. */
-    d3d12_fence_update_pending_value_locked(fence);
+    if (!fence->is_shared)
+        d3d12_fence_update_pending_value_locked(fence);
 
     pthread_mutex_unlock(&fence->mutex);
     return S_OK;
@@ -884,19 +914,25 @@ static HRESULT STDMETHODCALLTYPE d3d12_fence_GetDevice(d3d12_fence_iface *iface,
 static UINT64 STDMETHODCALLTYPE d3d12_fence_GetCompletedValue(d3d12_fence_iface *iface)
 {
     struct d3d12_fence *fence = impl_from_ID3D12Fence1(iface);
-    uint64_t completed_value;
-    int rc;
 
     TRACE("iface %p.\n", iface);
 
-    if ((rc = pthread_mutex_lock(&fence->mutex)))
+    if (fence->is_shared)
+        return shared_fence_get_value(fence->shared.fence);
+    else
     {
-        ERR("Failed to lock mutex, error %d.\n", rc);
-        return 0;
+        uint64_t completed_value;
+        int rc;
+
+        if ((rc = pthread_mutex_lock(&fence->mutex)))
+        {
+            ERR("Failed to lock mutex, error %d.\n", rc);
+            return 0;
+        }
+        completed_value = fence->local.virtual_value;
+        pthread_mutex_unlock(&fence->mutex);
+        return completed_value;
     }
-    completed_value = fence->virtual_value;
-    pthread_mutex_unlock(&fence->mutex);
-    return completed_value;
 }
 
 HRESULT d3d12_fence_set_event_on_completion(struct d3d12_fence *fence,
@@ -907,13 +943,15 @@ HRESULT d3d12_fence_set_event_on_completion(struct d3d12_fence *fence,
     bool latch;
     int rc;
 
+    assert(!fence->is_shared);
+
     if ((rc = pthread_mutex_lock(&fence->mutex)))
     {
         ERR("Failed to lock mutex, error %d.\n", rc);
         return hresult_from_errno(rc);
     }
 
-    if (value <= fence->virtual_value)
+    if (value <= fence->local.virtual_value)
     {
         if (event)
         {
@@ -929,9 +967,9 @@ HRESULT d3d12_fence_set_event_on_completion(struct d3d12_fence *fence,
         return S_OK;
     }
 
-    for (i = 0; i < fence->event_count; ++i)
+    for (i = 0; i < fence->local.event_count; ++i)
     {
-        struct vkd3d_waiting_event *current = &fence->events[i];
+        struct vkd3d_waiting_event *current = &fence->local.events[i];
         if (current->value == value && event && current->event == event)
         {
             WARN("Event completion for (%p, %#"PRIx64") is already in the list.\n",
@@ -941,29 +979,29 @@ HRESULT d3d12_fence_set_event_on_completion(struct d3d12_fence *fence,
         }
     }
 
-    if (!vkd3d_array_reserve((void **)&fence->events, &fence->events_size,
-            fence->event_count + 1, sizeof(*fence->events)))
+    if (!vkd3d_array_reserve((void **)&fence->local.events, &fence->local.events_size,
+            fence->local.event_count + 1, sizeof(*fence->local.events)))
     {
         WARN("Failed to add event.\n");
         pthread_mutex_unlock(&fence->mutex);
         return E_OUTOFMEMORY;
     }
 
-    fence->events[fence->event_count].value = value;
-    fence->events[fence->event_count].event = event;
-    fence->events[fence->event_count].type  = type;
-    fence->events[fence->event_count].latch = &latch;
-    ++fence->event_count;
+    fence->local.events[fence->local.event_count].value = value;
+    fence->local.events[fence->local.event_count].event = event;
+    fence->local.events[fence->local.event_count].type  = type;
+    fence->local.events[fence->local.event_count].latch = &latch;
+    ++fence->local.event_count;
 
     /* If event is NULL, we need to block until the fence value completes.
      * Implement this in a uniform way where we pretend we have a dummy event.
-     * A NULL fence->events[].event means that we should set latch to true
+     * A NULL fence->local.events[].event means that we should set latch to true
      * and signal a condition variable instead of calling external signal_event callback. */
     if (!event)
     {
         latch = false;
         while (!latch)
-            pthread_cond_wait(&fence->null_event_cond, &fence->mutex);
+            pthread_cond_wait(&fence->local.null_event_cond, &fence->mutex);
     }
 
     pthread_mutex_unlock(&fence->mutex);
@@ -977,7 +1015,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_fence_SetEventOnCompletion(d3d12_fence_if
 
     TRACE("iface %p, value %#"PRIx64", event %p.\n", iface, value, event);
 
-    return d3d12_fence_set_event_on_completion(fence, value, event, VKD3D_WAITING_EVENT_TYPE_EVENT);
+    if (fence->is_shared)
+        return shared_fence_wait(fence->shared.fence, event, value) ? S_OK : E_FAIL;
+    else
+        return d3d12_fence_set_event_on_completion(fence, value, event, VKD3D_WAITING_EVENT_TYPE_EVENT);
 }
 
 static HRESULT STDMETHODCALLTYPE d3d12_fence_Signal(d3d12_fence_iface *iface, UINT64 value)
@@ -986,7 +1027,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_fence_Signal(d3d12_fence_iface *iface, UI
 
     TRACE("iface %p, value %#"PRIx64".\n", iface, value);
 
-    return d3d12_fence_signal_cpu_timeline_semaphore(fence, value);
+    if (fence->is_shared)
+        return shared_fence_signal(fence->shared.fence, value) ? S_OK : E_FAIL;
+    else
+        return d3d12_fence_signal_cpu_timeline_semaphore(fence, value);
 }
 
 static D3D12_FENCE_FLAGS STDMETHODCALLTYPE d3d12_fence_GetCreationFlags(d3d12_fence_iface *iface)
@@ -1019,18 +1063,8 @@ CONST_VTBL struct ID3D12Fence1Vtbl d3d12_fence_vtbl =
     d3d12_fence_GetCreationFlags,
 };
 
-static HRESULT d3d12_fence_init_timeline(struct d3d12_fence *fence, struct d3d12_device *device,
-        UINT64 initial_value)
-{
-    fence->virtual_value = initial_value;
-    fence->max_pending_virtual_timeline_value = initial_value;
-    fence->physical_value = 0;
-    fence->counter = 0;
-    return vkd3d_create_timeline_semaphore(device, 0, &fence->timeline_semaphore);
-}
-
 static HRESULT d3d12_fence_init(struct d3d12_fence *fence, struct d3d12_device *device,
-        UINT64 initial_value, D3D12_FENCE_FLAGS flags)
+        UINT64 initial_value, D3D12_FENCE_FLAGS flags, HANDLE handle)
 {
     HRESULT hr;
     int rc;
@@ -1040,7 +1074,18 @@ static HRESULT d3d12_fence_init(struct d3d12_fence *fence, struct d3d12_device *
     fence->refcount = 1;
     fence->d3d12_flags = flags;
 
-    if (FAILED(hr = d3d12_fence_init_timeline(fence, device, initial_value)))
+    fence->pending_updates = NULL;
+    fence->pending_updates_count = 0;
+    fence->pending_updates_size = 0;
+
+    fence->is_shared = !!(flags & D3D12_FENCE_FLAG_SHARED);
+
+    if (flags & ~D3D12_FENCE_FLAG_SHARED)
+        FIXME("Ignoring flags %#x.\n", flags);
+
+    fence->physical_value = 0;
+    fence->counter = 0;
+    if (FAILED(hr = vkd3d_create_timeline_semaphore(device, 0, &fence->timeline_semaphore)))
         return hr;
 
     if ((rc = pthread_mutex_init(&fence->mutex, NULL)))
@@ -1049,38 +1094,53 @@ static HRESULT d3d12_fence_init(struct d3d12_fence *fence, struct d3d12_device *
         return hresult_from_errno(rc);
     }
 
-    if ((rc = pthread_cond_init(&fence->cond, NULL)))
+    if (FAILED(hr = vkd3d_private_store_init(&fence->private_store)))
     {
-        ERR("Failed to initialize cond variable, error %d.\n", rc);
         pthread_mutex_destroy(&fence->mutex);
-        return hresult_from_errno(rc);
+        return hr;
     }
 
-    if ((rc = pthread_cond_init(&fence->null_event_cond, NULL)))
+    if (fence->is_shared)
     {
-        ERR("Failed to initialize cond variable, error %d.\n", rc);
-        pthread_mutex_destroy(&fence->mutex);
-        pthread_cond_destroy(&fence->cond);
-        return hresult_from_errno(rc);
-    }
+        if (handle)
+            DuplicateHandle(GetCurrentProcess(), handle, GetCurrentProcess(), &fence->shared.handle, 0, FALSE, DUPLICATE_SAME_ACCESS);
+        else
+            fence->shared.handle = create_shared_fence(initial_value);
 
-    if (flags)
-        FIXME("Ignoring flags %#x.\n", flags);
+        if (!fence->shared.handle)
+        {
+            vkd3d_private_store_destroy(&fence->private_store);
+            pthread_mutex_destroy(&fence->mutex);
+            return E_FAIL;
+        }
 
-    fence->events = NULL;
-    fence->events_size = 0;
-    fence->event_count = 0;
+        fence->shared.fence = open_shared_fence(fence->shared.handle);
+    }
+    else
+    {
+        if ((rc = pthread_cond_init(&fence->local.cond, NULL)))
+        {
+            ERR("Failed to initialize cond variable, error %d.\n", rc);
+            vkd3d_private_store_destroy(&fence->private_store);
+            pthread_mutex_destroy(&fence->mutex);
+            return hresult_from_errno(rc);
+        }
 
-    fence->pending_updates = NULL;
-    fence->pending_updates_count = 0;
-    fence->pending_updates_size = 0;
+        if ((rc = pthread_cond_init(&fence->local.null_event_cond, NULL)))
+        {
+            ERR("Failed to initialize cond variable, error %d.\n", rc);
+            vkd3d_private_store_destroy(&fence->private_store);
+            pthread_cond_destroy(&fence->local.cond);
+            pthread_mutex_destroy(&fence->mutex);
+            return hresult_from_errno(rc);
+        }
 
-    if (FAILED(hr = vkd3d_private_store_init(&fence->private_store)))
-    {
-        pthread_mutex_destroy(&fence->mutex);
-        pthread_cond_destroy(&fence->cond);
-        pthread_cond_destroy(&fence->null_event_cond);
-        return hr;
+        fence->local.events = NULL;
+        fence->local.events_size = 0;
+        fence->local.event_count = 0;
+
+        fence->local.virtual_value = initial_value;
+        fence->local.max_pending_virtual_timeline_value = initial_value;
     }
 
     d3d12_device_add_ref(fence->device = device);
@@ -1097,7 +1157,7 @@ HRESULT d3d12_fence_create(struct d3d12_device *device,
     if (!(object = vkd3d_malloc(sizeof(*object))))
         return E_OUTOFMEMORY;
 
-    if (SUCCEEDED(hr = d3d12_fence_init(object, device, initial_value, flags)))
+    if (SUCCEEDED(hr = d3d12_fence_init(object, device, initial_value, flags, NULL)))
         TRACE("Created fence %p.\n", object);
     else
         ERR("Failed to create fence.\n");
@@ -1106,6 +1166,24 @@ HRESULT d3d12_fence_create(struct d3d12_device *device,
     return hr;
 }
 
+HRESULT d3d12_shared_fence_open(struct d3d12_device *device, HANDLE handle, struct d3d12_fence **fence)
+{
+    struct d3d12_fence *object;
+    HRESULT hr;
+
+    if (!(object = vkd3d_malloc(sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    if (SUCCEEDED(hr = d3d12_fence_init(object, device, 0, D3D12_FENCE_FLAG_SHARED, handle)))
+        TRACE("Opened fence %p.\n", object);
+    else
+        ERR("Failed to open fence.\n");
+
+    *fence = object;
+    return hr;
+
+}
+
 /* Command buffers */
 static void d3d12_command_list_mark_as_invalid(struct d3d12_command_list *list,
         const char *message, ...)
@@ -10799,6 +10877,14 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_queue_Wait(ID3D12CommandQueue *if
     sub.type = VKD3D_SUBMISSION_WAIT;
     sub.wait.fence = fence;
     sub.wait.value = value;
+    sub.wait.handle = NULL;
+
+    if (fence->is_shared)
+    {
+        sub.wait.handle = CreateEventW(NULL, TRUE, FALSE, NULL);
+        shared_fence_wait(fence->shared.fence, sub.wait.handle, value);
+    }
+
     d3d12_command_queue_add_submission(command_queue, &sub);
     return S_OK;
 }
@@ -11818,7 +11904,13 @@ static void *d3d12_command_queue_submission_worker_main(void *userdata)
 
         case VKD3D_SUBMISSION_WAIT:
             VKD3D_REGION_BEGIN(queue_wait);
-            d3d12_command_queue_wait(queue, submission.wait.fence, submission.wait.value);
+            if (submission.wait.fence->is_shared)
+            {
+                WaitForSingleObject(submission.wait.handle, INFINITE);
+                CloseHandle(submission.wait.handle);
+            }
+            else
+                d3d12_command_queue_wait(queue, submission.wait.fence, submission.wait.value);
             d3d12_fence_dec_ref(submission.wait.fence);
             VKD3D_REGION_END(queue_wait);
             break;
diff --git a/libs/vkd3d/device.c b/libs/vkd3d/device.c
index 0eb34440a..e99428930 100644
--- a/libs/vkd3d/device.c
+++ b/libs/vkd3d/device.c
@@ -4315,6 +4315,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateSharedHandle(d3d12_device_if
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
     struct d3d12_device *device = impl_from_ID3D12Device(iface);
     ID3D12Resource *resource_iface;
+    ID3D12Fence *fence_iface;
 
     TRACE("iface %p, object %p, attributes %p, access %#x, name %s, handle %p\n",
             iface, object, attributes, access, debugstr_w(name), handle);
@@ -4348,6 +4349,29 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateSharedHandle(d3d12_device_if
         ID3D12Resource_Release(resource_iface);
         return vr ? E_FAIL : S_OK;
     }
+    if (SUCCEEDED(ID3D12DeviceChild_QueryInterface(object, &IID_ID3D12Fence, (void**)&fence_iface)))
+    {
+        struct d3d12_fence *fence = impl_from_ID3D12Fence(fence_iface);
+        BOOL ret;
+
+        if (!fence->is_shared)
+        {
+            ID3D12Fence_Release(fence_iface);
+            return DXGI_ERROR_INVALID_CALL;
+        }
+
+        if (attributes)
+            FIXME("attributes %p not handled\n", attributes);
+        if (access)
+            FIXME("access %#x not handled\n", access);
+        if (name)
+            FIXME("name %s not handled\n", debugstr_w(name));
+
+        ret = DuplicateHandle(GetCurrentProcess(), fence->shared.handle, GetCurrentProcess(), handle, 0, FALSE, DUPLICATE_SAME_ACCESS);
+
+        ID3D12Fence_Release(fence_iface);
+        return ret ? S_OK : E_FAIL;
+    }
 
     FIXME("Creating shared handle for type of object %p unsupported\n", object);
     return E_NOTIMPL;
@@ -4440,6 +4464,20 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_OpenSharedHandle(d3d12_device_ifac
 
         return return_interface(&resource->ID3D12Resource_iface, &IID_ID3D12Resource, riid, object);
     }
+    if (IsEqualGUID(riid, &IID_ID3D12Fence))
+    {
+        struct d3d12_fence *fence;
+
+        hr = d3d12_shared_fence_open(device, handle, &fence);
+
+        if (FAILED(hr))
+        {
+            WARN("Failed to open shared ID3D12Fence, hr %#x.\n", hr);
+            return hr;
+        }
+
+        return return_interface(&fence->ID3D12Fence_iface, &IID_ID3D12Fence, riid, object);
+    }
 
     FIXME("Opening shared handle type %s unsupported\n", debugstr_guid(riid));
     return E_NOTIMPL;
diff --git a/libs/vkd3d/meson.build b/libs/vkd3d/meson.build
index 3bfd8f1ae..ec91590ce 100644
--- a/libs/vkd3d/meson.build
+++ b/libs/vkd3d/meson.build
@@ -41,6 +41,7 @@ vkd3d_src = [
   'meta.c',
   'platform.c',
   'resource.c',
+  'shared_fence.c',
   'shared_metadata.c',
   'state.c',
   'utils.c',
diff --git a/libs/vkd3d/shared_fence.c b/libs/vkd3d/shared_fence.c
new file mode 100644
index 000000000..a6167d405
--- /dev/null
+++ b/libs/vkd3d/shared_fence.c
@@ -0,0 +1,149 @@
+#include "shared_fence.h"
+
+/* For now the implementation isn't cross-process.
+ * When fixing this, we just need to reimplement the blocking wait with an event handle,
+ * removing the need for the conditional variable, and use a win32 mutex instead of a critical section */
+
+#define MAX_WAIT_COUNT 100
+
+struct waiter_thread
+{
+    bool waiting, signaled;
+    HANDLE handle;
+    UINT64 value;
+};
+
+struct shared_fence
+{
+    DWORD pid;
+    UINT64 value;
+    CRITICAL_SECTION *cs;
+    CONDITION_VARIABLE *cv;
+    struct waiter_thread waiters[MAX_WAIT_COUNT];
+};
+
+HANDLE create_shared_fence(UINT64 initial_value)
+{
+    HANDLE mapping = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE | SEC_COMMIT, 0, sizeof(struct shared_fence), NULL);
+    struct shared_fence *fence = open_shared_fence(mapping);
+
+    fence->pid = GetCurrentProcessId();
+    fence->value = initial_value;
+    fence->cs = malloc(sizeof(*fence->cs));
+    fence->cv = malloc(sizeof(*fence->cv));
+    InitializeCriticalSection(fence->cs);
+    InitializeConditionVariable(fence->cv);
+
+    shared_fence_close(fence);
+
+    return mapping;
+}
+
+struct shared_fence *open_shared_fence(HANDLE handle)
+{
+    return MapViewOfFile(handle, FILE_MAP_WRITE, 0, 0, sizeof(struct shared_fence));
+}
+
+void shared_fence_close(struct shared_fence *fence)
+{
+    UnmapViewOfFile(fence);
+}
+
+UINT64 shared_fence_get_value(struct shared_fence *fence)
+{
+    UINT64 value;
+    EnterCriticalSection(fence->cs);
+    value = fence->value;
+    LeaveCriticalSection(fence->cs);
+    return value;
+}
+
+/* Equivalent of SetEventOnCompletion*/
+bool shared_fence_wait(struct shared_fence *fence, HANDLE handle, UINT64 value)
+{
+    struct waiter_thread *waiter;
+    unsigned int i;
+
+    if (fence->pid != GetCurrentProcessId())
+        return false;
+
+    EnterCriticalSection(fence->cs);
+
+    if (fence->value >= value)
+    {
+        LeaveCriticalSection(fence->cs);
+
+        if (handle != NULL && handle != INVALID_HANDLE_VALUE)
+            SetEvent(handle);
+
+        return true;
+    }
+
+    for (i = 0; i < MAX_WAIT_COUNT; i++)
+    {
+        waiter = &fence->waiters[i];
+
+        if (!waiter->waiting)
+        {
+            waiter->waiting = true;
+            waiter->signaled = false;
+            waiter->handle = handle;
+            waiter->value = value;
+            break;
+        }
+    }
+
+    if (i == MAX_WAIT_COUNT)
+    {
+        LeaveCriticalSection(fence->cs);
+        return false;
+    }
+
+    if (handle != NULL && handle != INVALID_HANDLE_VALUE)
+    {
+        LeaveCriticalSection(fence->cs);
+        return true;
+    }
+
+    while (!waiter->signaled)
+        SleepConditionVariableCS(fence->cv, fence->cs, INFINITE);
+
+    waiter->waiting = false;
+
+    LeaveCriticalSection(fence->cs);
+    return true;
+}
+
+bool shared_fence_signal(struct shared_fence *fence, UINT64 value)
+{
+    unsigned int i;
+
+    if (fence->pid != GetCurrentProcessId())
+        return false;
+
+    EnterCriticalSection(fence->cs);
+
+    fence->value = value;
+    for (i = 0; i < MAX_WAIT_COUNT; i++)
+    {
+        struct waiter_thread *waiter = &fence->waiters[i];
+
+        if (waiter->value <= value)
+        {
+            if (waiter->handle != NULL && waiter->handle != INVALID_HANDLE_VALUE)
+            {
+                SetEvent(waiter->handle);
+                waiter->waiting = false;
+            }
+            else
+            {
+                waiter->signaled = true;
+            }
+        }
+    }
+
+    WakeAllConditionVariable(fence->cv);
+    LeaveCriticalSection(fence->cs);
+
+    return true;
+}
diff --git a/libs/vkd3d/shared_fence.h b/libs/vkd3d/shared_fence.h
new file mode 100644
index 000000000..31bd3e676
--- /dev/null
+++ b/libs/vkd3d/shared_fence.h
@@ -0,0 +1,11 @@
+/* simple polytonic cross-process semaphore implementation */
+
+#include <windows.h>
+#include <stdbool.h>
+
+HANDLE create_shared_fence(UINT64 initial_value);
+struct shared_fence *open_shared_fence(HANDLE handle);
+void shared_fence_close(struct shared_fence *fence);
+UINT64 shared_fence_get_value(struct shared_fence *fence);
+bool shared_fence_wait(struct shared_fence *fence, HANDLE handle, UINT64 value);
+bool shared_fence_signal(struct shared_fence *fence, UINT64 value);
diff --git a/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/vkd3d_private.h
index e81e75b90..a9523a9c0 100644
--- a/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/vkd3d_private.h
@@ -40,6 +40,7 @@
 #include "vkd3d_device_vkd3d_ext.h"
 #include "vkd3d_string.h"
 #include "vkd3d_file_utils.h"
+#include "shared_fence.h"
 #include <assert.h>
 #include <inttypes.h>
 #include <limits.h>
@@ -528,10 +529,12 @@ struct d3d12_fence
 
     D3D12_FENCE_FLAGS d3d12_flags;
 
+    struct d3d12_device *device;
+
+    struct vkd3d_private_store private_store;
+
     VkSemaphore timeline_semaphore;
 
-    uint64_t max_pending_virtual_timeline_value;
-    uint64_t virtual_value;
     uint64_t physical_value;
     uint64_t counter;
     struct d3d12_fence_value *pending_updates;
@@ -539,22 +542,36 @@ struct d3d12_fence
     size_t pending_updates_size;
 
     pthread_mutex_t mutex;
-    pthread_cond_t cond;
-    pthread_cond_t null_event_cond;
 
-    struct vkd3d_waiting_event
-    {
-        uint64_t value;
-        HANDLE event;
-        enum vkd3d_waiting_event_type type;
-        bool *latch;
-    } *events;
-    size_t events_size;
-    size_t event_count;
+    bool is_shared;
 
-    struct d3d12_device *device;
+    union
+    {
+        struct
+        {
+            pthread_cond_t cond;
+            pthread_cond_t null_event_cond;
+
+            uint64_t max_pending_virtual_timeline_value;
+            uint64_t virtual_value;
+
+            struct vkd3d_waiting_event
+            {
+                uint64_t value;
+                HANDLE event;
+                enum vkd3d_waiting_event_type type;
+                bool *latch;
+            } *events;
+            size_t events_size;
+            size_t event_count;
+        } local;
 
-    struct vkd3d_private_store private_store;
+        struct
+        {
+            HANDLE handle;
+            struct shared_fence *fence;
+        } shared;
+    };
 };
 
 static inline struct d3d12_fence *impl_from_ID3D12Fence1(ID3D12Fence1 *iface)
@@ -573,6 +590,8 @@ static inline struct d3d12_fence *impl_from_ID3D12Fence(ID3D12Fence *iface)
 
 HRESULT d3d12_fence_create(struct d3d12_device *device,
         uint64_t initial_value, D3D12_FENCE_FLAGS flags, struct d3d12_fence **fence);
+HRESULT d3d12_shared_fence_open(struct d3d12_device *device,
+        HANDLE handle, struct d3d12_fence **fence);
 HRESULT d3d12_fence_set_event_on_completion(struct d3d12_fence *fence,
         UINT64 value, HANDLE event, enum vkd3d_waiting_event_type type);
 
@@ -2269,6 +2288,7 @@ struct vkd3d_sparse_memory_bind_range
 struct d3d12_command_queue_submission_wait
 {
     struct d3d12_fence *fence;
+    HANDLE handle;
     UINT64 value;
 };
 
